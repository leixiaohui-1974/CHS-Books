# ç¬¬ä¸‰ç¯‡ï¼šåœ°è¡¨åœ°ä¸‹æ°´è€¦åˆç³»ç»Ÿ - è¯¦ç»†è®¾è®¡æ–¹æ¡ˆ

**æ—¥æœŸ**: 2025å¹´11æœˆ02æ—¥  
**ç‰ˆæœ¬**: v0.5.0-design  
**çŠ¶æ€**: è®¾è®¡ä¸­

---

## ğŸ“‹ æ€»ä½“æ¦‚è¿°

### æ ¸å¿ƒç›®æ ‡

å»ºç«‹å®Œæ•´çš„åœ°è¡¨åœ°ä¸‹æ°´è€¦åˆå»ºæ¨¡ä½“ç³»ï¼Œä»ç†è®ºåˆ°å®è·µï¼Œä»åŸºç¡€åˆ°é«˜çº§ï¼Œæ¶µç›–ï¼š
- è€¦åˆç†è®ºåŸºç¡€
- è¾¹ç•Œæ¡ä»¶å¤„ç†
- æ•°å€¼æ±‚è§£æ–¹æ³•
- è€¦åˆæ¨¡å‹ç‡å®š
- è€¦åˆç³»ç»Ÿä¸ç¡®å®šæ€§

### æ¡ˆä¾‹è§„åˆ’ï¼ˆ5ä¸ªæ¡ˆä¾‹ï¼‰

1. **æ¡ˆä¾‹11**: è€¦åˆç†è®ºåŸºç¡€
2. **æ¡ˆä¾‹12**: RiveråŒ…è¾¹ç•Œæ¡ä»¶
3. **æ¡ˆä¾‹13**: æ¸—æ¼ä¸è¶Šæµæ¨¡æ‹Ÿ
4. **æ¡ˆä¾‹14**: è€¦åˆæ¨¡å‹ç‡å®š
5. **æ¡ˆä¾‹15**: è€¦åˆç³»ç»Ÿä¸ç¡®å®šæ€§åˆ†æ

---

## ğŸ¯ æ¡ˆä¾‹11ï¼šè€¦åˆç†è®ºåŸºç¡€

### å­¦ä¹ ç›®æ ‡

- ç†è§£åœ°è¡¨æ°´-åœ°ä¸‹æ°´äº¤äº’æœºåˆ¶
- æŒæ¡è€¦åˆæ–¹ç¨‹çš„æ•°å­¦æè¿°
- å®ç°ç®€å•çš„ä¸€ç»´è€¦åˆæ¨¡å‹
- åˆ†æè€¦åˆå¼ºåº¦å½±å“

### ç†è®ºå†…å®¹

#### 1. è€¦åˆæœºåˆ¶

**æ°´é‡äº¤æ¢**ï¼š
- æ²³æµæ¸—æ¼ï¼ˆRiver Leakageï¼‰
- æ¹–æ³Šå…¥æ¸—ï¼ˆLake Infiltrationï¼‰
- è¶Šæµï¼ˆVertical Flowï¼‰
- è’¸å‘è’¸è…¾ï¼ˆETï¼‰

**æ•°å­¦æè¿°**ï¼š
```
åœ°ä¸‹æ°´æµåŠ¨æ–¹ç¨‹ï¼š
âˆ‚h/âˆ‚t = âˆ‡Â·(Kâˆ‡h) + Q_exchange

åœ°è¡¨æ°´æµåŠ¨æ–¹ç¨‹ï¼š
âˆ‚H/âˆ‚t + âˆ‚(uH)/âˆ‚x = Q_exchange

äº¤æ¢é¡¹ï¼š
Q_exchange = C(H - h)
```

å…¶ä¸­ï¼š
- h: åœ°ä¸‹æ°´æ°´å¤´
- H: åœ°è¡¨æ°´æ·±
- K: æ¸—é€ç³»æ•°
- C: æ°´åŠ›ä¼ å¯¼ç³»æ•°
- u: åœ°è¡¨æ°´æµé€Ÿ

#### 2. è€¦åˆç±»å‹

**å¼±è€¦åˆï¼ˆLoosely Coupledï¼‰**ï¼š
- äº¤æ›¿æ±‚è§£åœ°è¡¨å’Œåœ°ä¸‹æ°´
- ä¿¡æ¯åœ¨æ—¶é—´æ­¥ä¹‹é—´ä¼ é€’
- è®¡ç®—æ•ˆç‡é«˜
- å¯èƒ½ä¸ç¨³å®š

**å¼ºè€¦åˆï¼ˆTightly Coupledï¼‰**ï¼š
- åŒæ—¶æ±‚è§£åœ°è¡¨å’Œåœ°ä¸‹æ°´
- è”åˆçŸ©é˜µç³»ç»Ÿ
- ç¨³å®šæ€§å¥½
- è®¡ç®—é‡å¤§

**é¡ºåºè€¦åˆï¼ˆSequential Couplingï¼‰**ï¼š
- å…ˆæ±‚è§£ä¸€ä¸ªç³»ç»Ÿ
- ç»“æœä½œä¸ºå¦ä¸€ä¸ªç³»ç»Ÿçš„è¾¹ç•Œæ¡ä»¶
- é€‚ç”¨äºäº¤äº’è¾ƒå¼±çš„æƒ…å†µ

#### 3. è¾¹ç•Œäº¤äº’

**ç¬¬ä¸€ç±»è¾¹ç•Œï¼ˆDirichletï¼‰**ï¼š
```
h|_boundary = H_surface
```

**ç¬¬ä¸‰ç±»è¾¹ç•Œï¼ˆCauchyï¼‰**ï¼š
```
q = C(H - h)
```

å…¶ä¸­Cä¸ºæ¸—æ¼ç³»æ•°ï¼ˆLeakanceï¼‰ï¼š
```
C = K_bed / b_bed
```
- K_bed: æ²³åºŠæ¸—é€ç³»æ•°
- b_bed: æ²³åºŠåšåº¦

### ä»£ç å®ç°

#### æ ¸å¿ƒåŠŸèƒ½æ¨¡å—

**gwflow/coupling/__init__.py**
```python
"""
åœ°è¡¨åœ°ä¸‹æ°´è€¦åˆæ¨¡å—
"""

from .exchange import (
    compute_exchange_flux,
    leakance_coefficient,
    river_head_gradient
)

from .solver import (
    solve_coupled_weak,
    solve_coupled_strong,
    solve_sequential
)

from .boundary import (
    RiverBoundary,
    LakeBoundary,
    ETBoundary
)

__all__ = [
    'compute_exchange_flux',
    'leakance_coefficient',
    'river_head_gradient',
    'solve_coupled_weak',
    'solve_coupled_strong',
    'solve_sequential',
    'RiverBoundary',
    'LakeBoundary',
    'ETBoundary'
]
```

**gwflow/coupling/exchange.py** (~250è¡Œ)
```python
"""
æ°´é‡äº¤æ¢è®¡ç®—æ¨¡å—
"""

import numpy as np
from typing import Tuple, Optional

def compute_exchange_flux(
    h_gw: np.ndarray,
    h_sw: np.ndarray,
    leakance: float,
    conductance: Optional[float] = None
) -> np.ndarray:
    """
    è®¡ç®—åœ°è¡¨åœ°ä¸‹æ°´äº¤æ¢é€šé‡
    
    Parameters
    ----------
    h_gw : array
        åœ°ä¸‹æ°´æ°´å¤´
    h_sw : array
        åœ°è¡¨æ°´æ°´å¤´
    leakance : float
        æ¸—æ¼ç³»æ•° (1/day)
    conductance : float, optional
        æ°´åŠ›ä¼ å¯¼åº¦ (mÂ²/day)
    
    Returns
    -------
    Q : array
        äº¤æ¢é€šé‡ (mÂ³/day)ï¼Œæ­£å€¼è¡¨ç¤ºåœ°è¡¨æ°´è¡¥ç»™åœ°ä¸‹æ°´
    """
    if conductance is not None:
        Q = conductance * (h_sw - h_gw)
    else:
        Q = leakance * (h_sw - h_gw)
    
    return Q

def leakance_coefficient(
    K_bed: float,
    b_bed: float,
    river_width: Optional[float] = None
) -> float:
    """
    è®¡ç®—æ¸—æ¼ç³»æ•°
    
    C = K_bed / b_bed
    
    æˆ–å¸¦æ²³å®½ï¼š
    C = (K_bed * river_width) / b_bed
    """
    if river_width is not None:
        return (K_bed * river_width) / b_bed
    else:
        return K_bed / b_bed

def river_head_gradient(
    river_stage: float,
    river_bottom: float,
    gw_head: float,
    method: str = 'standard'
) -> float:
    """
    è®¡ç®—æ²³æµ-åœ°ä¸‹æ°´æ°´å¤´æ¢¯åº¦
    
    Parameters
    ----------
    river_stage : float
        æ²³æµæ°´ä½
    river_bottom : float
        æ²³åº•é«˜ç¨‹
    gw_head : float
        åœ°ä¸‹æ°´æ°´å¤´
    method : str
        è®¡ç®—æ–¹æ³•ï¼š'standard', 'clamped', 'disconnected'
    
    Returns
    -------
    gradient : float
        æœ‰æ•ˆæ°´å¤´æ¢¯åº¦
    """
    if method == 'standard':
        return river_stage - gw_head
    
    elif method == 'clamped':
        # é™åˆ¶åœ¨æ²³åº•ä¹‹ä¸Š
        effective_head = max(gw_head, river_bottom)
        return river_stage - effective_head
    
    elif method == 'disconnected':
        # è€ƒè™‘æ²³æµä¸åœ°ä¸‹æ°´æ–­å¼€æƒ…å†µ
        if gw_head < river_bottom:
            return river_stage - river_bottom
        else:
            return river_stage - gw_head
    
    else:
        raise ValueError(f"Unknown method: {method}")
```

**gwflow/coupling/solver.py** (~400è¡Œ)
```python
"""
è€¦åˆæ±‚è§£å™¨
"""

import numpy as np
from scipy.sparse import lil_matrix, csr_matrix
from scipy.sparse.linalg import spsolve
from typing import Dict, Tuple, Callable, Any

def solve_coupled_weak(
    gw_solver: Callable,
    sw_solver: Callable,
    initial_h_gw: np.ndarray,
    initial_h_sw: np.ndarray,
    leakance: float,
    dt: float,
    n_steps: int,
    max_iter: int = 10,
    tol: float = 1e-4,
    verbose: bool = True
) -> Dict[str, Any]:
    """
    å¼±è€¦åˆæ±‚è§£å™¨ï¼ˆè¿­ä»£æ³•ï¼‰
    
    ç®—æ³•æµç¨‹ï¼š
    1. ç”¨å‰ä¸€æ—¶åˆ»çš„h_swæ±‚è§£åœ°ä¸‹æ°´
    2. ç”¨æ–°çš„h_gwæ±‚è§£åœ°è¡¨æ°´
    3. æ£€æŸ¥æ”¶æ•›æ€§
    4. è‹¥æœªæ”¶æ•›ï¼Œè¿”å›æ­¥éª¤1
    
    Parameters
    ----------
    gw_solver : callable
        åœ°ä¸‹æ°´æ±‚è§£å™¨å‡½æ•°
    sw_solver : callable
        åœ°è¡¨æ°´æ±‚è§£å™¨å‡½æ•°
    initial_h_gw : array
        åœ°ä¸‹æ°´åˆå§‹æ°´å¤´
    initial_h_sw : array
        åœ°è¡¨æ°´åˆå§‹æ°´å¤´
    leakance : float
        æ¸—æ¼ç³»æ•°
    dt : float
        æ—¶é—´æ­¥é•¿
    n_steps : int
        æ—¶é—´æ­¥æ•°
    max_iter : int
        æ¯ä¸ªæ—¶é—´æ­¥æœ€å¤§è¿­ä»£æ¬¡æ•°
    tol : float
        æ”¶æ•›å®¹å·®
    verbose : bool
        æ˜¯å¦è¾“å‡ºè¯¦ç»†ä¿¡æ¯
    
    Returns
    -------
    results : dict
        æ±‚è§£ç»“æœï¼ŒåŒ…å«ï¼š
        - h_gw_history: åœ°ä¸‹æ°´æ°´å¤´å†å²
        - h_sw_history: åœ°è¡¨æ°´æ°´å¤´å†å²
        - exchange_history: äº¤æ¢é€šé‡å†å²
        - convergence_history: æ”¶æ•›å†å²
    """
    n_gw = len(initial_h_gw)
    n_sw = len(initial_h_sw)
    
    h_gw = initial_h_gw.copy()
    h_sw = initial_h_sw.copy()
    
    h_gw_history = np.zeros((n_steps + 1, n_gw))
    h_sw_history = np.zeros((n_steps + 1, n_sw))
    exchange_history = np.zeros((n_steps, n_gw))
    convergence_history = []
    
    h_gw_history[0] = h_gw
    h_sw_history[0] = h_sw
    
    for step in range(n_steps):
        if verbose and step % 10 == 0:
            print(f"Time step {step}/{n_steps}")
        
        # å¼±è€¦åˆè¿­ä»£
        for iter in range(max_iter):
            h_gw_old = h_gw.copy()
            h_sw_old = h_sw.copy()
            
            # 1. æ±‚è§£åœ°ä¸‹æ°´ï¼ˆä½¿ç”¨å½“å‰h_swï¼‰
            exchange_flux = compute_exchange_flux(h_gw, h_sw, leakance)
            h_gw = gw_solver(h_gw, exchange_flux, dt)
            
            # 2. æ±‚è§£åœ°è¡¨æ°´ï¼ˆä½¿ç”¨æ–°çš„h_gwï¼‰
            exchange_flux = compute_exchange_flux(h_gw, h_sw, leakance)
            h_sw = sw_solver(h_sw, -exchange_flux, dt)
            
            # 3. æ£€æŸ¥æ”¶æ•›
            error_gw = np.max(np.abs(h_gw - h_gw_old))
            error_sw = np.max(np.abs(h_sw - h_sw_old))
            max_error = max(error_gw, error_sw)
            
            if max_error < tol:
                convergence_history.append({
                    'step': step,
                    'iterations': iter + 1,
                    'error': max_error
                })
                break
        
        # è®°å½•ç»“æœ
        h_gw_history[step + 1] = h_gw
        h_sw_history[step + 1] = h_sw
        exchange_history[step] = compute_exchange_flux(h_gw, h_sw, leakance)
    
    return {
        'h_gw_history': h_gw_history,
        'h_sw_history': h_sw_history,
        'exchange_history': exchange_history,
        'convergence_history': convergence_history,
        'success': True
    }

def solve_coupled_strong(
    K_gw: np.ndarray,
    dx: float,
    dy: float,
    leakance: float,
    initial_h_gw: np.ndarray,
    initial_h_sw: np.ndarray,
    dt: float,
    n_steps: int,
    verbose: bool = True
) -> Dict[str, Any]:
    """
    å¼ºè€¦åˆæ±‚è§£å™¨ï¼ˆè”åˆçŸ©é˜µï¼‰
    
    æ„å»ºè”åˆçº¿æ€§ç³»ç»Ÿï¼š
    [A_gw    B_exchange] [h_gw]   [b_gw]
    [B_exchange  A_sw  ] [h_sw] = [b_sw]
    
    åŒæ—¶æ±‚è§£åœ°è¡¨å’Œåœ°ä¸‹æ°´
    """
    # å®ç°ç•¥
    pass
```

**gwflow/coupling/boundary.py** (~300è¡Œ)
```python
"""
è€¦åˆè¾¹ç•Œæ¡ä»¶ç±»
"""

import numpy as np
from typing import Optional, Callable

class RiverBoundary:
    """
    æ²³æµè¾¹ç•Œæ¡ä»¶
    
    æ¨¡æ‹Ÿæ²³æµä¸åœ°ä¸‹æ°´çš„ç›¸äº’ä½œç”¨
    """
    
    def __init__(
        self,
        river_stage: float,
        river_bottom: float,
        river_bed_K: float,
        river_bed_thickness: float,
        river_width: float,
        river_length: float
    ):
        """
        Parameters
        ----------
        river_stage : float
            æ²³æµæ°´ä½ (m)
        river_bottom : float
            æ²³åº•é«˜ç¨‹ (m)
        river_bed_K : float
            æ²³åºŠæ¸—é€ç³»æ•° (m/day)
        river_bed_thickness : float
            æ²³åºŠåšåº¦ (m)
        river_width : float
            æ²³å®½ (m)
        river_length : float
            æ²³æ®µé•¿åº¦ (m)
        """
        self.river_stage = river_stage
        self.river_bottom = river_bottom
        self.river_bed_K = river_bed_K
        self.river_bed_thickness = river_bed_thickness
        self.river_width = river_width
        self.river_length = river_length
        
        # è®¡ç®—æ°´åŠ›ä¼ å¯¼åº¦
        self.conductance = (
            river_bed_K * river_width * river_length / river_bed_thickness
        )
    
    def compute_flux(
        self,
        gw_head: float,
        method: str = 'standard'
    ) -> float:
        """
        è®¡ç®—æ²³æµ-åœ°ä¸‹æ°´äº¤æ¢é€šé‡
        
        Q = C * (H_river - h_gw)
        
        Parameters
        ----------
        gw_head : float
            åœ°ä¸‹æ°´æ°´å¤´
        method : str
            è®¡ç®—æ–¹æ³•
        
        Returns
        -------
        flux : float
            äº¤æ¢é€šé‡ (mÂ³/day)ï¼Œæ­£å€¼ä¸ºè¡¥ç»™åœ°ä¸‹æ°´
        """
        if method == 'standard':
            flux = self.conductance * (self.river_stage - gw_head)
        
        elif method == 'disconnected':
            # è€ƒè™‘æ²³æµæ–­å¼€æƒ…å†µ
            if gw_head < self.river_bottom:
                # åœ°ä¸‹æ°´ä½äºæ²³åº•ï¼Œæ²³æµä¸èƒ½ç»§ç»­ä¾›æ°´
                flux = self.conductance * (self.river_stage - self.river_bottom)
            else:
                flux = self.conductance * (self.river_stage - gw_head)
        
        else:
            raise ValueError(f"Unknown method: {method}")
        
        return flux
    
    def update_stage(self, new_stage: float):
        """æ›´æ–°æ²³æµæ°´ä½"""
        self.river_stage = new_stage

class LakeBoundary:
    """
    æ¹–æ³Šè¾¹ç•Œæ¡ä»¶
    """
    
    def __init__(
        self,
        lake_stage: float,
        lake_bottom: float,
        lake_bed_K: float,
        lake_bed_thickness: float,
        lake_area: float
    ):
        self.lake_stage = lake_stage
        self.lake_bottom = lake_bottom
        self.lake_bed_K = lake_bed_K
        self.lake_bed_thickness = lake_bed_thickness
        self.lake_area = lake_area
        
        self.conductance = lake_bed_K * lake_area / lake_bed_thickness
    
    def compute_flux(self, gw_head: float) -> float:
        """è®¡ç®—æ¹–æ³Š-åœ°ä¸‹æ°´äº¤æ¢é€šé‡"""
        return self.conductance * (self.lake_stage - gw_head)

class ETBoundary:
    """
    è’¸æ•£å‘è¾¹ç•Œæ¡ä»¶
    """
    
    def __init__(
        self,
        et_max: float,
        extinction_depth: float,
        land_surface_elevation: float
    ):
        """
        Parameters
        ----------
        et_max : float
            æœ€å¤§è’¸æ•£å‘ç‡ (m/day)
        extinction_depth : float
            è’¸æ•£å‘æ¶ˆé€€æ·±åº¦ (m)
        land_surface_elevation : float
            åœ°è¡¨é«˜ç¨‹ (m)
        """
        self.et_max = et_max
        self.extinction_depth = extinction_depth
        self.land_surface_elevation = land_surface_elevation
    
    def compute_et(self, gw_head: float) -> float:
        """
        è®¡ç®—å®é™…è’¸æ•£å‘ç‡
        
        ET = ET_max * (h - (z_surface - d)) / d
        
        å½“h > z_surfaceæ—¶ï¼ŒET = ET_max
        å½“h < z_surface - dæ—¶ï¼ŒET = 0
        """
        depth_below_surface = self.land_surface_elevation - gw_head
        
        if depth_below_surface <= 0:
            # åœ°ä¸‹æ°´ä½åœ¨åœ°è¡¨ä¹‹ä¸Š
            return self.et_max
        elif depth_below_surface >= self.extinction_depth:
            # åœ°ä¸‹æ°´ä½å¤ªæ·±
            return 0.0
        else:
            # çº¿æ€§æ’å€¼
            ratio = 1.0 - depth_below_surface / self.extinction_depth
            return self.et_max * ratio
```

### æ¡ˆä¾‹11ä¸»ç¨‹åº

**code/examples/case_11/case_11_coupling_basic.py** (~450è¡Œ)

```python
"""
æ¡ˆä¾‹11ï¼šåœ°è¡¨åœ°ä¸‹æ°´è€¦åˆåŸºç¡€

æ¼”ç¤ºå†…å®¹ï¼š
1. ä¸€ç»´æ²³æµ-åœ°ä¸‹æ°´è€¦åˆæ¨¡å‹
2. å¼±è€¦åˆæ±‚è§£æ–¹æ³•
3. æ²³æµæ¸—æ¼åˆ†æ
4. è€¦åˆå¼ºåº¦å½±å“

åœºæ™¯è®¾ç½®ï¼š
- 1Då«æ°´å±‚ï¼Œé•¿åº¦1000m
- æ²³æµä½äºä¸­å¿ƒä½ç½®
- åˆ†ææ²³æµå¯¹åœ°ä¸‹æ°´çš„å½±å“
"""

import numpy as np
import matplotlib.pyplot as plt
from gwflow.coupling import (
    compute_exchange_flux,
    leakance_coefficient,
    RiverBoundary
)
from gwflow.solvers import solve_1d_steady_gw
from gwflow.visualization import plot_1d_head

# æ¨¡å‹å‚æ•°
L = 1000.0  # å«æ°´å±‚é•¿åº¦ (m)
nx = 101    # ç½‘æ ¼æ•°
dx = L / (nx - 1)
x = np.linspace(0, L, nx)

K = 10.0    # æ¸—é€ç³»æ•° (m/day)
b = 20.0    # å«æ°´å±‚åšåº¦ (m)
T = K * b   # å¯¼æ°´ç³»æ•°

# æ²³æµå‚æ•°
river_pos_idx = nx // 2
river_stage = 30.0        # æ²³æµæ°´ä½ (m)
river_bottom = 20.0       # æ²³åº•é«˜ç¨‹ (m)
river_width = 50.0        # æ²³å®½ (m)
river_bed_K = 1.0         # æ²³åºŠæ¸—é€ç³»æ•° (m/day)
river_bed_thickness = 2.0 # æ²³åºŠåšåº¦ (m)

# åˆ›å»ºæ²³æµè¾¹ç•Œ
river = RiverBoundary(
    river_stage=river_stage,
    river_bottom=river_bottom,
    river_bed_K=river_bed_K,
    river_bed_thickness=river_bed_thickness,
    river_width=river_width,
    river_length=dx
)

print("="*60)
print("æ¡ˆä¾‹11ï¼šåœ°è¡¨åœ°ä¸‹æ°´è€¦åˆåŸºç¡€")
print("="*60)
print(f"å«æ°´å±‚é•¿åº¦: {L} m")
print(f"ç½‘æ ¼æ•°: {nx}")
print(f"æ¸—é€ç³»æ•°: {K} m/day")
print(f"æ²³æµæ°´ä½: {river_stage} m")
print(f"æ²³åºŠä¼ å¯¼åº¦: {river.conductance:.2e} mÂ²/day")
print()

# åœºæ™¯1ï¼šæ— æ²³æµæƒ…å†µï¼ˆåŸºå‡†ï¼‰
print("\nåœºæ™¯1ï¼šæ— æ²³æµè¡¥ç»™")
print("-" * 60)

# è¾¹ç•Œæ¡ä»¶
h_left = 25.0   # å·¦è¾¹ç•Œæ°´å¤´
h_right = 25.0  # å³è¾¹ç•Œæ°´å¤´

# ç¨³æ€æ±‚è§£ï¼ˆæ— è¡¥ç»™ï¼‰
result_no_river = solve_1d_steady_gw(
    K=K, b=b, L=L, nx=nx,
    bc_left=('dirichlet', h_left),
    bc_right=('dirichlet', h_right),
    recharge=0.0
)

h_no_river = result_no_river['head']
print(f"æœ€å¤§æ°´å¤´: {np.max(h_no_river):.2f} m")
print(f"æœ€å°æ°´å¤´: {np.min(h_no_river):.2f} m")

# åœºæ™¯2ï¼šæ²³æµè¡¥ç»™
print("\nåœºæ™¯2ï¼šæ²³æµè¡¥ç»™")
print("-" * 60)

# åˆ›å»ºæºæ±‡é¡¹æ•°ç»„
Q_river = np.zeros(nx)

# è¿­ä»£æ±‚è§£ï¼ˆå¼±è€¦åˆï¼‰
h_with_river = h_no_river.copy()
max_iter = 50
tol = 1e-6

convergence = []
for iter in range(max_iter):
    h_old = h_with_river.copy()
    
    # è®¡ç®—æ²³æµæ¸—æ¼
    flux = river.compute_flux(h_with_river[river_pos_idx], method='standard')
    Q_river[river_pos_idx] = flux / (dx * river_width * b)  # è½¬æ¢ä¸ºæºæ±‡é¡¹ (1/day)
    
    # æ±‚è§£åœ°ä¸‹æ°´
    result = solve_1d_steady_gw(
        K=K, b=b, L=L, nx=nx,
        bc_left=('dirichlet', h_left),
        bc_right=('dirichlet', h_right),
        source=Q_river
    )
    h_with_river = result['head']
    
    # æ£€æŸ¥æ”¶æ•›
    error = np.max(np.abs(h_with_river - h_old))
    convergence.append(error)
    
    if error < tol:
        print(f"æ”¶æ•›! è¿­ä»£æ¬¡æ•°: {iter + 1}")
        break

river_flux = river.compute_flux(h_with_river[river_pos_idx])
print(f"æ²³æµæ¸—æ¼é‡: {river_flux:.2f} mÂ³/day")
print(f"æœ€å¤§æ°´å¤´: {np.max(h_with_river):.2f} m")
print(f"æ²³æµå¤„æ°´å¤´: {h_with_river[river_pos_idx]:.2f} m")

# æ›´å¤šå®ç°...

if __name__ == '__main__':
    print("\nâœ… æ¡ˆä¾‹11æ‰§è¡Œå®Œæˆï¼")
```

### æ¡ˆä¾‹11æ•™ç¨‹

**code/examples/case_11/README.md** (~5,000å­—)

---

## ğŸ¯ æ¡ˆä¾‹12ï¼šRiveråŒ…è¾¹ç•Œæ¡ä»¶

### å­¦ä¹ ç›®æ ‡

- æŒæ¡MODFLOW RiveråŒ…çš„åŸç†
- å®ç°RiveråŒ…çš„Pythonç‰ˆæœ¬
- å¤„ç†æ²³æµæ–­å¼€æƒ…å†µ
- åˆ†ææ²³æµå‚æ•°æ•æ„Ÿæ€§

### ç†è®ºå†…å®¹

#### MODFLOW RiveråŒ…

**åŸºæœ¬å…¬å¼**ï¼š
```
Q_river = CRIV * (HRIV - h_gw)    å½“ h_gw > RBOT
Q_river = CRIV * (HRIV - RBOT)    å½“ h_gw â‰¤ RBOT
```

å‚æ•°ï¼š
- CRIV: æ²³æµä¼ å¯¼åº¦ (mÂ²/day)
- HRIV: æ²³æµæ°´ä½ (m)
- RBOT: æ²³åº•é«˜ç¨‹ (m)
- h_gw: åœ°ä¸‹æ°´æ°´å¤´ (m)

#### æ–­å¼€æœºåˆ¶

å½“åœ°ä¸‹æ°´ä½é™åˆ°æ²³åº•ä»¥ä¸‹æ—¶ï¼š
- æ²³æµä¸èƒ½ç»§ç»­å‘ä¸‹è¡¥ç»™
- é€šé‡è¢«é™åˆ¶åœ¨æ²³æµæ·±åº¦èŒƒå›´å†…
- é˜²æ­¢å‡ºç°éç‰©ç†çš„å¤§é€šé‡

### ä»£ç å®ç°

**gwflow/coupling/river_package.py** (~350è¡Œ)

#### æ¡ˆä¾‹12ä¸»ç¨‹åº

**code/examples/case_12/case_12_river_package.py** (~500è¡Œ)

---

## ğŸ¯ æ¡ˆä¾‹13ï¼šæ¸—æ¼ä¸è¶Šæµæ¨¡æ‹Ÿ

### å­¦ä¹ ç›®æ ‡

- æ¨¡æ‹Ÿå¤šå±‚å«æ°´å±‚ç³»ç»Ÿ
- å¤„ç†å¼±é€æ°´å±‚è¶Šæµ
- åˆ†æå‚å‘æ°´é‡äº¤æ¢
- å®ç°ä¸‰ç»´è€¦åˆæ¨¡å‹

### ç†è®ºå†…å®¹

#### è¶Šæµæœºåˆ¶

**è¶Šæµé€šé‡**ï¼š
```
Q_leakage = C_leakage * (h_upper - h_lower)

C_leakage = K_aquitard * A / b_aquitard
```

#### å¤šå±‚ç³»ç»Ÿ

```
Layer 1 (Confined)
    â†“ Q_leakage_1
Aquitard
    â†“ Q_leakage_2  
Layer 2 (Confined)
```

### ä»£ç å®ç°

**gwflow/coupling/leakage.py** (~300è¡Œ)

#### æ¡ˆä¾‹13ä¸»ç¨‹åº

**code/examples/case_13/case_13_leakage.py** (~550è¡Œ)

---

## ğŸ¯ æ¡ˆä¾‹14ï¼šè€¦åˆæ¨¡å‹ç‡å®š

### å­¦ä¹ ç›®æ ‡

- ç‡å®šè€¦åˆæ¨¡å‹å‚æ•°
- åŒæ—¶ä½¿ç”¨åœ°è¡¨å’Œåœ°ä¸‹æ°´è§‚æµ‹
- åˆ†æå‚æ•°å¯è¯†åˆ«æ€§
- è¯„ä¼°è€¦åˆå‚æ•°æ•æ„Ÿæ€§

### ç†è®ºå†…å®¹

#### è”åˆç›®æ ‡å‡½æ•°

```
J = Î£ w_gw(h_obs - h_sim)Â² + Î£ w_sw(H_obs - H_sim)Â²
```

#### ç‡å®šæŒ‘æˆ˜

- å‚æ•°ç›¸å…³æ€§å¢åŠ 
- è§‚æµ‹æ•°æ®ç±»å‹ä¸åŒ
- æ—¶é—´å°ºåº¦å·®å¼‚
- å±€éƒ¨æœ€ä¼˜é—®é¢˜

### ä»£ç å®ç°

#### æ¡ˆä¾‹14ä¸»ç¨‹åº

**code/examples/case_14/case_14_coupled_calibration.py** (~600è¡Œ)

---

## ğŸ¯ æ¡ˆä¾‹15ï¼šè€¦åˆç³»ç»Ÿä¸ç¡®å®šæ€§

### å­¦ä¹ ç›®æ ‡

- é‡åŒ–è€¦åˆç³»ç»Ÿä¸ç¡®å®šæ€§
- åˆ†æè¯¯å·®ä¼ æ’­
- è¯„ä¼°é¢„æµ‹å¯é æ€§
- æ¯”è¾ƒä¸åŒè€¦åˆæ–¹æ¡ˆ

### ç†è®ºå†…å®¹

#### ä¸ç¡®å®šæ€§æ¥æº

1. **å‚æ•°ä¸ç¡®å®šæ€§**
   - åœ°ä¸‹æ°´å‚æ•°ï¼ˆK, Sï¼‰
   - è€¦åˆå‚æ•°ï¼ˆC, K_bedï¼‰
   - è¾¹ç•Œæ¡ä»¶

2. **æ¨¡å‹ä¸ç¡®å®šæ€§**
   - è€¦åˆæ–¹å¼é€‰æ‹©
   - æ•°å€¼ç¦»æ•£
   - ç®€åŒ–å‡è®¾

3. **æ•°æ®ä¸ç¡®å®šæ€§**
   - è§‚æµ‹è¯¯å·®
   - é‡‡æ ·ä¸è¶³
   - æ—¶ç©ºå˜å¼‚

#### åˆ†ææ–¹æ³•

- Monte Carloåˆ†æ
- GLUEæ–¹æ³•
- è´å¶æ–¯æ¨æ–­
- é›†åˆé¢„æµ‹

### ä»£ç å®ç°

#### æ¡ˆä¾‹15ä¸»ç¨‹åº

**code/examples/case_15/case_15_coupled_uncertainty.py** (~650è¡Œ)

---

## ğŸ“Š gwflow/couplingæ¨¡å—æ€»è§ˆ

### æ¨¡å—ç»“æ„

```
gwflow/coupling/
â”œâ”€â”€ __init__.py           (100è¡Œ)  - æ¨¡å—æ¥å£
â”œâ”€â”€ exchange.py           (250è¡Œ)  - æ°´é‡äº¤æ¢è®¡ç®—
â”œâ”€â”€ solver.py             (400è¡Œ)  - è€¦åˆæ±‚è§£å™¨
â”œâ”€â”€ boundary.py           (300è¡Œ)  - è¾¹ç•Œæ¡ä»¶ç±»
â”œâ”€â”€ river_package.py      (350è¡Œ)  - RiveråŒ…å®ç°
â”œâ”€â”€ leakage.py            (300è¡Œ)  - è¶Šæµæ¨¡æ‹Ÿ
â””â”€â”€ coupled_calibration.py (250è¡Œ) - è€¦åˆç‡å®šå·¥å…·
```

**æ€»è®¡**: ~2,000è¡Œæ ¸å¿ƒä»£ç 

### ä¸»è¦åŠŸèƒ½

#### 1. æ°´é‡äº¤æ¢

- `compute_exchange_flux()`: è®¡ç®—äº¤æ¢é€šé‡
- `leakance_coefficient()`: æ¸—æ¼ç³»æ•°
- `river_head_gradient()`: æ°´å¤´æ¢¯åº¦

#### 2. æ±‚è§£å™¨

- `solve_coupled_weak()`: å¼±è€¦åˆæ±‚è§£
- `solve_coupled_strong()`: å¼ºè€¦åˆæ±‚è§£
- `solve_sequential()`: é¡ºåºè€¦åˆæ±‚è§£

#### 3. è¾¹ç•Œæ¡ä»¶

- `RiverBoundary`: æ²³æµè¾¹ç•Œ
- `LakeBoundary`: æ¹–æ³Šè¾¹ç•Œ
- `ETBoundary`: è’¸æ•£å‘è¾¹ç•Œ

#### 4. RiveråŒ…

- `RiverPackage`: MODFLOW RiveråŒ…
- `process_river_cells()`: å¤„ç†æ²³æµå•å…ƒ
- `compute_river_flux()`: è®¡ç®—æ²³æµé€šé‡

#### 5. è¶Šæµ

- `compute_leakage()`: è®¡ç®—è¶Šæµ
- `setup_multilayer()`: å¤šå±‚ç³»ç»Ÿè®¾ç½®
- `vertical_exchange()`: å‚å‘äº¤æ¢

---

## ğŸ“ˆ é¢„æœŸæˆæœ

### ä»£ç ç»Ÿè®¡

| æ¨¡å— | è¡Œæ•° | åŠŸèƒ½ |
|------|------|------|
| gwflow/coupling | ~2,000 | è€¦åˆæ ¸å¿ƒæ¨¡å— |
| case_11 | ~450 | è€¦åˆåŸºç¡€ |
| case_12 | ~500 | RiveråŒ… |
| case_13 | ~550 | è¶Šæµæ¨¡æ‹Ÿ |
| case_14 | ~600 | è€¦åˆç‡å®š |
| case_15 | ~650 | è€¦åˆä¸ç¡®å®šæ€§ |
| **æ€»è®¡** | **~4,750** | - |

### æ–‡æ¡£ç»Ÿè®¡

| æ–‡æ¡£ç±»å‹ | æ•°é‡ | å­—æ•° |
|---------|------|------|
| æ¡ˆä¾‹README | 5ä¸ª | ~30,000 |
| è®¾è®¡æ–¹æ¡ˆ | 1ä¸ª | ~8,000 |
| å®ŒæˆæŠ¥å‘Š | 1ä¸ª | ~12,000 |
| **æ€»è®¡** | **7ä¸ª** | **~50,000** |

---

## ğŸ“ æ•™å­¦ä»·å€¼

### ç†è®ºæ·±åº¦

- âœ… å®Œæ•´çš„è€¦åˆç†è®ºä½“ç³»
- âœ… MODFLOW RiveråŒ…å®ç°
- âœ… å¤šå±‚ç³»ç»Ÿè¶Šæµåˆ†æ
- âœ… è€¦åˆç³»ç»Ÿç‡å®šæ–¹æ³•
- âœ… ä¸ç¡®å®šæ€§é‡åŒ–

### å®è·µèƒ½åŠ›

- âœ… å®ç°è€¦åˆæ¨¡å‹
- âœ… å¤„ç†å¤æ‚è¾¹ç•Œæ¡ä»¶
- âœ… ç‡å®šè€¦åˆå‚æ•°
- âœ… è¯„ä¼°é¢„æµ‹ä¸ç¡®å®šæ€§

### å·¥ç¨‹åº”ç”¨

- âœ… æ²³æµè¡¥ç»™è¯„ä¼°
- âœ… å¤šå±‚ç³»ç»Ÿåˆ†æ
- âœ… æ°´èµ„æºç®¡ç†
- âœ… ç”Ÿæ€æ°´æ–‡ç ”ç©¶

---

## ğŸš€ å¼€å‘è®¡åˆ’

### æ—¶é—´å®‰æ’

- **Week 1-2**: æ¡ˆä¾‹11ï¼ˆè€¦åˆåŸºç¡€ï¼‰ + gwflow/couplingåŸºç¡€æ¨¡å—
- **Week 3**: æ¡ˆä¾‹12ï¼ˆRiveråŒ…ï¼‰
- **Week 4**: æ¡ˆä¾‹13ï¼ˆè¶Šæµæ¨¡æ‹Ÿï¼‰
- **Week 5**: æ¡ˆä¾‹14ï¼ˆè€¦åˆç‡å®šï¼‰
- **Week 6**: æ¡ˆä¾‹15ï¼ˆè€¦åˆä¸ç¡®å®šæ€§ï¼‰+ æ–‡æ¡£å®Œå–„

**æ€»è®¡**: 6å‘¨

### é‡Œç¨‹ç¢‘

- âœ… M3.1: è€¦åˆåŸºç¡€æ¨¡å—å®Œæˆ
- âœ… M3.2: RiveråŒ…å®ç°å®Œæˆ
- âœ… M3.3: å¤šå±‚ç³»ç»Ÿå®Œæˆ
- âœ… M3.4: è€¦åˆç‡å®šå®Œæˆ
- âœ… M3.5: ç¬¬ä¸‰ç¯‡å…¨éƒ¨å®Œæˆ

---

## ğŸ“ å‚è€ƒæ–‡çŒ®

1. McDonald, M.G. & Harbaugh, A.W. (1988). *MODFLOW User Manual*
2. Harbaugh, A.W. (2005). *MODFLOW-2005 Documentation*
3. Sophocleous, M. (2002). "Interactions between groundwater and surface water"
4. Brunner, P. et al. (2010). "HydroGeoSphere: A fully integrated model"

---

**Status**: è®¾è®¡å®Œæˆï¼Œå‡†å¤‡å¼€å‘ï¼  
**Next**: å¼€å§‹å¼€å‘æ¡ˆä¾‹11 ğŸš€

---

*è®¾è®¡æ—¥æœŸï¼š2025-11-02*  
*é¢„è®¡å®Œæˆï¼š2025-12-14ï¼ˆ6å‘¨åï¼‰*
