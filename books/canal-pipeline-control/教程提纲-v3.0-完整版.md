# 渠道、管道与管渠系统控制教程 - 完整提纲 v3.0
## 融合控制论+水力学+建模辨识+数字孪生

**版本**: v3.0-complete
**日期**: 2025-10-30
**状态**: 📝 提纲设计阶段（增强版）

---

## 📚 课程定位

本课程是《水系统控制论》和《明渠水力学》的**综合进阶课程**，系统涵盖：
1. ✅ 分布参数系统控制理论
2. ✅ **模型降阶方法**（PDE → ODE）
3. ✅ **系统辨识技术**（数据驱动建模）
4. ✅ **数字孪生应用**（虚实融合）
5. ✅ 智能控制与优化调度

---

## 🎯 核心技术体系

### 技术金字塔

```
                    ┌─────────────────────┐
                    │   数字孪生平台      │
                    │  (虚实融合、预测)   │
                    └──────────┬──────────┘
                               │
          ┌────────────────────┼────────────────────┐
          │                    │                    │
    ┌─────▼──────┐      ┌─────▼──────┐      ┌─────▼──────┐
    │ 智能控制   │      │ 先进控制   │      │ 优化调度   │
    │(RL/NN/DL) │      │(MPC/鲁棒)  │      │(MILP/GA)   │
    └─────┬──────┘      └─────┬──────┘      └─────┬──────┘
          │                    │                    │
          └────────────────────┼────────────────────┘
                               │
                    ┌──────────▼──────────┐
                    │    模型降阶          │
                    │  (PDE → ODE)        │
                    │  POD/DMD/Galerkin   │
                    └──────────┬──────────┘
                               │
          ┌────────────────────┼────────────────────┐
          │                    │                    │
    ┌─────▼──────┐      ┌─────▼──────┐      ┌─────▼──────┐
    │ 系统辨识   │      │ 状态估计   │      │ 传感融合   │
    │(N4SID/PEM)│      │(KF/PF/EKF) │      │(多源数据)  │
    └─────┬──────┘      └─────┬──────┘      └─────┬──────┘
          │                    │                    │
          └────────────────────┼────────────────────┘
                               │
                    ┌──────────▼──────────┐
                    │   物理模型基础       │
                    │ Saint-Venant方程    │
                    │ 达西定律/水锤方程   │
                    │ (明渠水力学提供)    │
                    └─────────────────────┘
```

---

## 📖 课程结构（20个案例）- 重新设计

### 第一章：分布式控制基础（案例1-3）

#### 案例1：单渠段PID水位控制
- 基础PID控制
- 时滞补偿
- 闸门非线性处理

#### 案例2：多点反馈分布式PID控制
- 多传感器融合
- 加权反馈策略
- 测点优化布置

#### 案例3：前馈-反馈复合控制
- 扰动前馈补偿
- 反馈鲁棒控制
- 前馈增益设计

---

### 第二章：模型降阶方法 ⭐⭐⭐ **【新增核心章节】**

#### 案例4：POD降阶 - 本征正交分解
**理论基础**:
- Proper Orthogonal Decomposition
- Karhunen-Loève展开
- 能量捕获率

**降阶过程**:
```python
# 1. 收集快照数据
snapshots = []
for t in time_steps:
    h, Q = solve_saint_venant(...)
    snapshots.append(h)  # N_x × 1

# 2. 构造快照矩阵
X = np.column_stack(snapshots)  # N_x × N_t

# 3. SVD分解
U, S, Vt = np.linalg.svd(X, full_matrices=False)

# 4. 选择前r个模态
r = 10  # 降阶维数
Phi = U[:, :r]  # 基函数矩阵 N_x × r

# 5. Galerkin投影
# h(x,t) ≈ Φ * a(t)
# 将PDE投影到低维子空间
def reduced_dynamics(a, t):
    # da/dt = Ar*a + Br*u
    return Ar @ a + Br @ u

# 6. 降阶模型控制器设计
from scipy.integrate import odeint
from water_system_control.controllers import PIDController

pid = PIDController(Kp=2, Ki=0.5, Kd=1)
for t in time:
    a_current = ...  # r维状态
    h_reconstructed = Phi @ a_current  # 重构 N_x维
    u = pid.compute(h_reconstructed[-1])
    ...
```

**评估指标**:
```python
# 能量捕获率
energy_ratio = sum(S[:r]**2) / sum(S**2)

# 重构误差
error = norm(h_full - h_reduced) / norm(h_full)

# 计算加速比
speedup = time_full / time_reduced
```

**实验**:
1. 不同模态数 r=5,10,20,50
2. POD vs 全阶模型精度对比
3. 控制性能对比
4. 计算时间对比

**难度**: ⭐⭐⭐⭐
**代码量**: ~1000行

---

#### 案例5：动态模态分解（DMD）
**理论基础**:
- Dynamic Mode Decomposition
- Koopman算子理论
- 线性算子逼近

**DMD算法**:
```python
# 1. 数据矩阵
X = [x0, x1, ..., x_{m-1}]  # N × m
Y = [x1, x2, ..., x_m]      # N × m

# 2. DMD分解
U, S, Vt = np.linalg.svd(X, full_matrices=False)

# 3. 降阶线性算子
A_tilde = U.T @ Y @ Vt.T @ np.diag(1/S)

# 4. 特征分解
eigenvalues, eigenvectors = np.linalg.eig(A_tilde)

# 5. DMD模态
Phi = Y @ Vt.T @ np.diag(1/S) @ eigenvectors

# 6. 预测
x(t) ≈ Σ φ_k * exp(λ_k * t) * b_k
```

**应用**:
```python
# 短期预测（用于MPC）
def dmd_predict(x0, dt, n_steps):
    b = np.linalg.lstsq(Phi, x0)[0]
    predictions = []
    for k in range(n_steps):
        t = k * dt
        x_pred = Phi @ (np.exp(eigenvalues * t) * b)
        predictions.append(x_pred)
    return predictions

# 在MPC中使用DMD模型
class DMD_MPC:
    def __init__(self, dmd_model):
        self.Phi = dmd_model.Phi
        self.eigenvalues = dmd_model.eigenvalues

    def predict_horizon(self, x0, u_sequence, N):
        # 使用DMD快速预测N步
        x_pred = []
        for k in range(N):
            x_k = dmd_predict(x0, dt*k, 1)
            x_pred.append(x_k)
        return x_pred
```

**扩展：DMD变种**:
1. **Exact DMD**: 精确算法
2. **Extended DMD**: 非线性系统
3. **DMD with Control**: 含控制输入
4. **Optimized DMD**: 稀疏优化

**实验**:
1. DMD vs POD对比
2. 预测精度分析
3. 不同时间窗口影响
4. 在线更新DMD模型

**难度**: ⭐⭐⭐⭐⭐
**代码量**: ~1100行

---

#### 案例6：Galerkin投影与有限元降阶
**理论基础**:
- Galerkin方法
- 有限元基函数
- 弱形式

**Galerkin投影**:
```python
# 原PDE（Saint-Venant）
∂h/∂t + ∂Q/∂x = 0
∂Q/∂t + ∂(Q²/A)/∂x + gA*∂h/∂x = -gA*Sf

# 选择基函数 φ_i(x)
# h(x,t) = Σ a_i(t) * φ_i(x)

# Galerkin投影：
∫ [∂h/∂t + ∂Q/∂x] * φ_j(x) dx = 0

# 得到ODE系统
da/dt = f(a, u)  # r维ODE
```

**实现**:
```python
class GalerkinReducedModel:
    def __init__(self, basis_functions, n_modes):
        self.phi = basis_functions  # 基函数
        self.r = n_modes

    def project_pde(self, saint_venant_operator):
        """投影PDE到子空间"""
        # 质量矩阵
        M = self.compute_mass_matrix()

        # 刚度矩阵
        K = self.compute_stiffness_matrix()

        # 降阶系统: M*da/dt = K*a + B*u
        return M, K

    def compute_mass_matrix(self):
        M = np.zeros((self.r, self.r))
        for i in range(self.r):
            for j in range(self.r):
                M[i,j] = self.integrate(self.phi[i] * self.phi[j])
        return M

    def solve_reduced_system(self, u, T):
        """求解降阶ODE"""
        from scipy.integrate import odeint

        def ode_rhs(a, t):
            return np.linalg.solve(self.M, self.K @ a + self.B * u(t))

        a = odeint(ode_rhs, a0, np.linspace(0, T, 1000))
        return a
```

**基函数选择**:
1. **正弦/余弦**: 周期边界
2. **多项式**: Legendre、Chebyshev
3. **样条**: B-spline
4. **POD模态**: 数据驱动

**实验**:
1. 不同基函数性能对比
2. 边界条件处理
3. 非线性项处理
4. 自适应基函数选择

**难度**: ⭐⭐⭐⭐⭐
**代码量**: ~1200行

---

#### 案例7：神经网络降阶模型
**理论基础**:
- Autoencoder架构
- Physics-Informed Neural Networks (PINN)
- 神经算子（Neural Operator）

**Autoencoder降阶**:
```python
import torch
import torch.nn as nn

class ChannelAutoencoder(nn.Module):
    def __init__(self, spatial_dim=100, latent_dim=10):
        super().__init__()

        # 编码器：N_x维 → r维
        self.encoder = nn.Sequential(
            nn.Linear(spatial_dim, 64),
            nn.Tanh(),
            nn.Linear(64, 32),
            nn.Tanh(),
            nn.Linear(32, latent_dim)
        )

        # 解码器：r维 → N_x维
        self.decoder = nn.Sequential(
            nn.Linear(latent_dim, 32),
            nn.Tanh(),
            nn.Linear(32, 64),
            nn.Tanh(),
            nn.Linear(64, spatial_dim)
        )

    def forward(self, x):
        z = self.encoder(x)  # 编码到低维
        x_recon = self.decoder(z)  # 解码回高维
        return x_recon, z

# 训练
model = ChannelAutoencoder(spatial_dim=100, latent_dim=10)
optimizer = torch.optim.Adam(model.parameters())

for epoch in range(1000):
    for h_snapshot in dataloader:
        h_recon, z = model(h_snapshot)
        loss = nn.MSELoss()(h_recon, h_snapshot)
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
```

**动力学神经网络**:
```python
class LatentDynamicsNN(nn.Module):
    """学习低维状态的演化"""
    def __init__(self, latent_dim=10, control_dim=1):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(latent_dim + control_dim, 64),
            nn.Tanh(),
            nn.Linear(64, 64),
            nn.Tanh(),
            nn.Linear(64, latent_dim)
        )

    def forward(self, z, u):
        """预测下一时刻的低维状态"""
        inp = torch.cat([z, u], dim=-1)
        z_next = self.net(inp)
        return z_next

# 完整的降阶模型
class NeuralROM:
    def __init__(self, autoencoder, dynamics_net):
        self.ae = autoencoder
        self.dyn = dynamics_net

    def predict(self, h0, u_sequence):
        # 编码
        z0 = self.ae.encoder(h0)

        # 在低维空间演化
        z_traj = [z0]
        for u_t in u_sequence:
            z_next = self.dyn(z_traj[-1], u_t)
            z_traj.append(z_next)

        # 解码回高维
        h_traj = [self.ae.decoder(z) for z in z_traj]
        return h_traj
```

**Physics-Informed损失**:
```python
def physics_loss(h_pred, h_true):
    # 数据损失
    data_loss = mse_loss(h_pred, h_true)

    # 物理损失（满足PDE）
    dh_dt = compute_time_derivative(h_pred)
    dQ_dx = compute_space_derivative(Q_pred)
    continuity_residual = dh_dt + dQ_dx  # 应该≈0

    physics_loss = mse_loss(continuity_residual, torch.zeros_like(continuity_residual))

    return data_loss + lambda_physics * physics_loss
```

**实验**:
1. NN-ROM vs POD性能对比
2. 不同网络架构测试
3. 物理约束的作用
4. 泛化能力测试（不同工况）

**难度**: ⭐⭐⭐⭐⭐
**代码量**: ~1300行

---

### 第三章：系统辨识方法 ⭐⭐⭐ **【新增核心章节】**

#### 案例8：子空间辨识（N4SID）
**理论基础**:
- 状态空间模型辨识
- Numerical Subspace State Space Identification
- Hankel矩阵

**N4SID算法**:
```python
from scipy.linalg import svd, lstsq

def n4sid(y, u, order):
    """
    y: 输出数据 (N_samples × N_outputs)
    u: 输入数据 (N_samples × N_inputs)
    order: 模型阶数
    """
    # 1. 构造Hankel矩阵
    i = 20  # 行块数
    Y = hankel_matrix(y, i)
    U = hankel_matrix(u, i)

    # 2. LQ分解
    L, Q = np.linalg.qr(np.vstack([U, Y]).T)

    # 3. 提取可观测性矩阵
    O = L[n_u*i:, :order]

    # 4. SVD确定阶数
    U_svd, S, Vt = svd(O)
    order_estimated = np.sum(S > threshold)

    # 5. 辨识A, C矩阵
    O1 = O[:-n_y, :]
    O2 = O[n_y:, :]
    A = lstsq(O1, O2)[0]
    C = O[:n_y, :]

    # 6. 辨识B, D矩阵
    # ...（通过输入输出关系）

    return A, B, C, D

# 应用到渠道系统
y_data = measured_water_levels  # 沿程水位测量
u_data = gate_openings  # 闸门开度

A, B, C, D = n4sid(y_data, u_data, order=10)

# 得到状态空间模型
# dx/dt = A*x + B*u
# y = C*x + D*u

# 用于控制器设计
from scipy.signal import lti
system = lti(A, B, C, D)
```

**模型验证**:
```python
def validate_model(system, y_test, u_test):
    # 模拟输出
    t, y_sim = system.output(u_test, t)

    # 拟合优度（Variance Accounted For）
    VAF = (1 - np.var(y_test - y_sim) / np.var(y_test)) * 100

    # 残差分析
    residuals = y_test - y_sim
    autocorr = np.correlate(residuals, residuals, mode='full')

    return VAF, autocorr
```

**实验**:
1. 不同模型阶数选择
2. 与物理模型对比
3. 闭环辨识 vs 开环辨识
4. 不同激励信号影响

**难度**: ⭐⭐⭐⭐⭐
**代码量**: ~1100行

---

#### 案例9：频域辨识与传递函数拟合
**理论基础**:
- 频率响应测试
- 传递函数估计
- Bode图拟合

**频域辨识**:
```python
from scipy import signal
from scipy.optimize import least_squares

def frequency_domain_identification(y, u, fs):
    """
    基于频域数据辨识传递函数
    """
    # 1. 计算频率响应
    f, Pyu = signal.csd(y, u, fs=fs)
    f, Puu = signal.welch(u, fs=fs)
    H = Pyu / Puu  # 频率响应函数

    # 2. 拟合传递函数
    # H(s) = (b_m*s^m + ... + b_0) / (s^n + a_{n-1}*s^{n-1} + ... + a_0)

    def tf_model(params, s):
        """传递函数模型"""
        n_num = len(params) // 2
        num = np.poly1d(params[:n_num])
        den = np.poly1d([1] + list(params[n_num:]))
        return num(s) / den(s)

    def residual(params):
        H_model = tf_model(params, 1j*2*np.pi*f)
        return np.abs(H - H_model).flatten()

    # 优化
    result = least_squares(residual, initial_params)
    num_coeffs = result.x[:n_num]
    den_coeffs = result.x[n_num:]

    return num_coeffs, den_coeffs

# 应用
num, den = frequency_domain_identification(water_levels, gate_openings, fs=1/60)
tf = signal.TransferFunction(num, den)

# 用于控制器设计
# 如：IMC控制器设计
```

**渠道传递函数模型**:
```python
# 典型的渠道传递函数（带时滞）
# G(s) = K * exp(-τ*s) / (T*s + 1)^n

class CanalTransferFunction:
    def __init__(self, K, tau, T, n):
        self.K = K      # 增益
        self.tau = tau  # 时滞
        self.T = T      # 时间常数
        self.n = n      # 阶数

    def frequency_response(self, omega):
        s = 1j * omega
        return self.K * np.exp(-self.tau*s) / (self.T*s + 1)**self.n

    def bode_plot(self):
        w = np.logspace(-3, 1, 100)
        H = self.frequency_response(w)
        mag = 20 * np.log10(np.abs(H))
        phase = np.angle(H, deg=True)

        plt.figure(figsize=(10,8))
        plt.subplot(211)
        plt.semilogx(w, mag)
        plt.ylabel('Magnitude (dB)')
        plt.grid()

        plt.subplot(212)
        plt.semilogx(w, phase)
        plt.ylabel('Phase (deg)')
        plt.xlabel('Frequency (rad/s)')
        plt.grid()
```

**实验**:
1. PRBS激励信号测试
2. Chirp信号扫频测试
3. 不同模型结构对比
4. Bode图匹配优化

**难度**: ⭐⭐⭐⭐
**代码量**: ~900行

---

#### 案例10：非线性系统辨识 - Hammerstein-Wiener模型
**理论基础**:
- 非线性块结构模型
- Hammerstein模型（NL → L）
- Wiener模型（L → NL）
- Hammerstein-Wiener模型（NL → L → NL）

**闸门-水位非线性辨识**:
```python
class HammersteinWienerModel:
    """
    u → [f(·)] → v → [G(z)] → w → [g(·)] → y
    输入   静态非线性  线性动态  静态非线性  输出
    """
    def __init__(self):
        # 输入非线性（闸门-流量关系）
        self.f_input = self.input_nonlinearity

        # 线性动态部分
        self.G = None  # 传递函数

        # 输出非线性
        self.g_output = self.output_nonlinearity

    def input_nonlinearity(self, u):
        """
        闸门开度 u → 流量 Q
        Q = Cd * u * A * sqrt(2*g*h_upstream)
        """
        # 多项式近似
        return self.poly_input(u)

    def output_nonlinearity(self, w):
        """流量 → 水位"""
        return self.poly_output(w)

    def fit(self, u_data, y_data):
        """
        迭代辨识算法
        """
        # 1. 初始化：假设线性
        self.G = identify_linear_part(u_data, y_data)

        # 2. 迭代优化
        for iter in range(max_iter):
            # 固定 G，辨识 f 和 g
            self.fit_nonlinearities(u_data, y_data)

            # 固定 f 和 g，辨识 G
            v = self.f_input(u_data)
            w = self.G.output(v)
            self.G = identify_linear_part(v, inverse(self.g_output, y_data))

            # 检查收敛
            if converged:
                break

        return self

def identify_hammerstein_wiener(u, y):
    """完整辨识流程"""
    model = HammersteinWienerModel()
    model.fit(u, y)
    return model

# 应用
model = identify_hammerstein_wiener(gate_openings, water_levels)

# 预测
y_pred = model.predict(u_test)
```

**高级：Volterra级数**:
```python
class VolterraModel:
    """
    y(t) = h0 + Σ h1(τ1)*u(t-τ1) +
           ΣΣ h2(τ1,τ2)*u(t-τ1)*u(t-τ2) +
           ...
    """
    def __init__(self, order=2, memory=10):
        self.order = order
        self.memory = memory
        self.kernels = []

    def fit(self, u, y):
        # Lee-Schetzen方法
        # 使用高斯白噪声激励
        ...

# 对于严重非线性的渠道系统
volterra_model = VolterraModel(order=2, memory=20)
volterra_model.fit(u, y)
```

**实验**:
1. Hammerstein vs Wiener vs HW对比
2. 不同非线性函数形式
3. 线性部分阶数影响
4. 与神经网络模型对比

**难度**: ⭐⭐⭐⭐⭐
**代码量**: ~1200行

---

#### 案例11：数据驱动辨识 - SINDy与稀疏辨识
**理论基础**:
- Sparse Identification of Nonlinear Dynamics (SINDy)
- 稀疏回归
- 符号回归

**SINDy算法**:
```python
from sklearn.linear_model import Lasso

def sindy(X, dX_dt, poly_order=3, threshold=0.01):
    """
    X: 状态数据 (n_samples × n_states)
    dX_dt: 状态导数 (n_samples × n_states)
    """
    # 1. 构造候选函数库
    # Θ(X) = [1, x1, x2, x1², x1*x2, x2², x1³, ...]

    Theta = build_library(X, poly_order)
    # Theta shape: (n_samples × n_library_functions)

    # 2. 稀疏回归
    # dX/dt = Θ(X) * Ξ
    # 求解 Ξ（系数矩阵）

    Xi = np.zeros((Theta.shape[1], X.shape[1]))

    for i in range(X.shape[1]):
        # Lasso回归（L1正则化 → 稀疏）
        model = Lasso(alpha=threshold)
        model.fit(Theta, dX_dt[:, i])
        Xi[:, i] = model.coef_

    return Xi, Theta

def build_library(X, poly_order):
    """构造多项式库"""
    n_samples, n_vars = X.shape
    library = [np.ones(n_samples)]  # 常数项

    # 一次项
    for i in range(n_vars):
        library.append(X[:, i])

    # 二次项
    if poly_order >= 2:
        for i in range(n_vars):
            for j in range(i, n_vars):
                library.append(X[:, i] * X[:, j])

    # 三次项
    if poly_order >= 3:
        for i in range(n_vars):
            for j in range(i, n_vars):
                for k in range(j, n_vars):
                    library.append(X[:, i] * X[:, j] * X[:, k])

    # 三角函数项（可选）
    for i in range(n_vars):
        library.append(np.sin(X[:, i]))
        library.append(np.cos(X[:, i]))

    return np.column_stack(library)

# 应用到渠道系统
# 状态：x = [h1, h2, ..., h_N, Q1, Q2, ..., Q_M]

# 从数据计算导数
X = state_data
dX_dt = np.gradient(X, dt, axis=0)

# 辨识
Xi, Theta = sindy(X, dX_dt, poly_order=3)

# 得到的模型：
# dh1/dt = ξ_{11} + ξ_{21}*h1 + ξ_{31}*Q1 + ξ_{41}*h1² + ...
# dh2/dt = ξ_{12} + ξ_{22}*h2 + ξ_{32}*Q2 + ...

# 打印发现的方程
def print_equations(Xi, Theta, feature_names):
    for i, eq in enumerate(Xi.T):
        terms = []
        for j, coef in enumerate(eq):
            if abs(coef) > 1e-6:
                terms.append(f"{coef:.4f}*{feature_names[j]}")
        print(f"dx{i}/dt = {' + '.join(terms)}")

print_equations(Xi, Theta, feature_names)
```

**输出示例**:
```
# 发现的方程（可能结果）
dh1/dt = -0.0123*Q1 + 0.0045*Q0
dQ1/dt = -9.81*h1 + 9.81*h0 - 0.0234*Q1*|Q1|
...
# 可以看出是Saint-Venant方程的离散形式！
```

**PySINDy库应用**:
```python
import pysindy as ps

model = ps.SINDy(
    optimizer=ps.STLSQ(threshold=0.01),
    feature_library=ps.PolynomialLibrary(degree=3),
    differentiation_method=ps.FiniteDifference()
)

model.fit(X, t=t, u=u)  # u是控制输入
model.print()

# 用于预测
X_pred = model.simulate(X[0], t, u=u)
```

**实验**:
1. 不同库函数组合
2. 稀疏度阈值影响
3. 噪声鲁棒性测试
4. 与物理模型符号对比

**难度**: ⭐⭐⭐⭐⭐
**代码量**: ~1000行

---

### 第四章：数字孪生技术 ⭐⭐⭐ **【新增核心章节】**

#### 案例12：数字孪生架构 - 状态估计与虚拟传感
**理论基础**:
- 数字孪生概念
- 状态估计理论
- 数据同化

**数字孪生架构**:
```python
class DigitalTwin:
    """
    渠道系统数字孪生
    """
    def __init__(self):
        # 物理模型
        self.physical_model = SaintVenantSolver()

        # 数据驱动模型（降阶/NN）
        self.data_model = None

        # 状态估计器
        self.estimator = ExtendedKalmanFilter()

        # 传感器模型
        self.sensors = SensorNetwork()

        # 虚拟传感器
        self.virtual_sensors = {}

    def synchronize(self, measurements):
        """
        同步物理系统状态
        """
        # 1. 预测步（物理模型前向）
        x_pred = self.physical_model.step(u=self.current_control)

        # 2. 更新步（融合测量）
        x_est = self.estimator.update(x_pred, measurements)

        # 3. 更新数字孪生状态
        self.state = x_est

        return x_est

    def predict_future(self, horizon, control_scenario):
        """
        未来状态预测
        """
        x_future = []
        x = self.state

        for k in range(horizon):
            u = control_scenario[k]
            x = self.physical_model.step(x, u)
            x_future.append(x)

        return x_future

    def create_virtual_sensor(self, location):
        """
        创建虚拟传感器（软测量）
        """
        def virtual_sensor_reading():
            # 从完整状态估计中提取
            return self.interpolate_state(location)

        self.virtual_sensors[location] = virtual_sensor_reading
        return virtual_sensor_reading

    def anomaly_detection(self):
        """
        异常检测
        """
        # 模型预测 vs 实际测量
        residual = self.measurements - self.model_prediction

        # 统计检验
        if np.linalg.norm(residual) > threshold:
            return True, residual
        return False, residual

    def what_if_analysis(self, scenario):
        """
        What-if分析
        """
        # 克隆当前状态
        twin_copy = copy.deepcopy(self)

        # 模拟不同场景
        results = twin_copy.simulate(scenario)

        return results
```

**扩展卡尔曼滤波实现**:
```python
class ExtendedKalmanFilter:
    """
    针对非线性Saint-Venant方程的EKF
    """
    def __init__(self, n_states, n_measurements):
        self.n = n_states
        self.m = n_measurements

        # 状态协方差
        self.P = np.eye(n_states)

        # 过程噪声
        self.Q = np.eye(n_states) * 0.01

        # 测量噪声
        self.R = np.eye(n_measurements) * 0.1

    def predict(self, x, u, dt):
        """
        预测步
        """
        # 非线性状态转移
        x_pred = self.f(x, u, dt)  # Saint-Venant求解

        # 雅可比矩阵
        F = self.jacobian_f(x, u, dt)

        # 协方差预测
        P_pred = F @ self.P @ F.T + self.Q

        return x_pred, P_pred

    def update(self, x_pred, P_pred, z):
        """
        更新步
        """
        # 预测测量
        z_pred = self.h(x_pred)

        # 测量雅可比
        H = self.jacobian_h(x_pred)

        # 卡尔曼增益
        S = H @ P_pred @ H.T + self.R
        K = P_pred @ H.T @ np.linalg.inv(S)

        # 状态更新
        innovation = z - z_pred
        x_est = x_pred + K @ innovation

        # 协方差更新
        P_est = (np.eye(self.n) - K @ H) @ P_pred

        self.P = P_est
        return x_est

    def f(self, x, u, dt):
        """状态转移函数（Saint-Venant）"""
        return solve_saint_venant_one_step(x, u, dt)

    def h(self, x):
        """测量函数（提取传感器位置的状态）"""
        return x[self.sensor_indices]

    def jacobian_f(self, x, u, dt):
        """数值微分计算F"""
        F = np.zeros((self.n, self.n))
        eps = 1e-6

        for i in range(self.n):
            x_plus = x.copy()
            x_plus[i] += eps
            f_plus = self.f(x_plus, u, dt)

            x_minus = x.copy()
            x_minus[i] -= eps
            f_minus = self.f(x_minus, u, dt)

            F[:, i] = (f_plus - f_minus) / (2*eps)

        return F
```

**实时数字孪生系统**:
```python
class RealtimeDigitalTwin:
    def __init__(self):
        self.twin = DigitalTwin()
        self.history = []

    def run_realtime(self):
        """实时运行循环"""
        while True:
            # 1. 获取传感器数据
            measurements = self.acquire_sensor_data()

            # 2. 同步状态
            state_est = self.twin.synchronize(measurements)

            # 3. 异常检测
            is_anomaly, residual = self.twin.anomaly_detection()
            if is_anomaly:
                self.trigger_alarm(residual)

            # 4. 短期预测（用于MPC）
            x_future = self.twin.predict_future(horizon=10, control_scenario=self.mpc_plan)

            # 5. 更新可视化
            self.update_dashboard(state_est, x_future)

            # 6. 记录历史
            self.history.append({
                'time': time.time(),
                'state': state_est,
                'measurements': measurements,
                'prediction': x_future
            })

            time.sleep(60)  # 1分钟周期
```

**实验**:
1. 不同状态估计器对比（EKF vs UKF vs PF）
2. 传感器配置优化
3. 虚拟传感器精度验证
4. 异常检测算法对比

**难度**: ⭐⭐⭐⭐⭐
**代码量**: ~1500行

---

#### 案例13：数字孪生 - 预测性维护
**应用场景**:
- 闸门机械磨损
- 泵站设备劣化
- 渠道淤积预测

**退化模型**:
```python
class EquipmentDegradationModel:
    """
    设备退化模型
    """
    def __init__(self, equipment_type):
        self.type = equipment_type
        self.health_index = 100.0  # 健康指数 0-100

    def update_health(self, operating_conditions, dt):
        """
        根据运行条件更新健康指数
        """
        if self.type == 'gate':
            # 闸门磨损模型
            wear_rate = self.compute_gate_wear(
                opening_cycles=operating_conditions['cycles'],
                load=operating_conditions['head_difference']
            )
            self.health_index -= wear_rate * dt

        elif self.type == 'pump':
            # 泵退化模型
            degradation = self.compute_pump_degradation(
                flow=operating_conditions['flow'],
                cavitation_events=operating_conditions['cavitation']
            )
            self.health_index -= degradation * dt

        # 限制在[0, 100]
        self.health_index = np.clip(self.health_index, 0, 100)

    def predict_rul(self):
        """
        预测剩余使用寿命 (Remaining Useful Life)
        """
        # 简化线性模型
        degradation_rate = self.estimate_degradation_rate()
        rul = self.health_index / degradation_rate
        return rul

    def maintenance_threshold(self):
        """维护阈值"""
        return 30.0  # 健康指数<30需要维护

class PredictiveMaintenanceSystem:
    def __init__(self, digital_twin):
        self.twin = digital_twin
        self.equipment_models = {}

    def add_equipment(self, name, equipment_type):
        self.equipment_models[name] = EquipmentDegradationModel(equipment_type)

    def update(self, operating_data, dt):
        """更新所有设备状态"""
        for name, model in self.equipment_models.items():
            conditions = operating_data[name]
            model.update_health(conditions, dt)

    def generate_maintenance_plan(self, horizon_days):
        """
        生成维护计划
        """
        plan = []

        for name, model in self.equipment_models.items():
            rul = model.predict_rul()

            if rul < horizon_days:
                plan.append({
                    'equipment': name,
                    'current_health': model.health_index,
                    'rul_days': rul,
                    'urgency': 'high' if rul < 7 else 'medium',
                    'recommended_action': self.get_maintenance_action(model)
                })

        # 按紧急程度排序
        plan.sort(key=lambda x: x['rul_days'])
        return plan
```

**数据驱动的RUL预测**:
```python
# 使用LSTM预测RUL
class RUL_Predictor:
    def __init__(self):
        self.model = nn.LSTM(
            input_size=10,   # 特征维度
            hidden_size=64,
            num_layers=2,
            output_size=1    # RUL预测
        )

    def train(self, historical_data):
        """
        historical_data: {
            'features': [vibration, temperature, pressure, ...],
            'rul': [remaining days until failure]
        }
        """
        X = historical_data['features']
        y = historical_data['rul']

        # 训练...

    def predict(self, current_features):
        """预测当前RUL"""
        return self.model(current_features)
```

**实验**:
1. 不同退化模型对比
2. RUL预测精度评估
3. 维护策略优化（预防性vs预测性）
4. 成本-效益分析

**难度**: ⭐⭐⭐⭐⭐
**代码量**: ~1200行

---

### 第五章：管道系统控制（案例14-15）

#### 案例14：管网多泵站协调控制
（内容从之前的案例11移到这里）

#### 案例15：水锤防护控制
（内容从之前的案例10移到这里）

---

### 第六章：先进控制方法（案例16-17）

#### 案例16：基于降阶模型的MPC控制
**结合案例4-7的降阶模型**

```python
# 使用POD降阶模型进行MPC
class ROM_MPC_Controller:
    def __init__(self, pod_model, horizon=10):
        self.pod = pod_model  # 来自案例4
        self.N = horizon
        self.r = pod_model.n_modes  # 降阶维数

    def solve(self, a_current, a_target, constraints):
        """
        min  Σ ||a[k] - a_target||²_Q + ||u[k]||²_R
        s.t. a[k+1] = Ar*a[k] + Br*u[k]
             u_min <= u[k] <= u_max
        """
        import cvxpy as cp

        # 决策变量（低维！）
        a = cp.Variable((self.r, self.N+1))
        u = cp.Variable((self.m, self.N))

        # 目标函数
        cost = 0
        for k in range(self.N):
            cost += cp.quad_form(a[:,k] - a_target, self.Q)
            cost += cp.quad_form(u[:,k], self.R)

        # 约束
        constraints_list = [a[:,0] == a_current]
        for k in range(self.N):
            # 降阶动力学
            constraints_list.append(
                a[:,k+1] == self.pod.Ar @ a[:,k] + self.pod.Br @ u[:,k]
            )

            # 控制约束
            constraints_list.append(u[:,k] >= constraints['u_min'])
            constraints_list.append(u[:,k] <= constraints['u_max'])

            # 状态约束（重构到物理空间）
            h_k = self.pod.Phi @ a[:,k]  # N_x维
            constraints_list.append(h_k >= constraints['h_min'])
            constraints_list.append(h_k <= constraints['h_max'])

        # 求解
        prob = cp.Problem(cp.Minimize(cost), constraints_list)
        prob.solve(solver=cp.OSQP)

        return u[:,0].value  # 返回第一步控制

# 完整闭环
pod_model = POD_Model(...)  # 来自案例4
mpc = ROM_MPC_Controller(pod_model, horizon=10)

for t in time_steps:
    # 当前状态（降阶空间）
    a_current = pod_model.project(h_current)

    # MPC求解
    u_opt = mpc.solve(a_current, a_target, constraints)

    # 应用控制
    apply_control(u_opt)

    # 物理系统演化
    h_next = solve_saint_venant(h_current, u_opt)
    h_current = h_next
```

**对比实验**:
- 全阶MPC vs 降阶MPC
- 计算时间对比
- 控制性能对比
- 不同降阶方法（POD vs DMD vs NN）

**难度**: ⭐⭐⭐⭐⭐
**代码量**: ~1100行

---

#### 案例17：自适应MPC - 在线模型更新
**结合案例8-11的系统辨识**

```python
class AdaptiveMPC:
    """
    自适应MPC：在线更新模型
    """
    def __init__(self, initial_model):
        self.model = initial_model
        self.mpc = MPCController(self.model)

        # 在线辨识器
        self.identifier = RecursiveLeastSquares()

        # 数据缓冲
        self.buffer = collections.deque(maxlen=100)

    def control(self, x_current, x_target):
        # 1. 使用当前模型计算MPC
        u = self.mpc.solve(x_current, x_target)

        # 2. 应用控制，观测结果
        x_next = self.system.step(u)

        # 3. 更新数据缓冲
        self.buffer.append((x_current, u, x_next))

        # 4. 在线更新模型（每N步）
        if len(self.buffer) >= self.update_threshold:
            self.update_model()

        return u

    def update_model(self):
        """在线更新模型参数"""
        X = np.array([d[0] for d in self.buffer])
        U = np.array([d[1] for d in self.buffer])
        X_next = np.array([d[2] for d in self.buffer])

        # RLS更新
        A_new, B_new = self.identifier.update(X, U, X_next)

        # 更新MPC模型
        self.model.A = A_new
        self.model.B = B_new
        self.mpc.update_model(self.model)
```

**实验**:
1. 固定模型MPC vs 自适应MPC
2. 参数突变响应
3. 长期运行性能
4. 不同辨识算法对比

**难度**: ⭐⭐⭐⭐⭐
**代码量**: ~1200行

---

### 第七章：智能控制与优化（案例18-19）

#### 案例18：强化学习 - 多闸门协同调度
（从之前案例移动，增加与数字孪生的结合）

#### 案例19：综合性能对比
（所有方法的对比）

---

### 第八章：综合应用（案例20）

#### 案例20：南水北调工程 - 完整数字孪生系统
**集成所有技术**:
- 降阶模型（加速计算）
- 系统辨识（参数校准）
- 数字孪生（虚实映射）
- 预测性维护（设备管理）
- 多层控制（优化调度）

---

## 🛠️ 技术实现总结

### 新增的核心工具库

```python
# 模型降阶
books/canal_pipeline_control/code/rom/
├── pod.py              # POD降阶
├── dmd.py              # 动态模态分解
├── galerkin.py         # Galerkin投影
└── neural_rom.py       # 神经网络降阶

# 系统辨识
books/canal_pipeline_control/code/identification/
├── n4sid.py            # 子空间辨识
├── frequency.py        # 频域辨识
├── hammerstein.py      # 非线性辨识
└── sindy.py            # 稀疏辨识

# 数字孪生
books/canal_pipeline_control/code/digital_twin/
├── twin_core.py        # 孪生核心
├── state_estimation.py # 状态估计
├── virtual_sensor.py   # 虚拟传感
└── predictive_maintenance.py  # 预测维护
```

---

## 📅 更新后的开发计划

### 阶段1：基础（1周）
- 案例1-3：分布式PID

### 阶段2：模型降阶（3周）⭐ 重点
- 案例4：POD
- 案例5：DMD
- 案例6：Galerkin
- 案例7：NN-ROM

### 阶段3：系统辨识（3周）⭐ 重点
- 案例8：N4SID
- 案例9：频域辨识
- 案例10：非线性辨识
- 案例11：SINDy

### 阶段4：数字孪生（2周）⭐ 重点
- 案例12：孪生架构
- 案例13：预测维护

### 阶段5：管道控制（2周）
- 案例14-15

### 阶段6：先进控制（2周）
- 案例16-17

### 阶段7：智能控制（2周）
- 案例18-19

### 阶段8：综合应用（3周）
- 案例20：南水北调

**总计**: 约18周（保持不变）

---

## 📖 新增参考文献

### 模型降阶
1. *Model Reduction and Approximation* - Benner et al.
2. *Reduced Order Methods for Modeling and Computational Reduction* - Quarteroni & Rozza
3. *Dynamic Mode Decomposition* - Kutz et al.

### 系统辨识
4. *System Identification* - Ljung
5. *Subspace Methods for System Identification* - Katayama
6. *Nonlinear System Identification* - Nelles

### 数字孪生
7. *Digital Twin: Enabling Technologies, Challenges and Open Research* - IEEE
8. *Digital Twins for Smart Cities* - IBM白皮书
9. *Predictive Maintenance 4.0* - Siemens研究报告

---

## ✅ v3.0版本更新总结

### 新增内容

1. **模型降阶方法**（4个案例）
   - POD/SVD降阶
   - 动态模态分解（DMD）
   - Galerkin投影
   - 神经网络降阶

2. **系统辨识方法**（4个案例）
   - 子空间辨识（N4SID）
   - 频域辨识
   - 非线性辨识（Hammerstein-Wiener）
   - 数据驱动辨识（SINDy）

3. **数字孪生技术**（2个案例）
   - 完整孪生架构
   - 预测性维护应用

### 价值提升

- **理论完整性**: 从物理建模 → 降阶 → 辨识 → 控制 → 孪生，形成完整闭环
- **工程实用性**: 所有方法都是实际工程必需的
- **前沿性**: 涵盖最新的数字孪生、SINDy等前沿技术
- **教学价值**: 每个方法都有详细的理论推导和代码实现

---

**提纲完成日期**: 2025-10-30
**版本**: v3.0-complete
**状态**: 📝 待审阅
