# æ¸ é“ã€ç®¡é“ä¸ç®¡æ¸ ç³»ç»Ÿæ§åˆ¶æ•™ç¨‹ - å®Œæ•´æçº² v3.0
## èåˆæ§åˆ¶è®º+æ°´åŠ›å­¦+å»ºæ¨¡è¾¨è¯†+æ•°å­—å­ªç”Ÿ

**ç‰ˆæœ¬**: v3.0-complete
**æ—¥æœŸ**: 2025-10-30
**çŠ¶æ€**: ğŸ“ æçº²è®¾è®¡é˜¶æ®µï¼ˆå¢å¼ºç‰ˆï¼‰

---

## ğŸ“š è¯¾ç¨‹å®šä½

æœ¬è¯¾ç¨‹æ˜¯ã€Šæ°´ç³»ç»Ÿæ§åˆ¶è®ºã€‹å’Œã€Šæ˜æ¸ æ°´åŠ›å­¦ã€‹çš„**ç»¼åˆè¿›é˜¶è¯¾ç¨‹**ï¼Œç³»ç»Ÿæ¶µç›–ï¼š
1. âœ… åˆ†å¸ƒå‚æ•°ç³»ç»Ÿæ§åˆ¶ç†è®º
2. âœ… **æ¨¡å‹é™é˜¶æ–¹æ³•**ï¼ˆPDE â†’ ODEï¼‰
3. âœ… **ç³»ç»Ÿè¾¨è¯†æŠ€æœ¯**ï¼ˆæ•°æ®é©±åŠ¨å»ºæ¨¡ï¼‰
4. âœ… **æ•°å­—å­ªç”Ÿåº”ç”¨**ï¼ˆè™šå®èåˆï¼‰
5. âœ… æ™ºèƒ½æ§åˆ¶ä¸ä¼˜åŒ–è°ƒåº¦

---

## ğŸ¯ æ ¸å¿ƒæŠ€æœ¯ä½“ç³»

### æŠ€æœ¯é‡‘å­—å¡”

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   æ•°å­—å­ªç”Ÿå¹³å°      â”‚
                    â”‚  (è™šå®èåˆã€é¢„æµ‹)   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                    â”‚                    â”‚
    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
    â”‚ æ™ºèƒ½æ§åˆ¶   â”‚      â”‚ å…ˆè¿›æ§åˆ¶   â”‚      â”‚ ä¼˜åŒ–è°ƒåº¦   â”‚
    â”‚(RL/NN/DL) â”‚      â”‚(MPC/é²æ£’)  â”‚      â”‚(MILP/GA)   â”‚
    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
          â”‚                    â”‚                    â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚    æ¨¡å‹é™é˜¶          â”‚
                    â”‚  (PDE â†’ ODE)        â”‚
                    â”‚  POD/DMD/Galerkin   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                    â”‚                    â”‚
    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
    â”‚ ç³»ç»Ÿè¾¨è¯†   â”‚      â”‚ çŠ¶æ€ä¼°è®¡   â”‚      â”‚ ä¼ æ„Ÿèåˆ   â”‚
    â”‚(N4SID/PEM)â”‚      â”‚(KF/PF/EKF) â”‚      â”‚(å¤šæºæ•°æ®)  â”‚
    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
          â”‚                    â”‚                    â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   ç‰©ç†æ¨¡å‹åŸºç¡€       â”‚
                    â”‚ Saint-Venantæ–¹ç¨‹    â”‚
                    â”‚ è¾¾è¥¿å®šå¾‹/æ°´é”¤æ–¹ç¨‹   â”‚
                    â”‚ (æ˜æ¸ æ°´åŠ›å­¦æä¾›)    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“– è¯¾ç¨‹ç»“æ„ï¼ˆ20ä¸ªæ¡ˆä¾‹ï¼‰- é‡æ–°è®¾è®¡

### ç¬¬ä¸€ç« ï¼šåˆ†å¸ƒå¼æ§åˆ¶åŸºç¡€ï¼ˆæ¡ˆä¾‹1-3ï¼‰

#### æ¡ˆä¾‹1ï¼šå•æ¸ æ®µPIDæ°´ä½æ§åˆ¶
- åŸºç¡€PIDæ§åˆ¶
- æ—¶æ»è¡¥å¿
- é—¸é—¨éçº¿æ€§å¤„ç†

#### æ¡ˆä¾‹2ï¼šå¤šç‚¹åé¦ˆåˆ†å¸ƒå¼PIDæ§åˆ¶
- å¤šä¼ æ„Ÿå™¨èåˆ
- åŠ æƒåé¦ˆç­–ç•¥
- æµ‹ç‚¹ä¼˜åŒ–å¸ƒç½®

#### æ¡ˆä¾‹3ï¼šå‰é¦ˆ-åé¦ˆå¤åˆæ§åˆ¶
- æ‰°åŠ¨å‰é¦ˆè¡¥å¿
- åé¦ˆé²æ£’æ§åˆ¶
- å‰é¦ˆå¢ç›Šè®¾è®¡

---

### ç¬¬äºŒç« ï¼šæ¨¡å‹é™é˜¶æ–¹æ³• â­â­â­ **ã€æ–°å¢æ ¸å¿ƒç« èŠ‚ã€‘**

#### æ¡ˆä¾‹4ï¼šPODé™é˜¶ - æœ¬å¾æ­£äº¤åˆ†è§£
**ç†è®ºåŸºç¡€**:
- Proper Orthogonal Decomposition
- Karhunen-LoÃ¨veå±•å¼€
- èƒ½é‡æ•è·ç‡

**é™é˜¶è¿‡ç¨‹**:
```python
# 1. æ”¶é›†å¿«ç…§æ•°æ®
snapshots = []
for t in time_steps:
    h, Q = solve_saint_venant(...)
    snapshots.append(h)  # N_x Ã— 1

# 2. æ„é€ å¿«ç…§çŸ©é˜µ
X = np.column_stack(snapshots)  # N_x Ã— N_t

# 3. SVDåˆ†è§£
U, S, Vt = np.linalg.svd(X, full_matrices=False)

# 4. é€‰æ‹©å‰rä¸ªæ¨¡æ€
r = 10  # é™é˜¶ç»´æ•°
Phi = U[:, :r]  # åŸºå‡½æ•°çŸ©é˜µ N_x Ã— r

# 5. GalerkinæŠ•å½±
# h(x,t) â‰ˆ Î¦ * a(t)
# å°†PDEæŠ•å½±åˆ°ä½ç»´å­ç©ºé—´
def reduced_dynamics(a, t):
    # da/dt = Ar*a + Br*u
    return Ar @ a + Br @ u

# 6. é™é˜¶æ¨¡å‹æ§åˆ¶å™¨è®¾è®¡
from scipy.integrate import odeint
from water_system_control.controllers import PIDController

pid = PIDController(Kp=2, Ki=0.5, Kd=1)
for t in time:
    a_current = ...  # rç»´çŠ¶æ€
    h_reconstructed = Phi @ a_current  # é‡æ„ N_xç»´
    u = pid.compute(h_reconstructed[-1])
    ...
```

**è¯„ä¼°æŒ‡æ ‡**:
```python
# èƒ½é‡æ•è·ç‡
energy_ratio = sum(S[:r]**2) / sum(S**2)

# é‡æ„è¯¯å·®
error = norm(h_full - h_reduced) / norm(h_full)

# è®¡ç®—åŠ é€Ÿæ¯”
speedup = time_full / time_reduced
```

**å®éªŒ**:
1. ä¸åŒæ¨¡æ€æ•° r=5,10,20,50
2. POD vs å…¨é˜¶æ¨¡å‹ç²¾åº¦å¯¹æ¯”
3. æ§åˆ¶æ€§èƒ½å¯¹æ¯”
4. è®¡ç®—æ—¶é—´å¯¹æ¯”

**éš¾åº¦**: â­â­â­â­
**ä»£ç é‡**: ~1000è¡Œ

---

#### æ¡ˆä¾‹5ï¼šåŠ¨æ€æ¨¡æ€åˆ†è§£ï¼ˆDMDï¼‰
**ç†è®ºåŸºç¡€**:
- Dynamic Mode Decomposition
- Koopmanç®—å­ç†è®º
- çº¿æ€§ç®—å­é€¼è¿‘

**DMDç®—æ³•**:
```python
# 1. æ•°æ®çŸ©é˜µ
X = [x0, x1, ..., x_{m-1}]  # N Ã— m
Y = [x1, x2, ..., x_m]      # N Ã— m

# 2. DMDåˆ†è§£
U, S, Vt = np.linalg.svd(X, full_matrices=False)

# 3. é™é˜¶çº¿æ€§ç®—å­
A_tilde = U.T @ Y @ Vt.T @ np.diag(1/S)

# 4. ç‰¹å¾åˆ†è§£
eigenvalues, eigenvectors = np.linalg.eig(A_tilde)

# 5. DMDæ¨¡æ€
Phi = Y @ Vt.T @ np.diag(1/S) @ eigenvectors

# 6. é¢„æµ‹
x(t) â‰ˆ Î£ Ï†_k * exp(Î»_k * t) * b_k
```

**åº”ç”¨**:
```python
# çŸ­æœŸé¢„æµ‹ï¼ˆç”¨äºMPCï¼‰
def dmd_predict(x0, dt, n_steps):
    b = np.linalg.lstsq(Phi, x0)[0]
    predictions = []
    for k in range(n_steps):
        t = k * dt
        x_pred = Phi @ (np.exp(eigenvalues * t) * b)
        predictions.append(x_pred)
    return predictions

# åœ¨MPCä¸­ä½¿ç”¨DMDæ¨¡å‹
class DMD_MPC:
    def __init__(self, dmd_model):
        self.Phi = dmd_model.Phi
        self.eigenvalues = dmd_model.eigenvalues

    def predict_horizon(self, x0, u_sequence, N):
        # ä½¿ç”¨DMDå¿«é€Ÿé¢„æµ‹Næ­¥
        x_pred = []
        for k in range(N):
            x_k = dmd_predict(x0, dt*k, 1)
            x_pred.append(x_k)
        return x_pred
```

**æ‰©å±•ï¼šDMDå˜ç§**:
1. **Exact DMD**: ç²¾ç¡®ç®—æ³•
2. **Extended DMD**: éçº¿æ€§ç³»ç»Ÿ
3. **DMD with Control**: å«æ§åˆ¶è¾“å…¥
4. **Optimized DMD**: ç¨€ç–ä¼˜åŒ–

**å®éªŒ**:
1. DMD vs PODå¯¹æ¯”
2. é¢„æµ‹ç²¾åº¦åˆ†æ
3. ä¸åŒæ—¶é—´çª—å£å½±å“
4. åœ¨çº¿æ›´æ–°DMDæ¨¡å‹

**éš¾åº¦**: â­â­â­â­â­
**ä»£ç é‡**: ~1100è¡Œ

---

#### æ¡ˆä¾‹6ï¼šGalerkinæŠ•å½±ä¸æœ‰é™å…ƒé™é˜¶
**ç†è®ºåŸºç¡€**:
- Galerkinæ–¹æ³•
- æœ‰é™å…ƒåŸºå‡½æ•°
- å¼±å½¢å¼

**GalerkinæŠ•å½±**:
```python
# åŸPDEï¼ˆSaint-Venantï¼‰
âˆ‚h/âˆ‚t + âˆ‚Q/âˆ‚x = 0
âˆ‚Q/âˆ‚t + âˆ‚(QÂ²/A)/âˆ‚x + gA*âˆ‚h/âˆ‚x = -gA*Sf

# é€‰æ‹©åŸºå‡½æ•° Ï†_i(x)
# h(x,t) = Î£ a_i(t) * Ï†_i(x)

# GalerkinæŠ•å½±ï¼š
âˆ« [âˆ‚h/âˆ‚t + âˆ‚Q/âˆ‚x] * Ï†_j(x) dx = 0

# å¾—åˆ°ODEç³»ç»Ÿ
da/dt = f(a, u)  # rç»´ODE
```

**å®ç°**:
```python
class GalerkinReducedModel:
    def __init__(self, basis_functions, n_modes):
        self.phi = basis_functions  # åŸºå‡½æ•°
        self.r = n_modes

    def project_pde(self, saint_venant_operator):
        """æŠ•å½±PDEåˆ°å­ç©ºé—´"""
        # è´¨é‡çŸ©é˜µ
        M = self.compute_mass_matrix()

        # åˆšåº¦çŸ©é˜µ
        K = self.compute_stiffness_matrix()

        # é™é˜¶ç³»ç»Ÿ: M*da/dt = K*a + B*u
        return M, K

    def compute_mass_matrix(self):
        M = np.zeros((self.r, self.r))
        for i in range(self.r):
            for j in range(self.r):
                M[i,j] = self.integrate(self.phi[i] * self.phi[j])
        return M

    def solve_reduced_system(self, u, T):
        """æ±‚è§£é™é˜¶ODE"""
        from scipy.integrate import odeint

        def ode_rhs(a, t):
            return np.linalg.solve(self.M, self.K @ a + self.B * u(t))

        a = odeint(ode_rhs, a0, np.linspace(0, T, 1000))
        return a
```

**åŸºå‡½æ•°é€‰æ‹©**:
1. **æ­£å¼¦/ä½™å¼¦**: å‘¨æœŸè¾¹ç•Œ
2. **å¤šé¡¹å¼**: Legendreã€Chebyshev
3. **æ ·æ¡**: B-spline
4. **PODæ¨¡æ€**: æ•°æ®é©±åŠ¨

**å®éªŒ**:
1. ä¸åŒåŸºå‡½æ•°æ€§èƒ½å¯¹æ¯”
2. è¾¹ç•Œæ¡ä»¶å¤„ç†
3. éçº¿æ€§é¡¹å¤„ç†
4. è‡ªé€‚åº”åŸºå‡½æ•°é€‰æ‹©

**éš¾åº¦**: â­â­â­â­â­
**ä»£ç é‡**: ~1200è¡Œ

---

#### æ¡ˆä¾‹7ï¼šç¥ç»ç½‘ç»œé™é˜¶æ¨¡å‹
**ç†è®ºåŸºç¡€**:
- Autoencoderæ¶æ„
- Physics-Informed Neural Networks (PINN)
- ç¥ç»ç®—å­ï¼ˆNeural Operatorï¼‰

**Autoencoderé™é˜¶**:
```python
import torch
import torch.nn as nn

class ChannelAutoencoder(nn.Module):
    def __init__(self, spatial_dim=100, latent_dim=10):
        super().__init__()

        # ç¼–ç å™¨ï¼šN_xç»´ â†’ rç»´
        self.encoder = nn.Sequential(
            nn.Linear(spatial_dim, 64),
            nn.Tanh(),
            nn.Linear(64, 32),
            nn.Tanh(),
            nn.Linear(32, latent_dim)
        )

        # è§£ç å™¨ï¼šrç»´ â†’ N_xç»´
        self.decoder = nn.Sequential(
            nn.Linear(latent_dim, 32),
            nn.Tanh(),
            nn.Linear(32, 64),
            nn.Tanh(),
            nn.Linear(64, spatial_dim)
        )

    def forward(self, x):
        z = self.encoder(x)  # ç¼–ç åˆ°ä½ç»´
        x_recon = self.decoder(z)  # è§£ç å›é«˜ç»´
        return x_recon, z

# è®­ç»ƒ
model = ChannelAutoencoder(spatial_dim=100, latent_dim=10)
optimizer = torch.optim.Adam(model.parameters())

for epoch in range(1000):
    for h_snapshot in dataloader:
        h_recon, z = model(h_snapshot)
        loss = nn.MSELoss()(h_recon, h_snapshot)
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
```

**åŠ¨åŠ›å­¦ç¥ç»ç½‘ç»œ**:
```python
class LatentDynamicsNN(nn.Module):
    """å­¦ä¹ ä½ç»´çŠ¶æ€çš„æ¼”åŒ–"""
    def __init__(self, latent_dim=10, control_dim=1):
        super().__init__()
        self.net = nn.Sequential(
            nn.Linear(latent_dim + control_dim, 64),
            nn.Tanh(),
            nn.Linear(64, 64),
            nn.Tanh(),
            nn.Linear(64, latent_dim)
        )

    def forward(self, z, u):
        """é¢„æµ‹ä¸‹ä¸€æ—¶åˆ»çš„ä½ç»´çŠ¶æ€"""
        inp = torch.cat([z, u], dim=-1)
        z_next = self.net(inp)
        return z_next

# å®Œæ•´çš„é™é˜¶æ¨¡å‹
class NeuralROM:
    def __init__(self, autoencoder, dynamics_net):
        self.ae = autoencoder
        self.dyn = dynamics_net

    def predict(self, h0, u_sequence):
        # ç¼–ç 
        z0 = self.ae.encoder(h0)

        # åœ¨ä½ç»´ç©ºé—´æ¼”åŒ–
        z_traj = [z0]
        for u_t in u_sequence:
            z_next = self.dyn(z_traj[-1], u_t)
            z_traj.append(z_next)

        # è§£ç å›é«˜ç»´
        h_traj = [self.ae.decoder(z) for z in z_traj]
        return h_traj
```

**Physics-InformedæŸå¤±**:
```python
def physics_loss(h_pred, h_true):
    # æ•°æ®æŸå¤±
    data_loss = mse_loss(h_pred, h_true)

    # ç‰©ç†æŸå¤±ï¼ˆæ»¡è¶³PDEï¼‰
    dh_dt = compute_time_derivative(h_pred)
    dQ_dx = compute_space_derivative(Q_pred)
    continuity_residual = dh_dt + dQ_dx  # åº”è¯¥â‰ˆ0

    physics_loss = mse_loss(continuity_residual, torch.zeros_like(continuity_residual))

    return data_loss + lambda_physics * physics_loss
```

**å®éªŒ**:
1. NN-ROM vs PODæ€§èƒ½å¯¹æ¯”
2. ä¸åŒç½‘ç»œæ¶æ„æµ‹è¯•
3. ç‰©ç†çº¦æŸçš„ä½œç”¨
4. æ³›åŒ–èƒ½åŠ›æµ‹è¯•ï¼ˆä¸åŒå·¥å†µï¼‰

**éš¾åº¦**: â­â­â­â­â­
**ä»£ç é‡**: ~1300è¡Œ

---

### ç¬¬ä¸‰ç« ï¼šç³»ç»Ÿè¾¨è¯†æ–¹æ³• â­â­â­ **ã€æ–°å¢æ ¸å¿ƒç« èŠ‚ã€‘**

#### æ¡ˆä¾‹8ï¼šå­ç©ºé—´è¾¨è¯†ï¼ˆN4SIDï¼‰
**ç†è®ºåŸºç¡€**:
- çŠ¶æ€ç©ºé—´æ¨¡å‹è¾¨è¯†
- Numerical Subspace State Space Identification
- HankelçŸ©é˜µ

**N4SIDç®—æ³•**:
```python
from scipy.linalg import svd, lstsq

def n4sid(y, u, order):
    """
    y: è¾“å‡ºæ•°æ® (N_samples Ã— N_outputs)
    u: è¾“å…¥æ•°æ® (N_samples Ã— N_inputs)
    order: æ¨¡å‹é˜¶æ•°
    """
    # 1. æ„é€ HankelçŸ©é˜µ
    i = 20  # è¡Œå—æ•°
    Y = hankel_matrix(y, i)
    U = hankel_matrix(u, i)

    # 2. LQåˆ†è§£
    L, Q = np.linalg.qr(np.vstack([U, Y]).T)

    # 3. æå–å¯è§‚æµ‹æ€§çŸ©é˜µ
    O = L[n_u*i:, :order]

    # 4. SVDç¡®å®šé˜¶æ•°
    U_svd, S, Vt = svd(O)
    order_estimated = np.sum(S > threshold)

    # 5. è¾¨è¯†A, CçŸ©é˜µ
    O1 = O[:-n_y, :]
    O2 = O[n_y:, :]
    A = lstsq(O1, O2)[0]
    C = O[:n_y, :]

    # 6. è¾¨è¯†B, DçŸ©é˜µ
    # ...ï¼ˆé€šè¿‡è¾“å…¥è¾“å‡ºå…³ç³»ï¼‰

    return A, B, C, D

# åº”ç”¨åˆ°æ¸ é“ç³»ç»Ÿ
y_data = measured_water_levels  # æ²¿ç¨‹æ°´ä½æµ‹é‡
u_data = gate_openings  # é—¸é—¨å¼€åº¦

A, B, C, D = n4sid(y_data, u_data, order=10)

# å¾—åˆ°çŠ¶æ€ç©ºé—´æ¨¡å‹
# dx/dt = A*x + B*u
# y = C*x + D*u

# ç”¨äºæ§åˆ¶å™¨è®¾è®¡
from scipy.signal import lti
system = lti(A, B, C, D)
```

**æ¨¡å‹éªŒè¯**:
```python
def validate_model(system, y_test, u_test):
    # æ¨¡æ‹Ÿè¾“å‡º
    t, y_sim = system.output(u_test, t)

    # æ‹Ÿåˆä¼˜åº¦ï¼ˆVariance Accounted Forï¼‰
    VAF = (1 - np.var(y_test - y_sim) / np.var(y_test)) * 100

    # æ®‹å·®åˆ†æ
    residuals = y_test - y_sim
    autocorr = np.correlate(residuals, residuals, mode='full')

    return VAF, autocorr
```

**å®éªŒ**:
1. ä¸åŒæ¨¡å‹é˜¶æ•°é€‰æ‹©
2. ä¸ç‰©ç†æ¨¡å‹å¯¹æ¯”
3. é—­ç¯è¾¨è¯† vs å¼€ç¯è¾¨è¯†
4. ä¸åŒæ¿€åŠ±ä¿¡å·å½±å“

**éš¾åº¦**: â­â­â­â­â­
**ä»£ç é‡**: ~1100è¡Œ

---

#### æ¡ˆä¾‹9ï¼šé¢‘åŸŸè¾¨è¯†ä¸ä¼ é€’å‡½æ•°æ‹Ÿåˆ
**ç†è®ºåŸºç¡€**:
- é¢‘ç‡å“åº”æµ‹è¯•
- ä¼ é€’å‡½æ•°ä¼°è®¡
- Bodeå›¾æ‹Ÿåˆ

**é¢‘åŸŸè¾¨è¯†**:
```python
from scipy import signal
from scipy.optimize import least_squares

def frequency_domain_identification(y, u, fs):
    """
    åŸºäºé¢‘åŸŸæ•°æ®è¾¨è¯†ä¼ é€’å‡½æ•°
    """
    # 1. è®¡ç®—é¢‘ç‡å“åº”
    f, Pyu = signal.csd(y, u, fs=fs)
    f, Puu = signal.welch(u, fs=fs)
    H = Pyu / Puu  # é¢‘ç‡å“åº”å‡½æ•°

    # 2. æ‹Ÿåˆä¼ é€’å‡½æ•°
    # H(s) = (b_m*s^m + ... + b_0) / (s^n + a_{n-1}*s^{n-1} + ... + a_0)

    def tf_model(params, s):
        """ä¼ é€’å‡½æ•°æ¨¡å‹"""
        n_num = len(params) // 2
        num = np.poly1d(params[:n_num])
        den = np.poly1d([1] + list(params[n_num:]))
        return num(s) / den(s)

    def residual(params):
        H_model = tf_model(params, 1j*2*np.pi*f)
        return np.abs(H - H_model).flatten()

    # ä¼˜åŒ–
    result = least_squares(residual, initial_params)
    num_coeffs = result.x[:n_num]
    den_coeffs = result.x[n_num:]

    return num_coeffs, den_coeffs

# åº”ç”¨
num, den = frequency_domain_identification(water_levels, gate_openings, fs=1/60)
tf = signal.TransferFunction(num, den)

# ç”¨äºæ§åˆ¶å™¨è®¾è®¡
# å¦‚ï¼šIMCæ§åˆ¶å™¨è®¾è®¡
```

**æ¸ é“ä¼ é€’å‡½æ•°æ¨¡å‹**:
```python
# å…¸å‹çš„æ¸ é“ä¼ é€’å‡½æ•°ï¼ˆå¸¦æ—¶æ»ï¼‰
# G(s) = K * exp(-Ï„*s) / (T*s + 1)^n

class CanalTransferFunction:
    def __init__(self, K, tau, T, n):
        self.K = K      # å¢ç›Š
        self.tau = tau  # æ—¶æ»
        self.T = T      # æ—¶é—´å¸¸æ•°
        self.n = n      # é˜¶æ•°

    def frequency_response(self, omega):
        s = 1j * omega
        return self.K * np.exp(-self.tau*s) / (self.T*s + 1)**self.n

    def bode_plot(self):
        w = np.logspace(-3, 1, 100)
        H = self.frequency_response(w)
        mag = 20 * np.log10(np.abs(H))
        phase = np.angle(H, deg=True)

        plt.figure(figsize=(10,8))
        plt.subplot(211)
        plt.semilogx(w, mag)
        plt.ylabel('Magnitude (dB)')
        plt.grid()

        plt.subplot(212)
        plt.semilogx(w, phase)
        plt.ylabel('Phase (deg)')
        plt.xlabel('Frequency (rad/s)')
        plt.grid()
```

**å®éªŒ**:
1. PRBSæ¿€åŠ±ä¿¡å·æµ‹è¯•
2. Chirpä¿¡å·æ‰«é¢‘æµ‹è¯•
3. ä¸åŒæ¨¡å‹ç»“æ„å¯¹æ¯”
4. Bodeå›¾åŒ¹é…ä¼˜åŒ–

**éš¾åº¦**: â­â­â­â­
**ä»£ç é‡**: ~900è¡Œ

---

#### æ¡ˆä¾‹10ï¼šéçº¿æ€§ç³»ç»Ÿè¾¨è¯† - Hammerstein-Wieneræ¨¡å‹
**ç†è®ºåŸºç¡€**:
- éçº¿æ€§å—ç»“æ„æ¨¡å‹
- Hammersteinæ¨¡å‹ï¼ˆNL â†’ Lï¼‰
- Wieneræ¨¡å‹ï¼ˆL â†’ NLï¼‰
- Hammerstein-Wieneræ¨¡å‹ï¼ˆNL â†’ L â†’ NLï¼‰

**é—¸é—¨-æ°´ä½éçº¿æ€§è¾¨è¯†**:
```python
class HammersteinWienerModel:
    """
    u â†’ [f(Â·)] â†’ v â†’ [G(z)] â†’ w â†’ [g(Â·)] â†’ y
    è¾“å…¥   é™æ€éçº¿æ€§  çº¿æ€§åŠ¨æ€  é™æ€éçº¿æ€§  è¾“å‡º
    """
    def __init__(self):
        # è¾“å…¥éçº¿æ€§ï¼ˆé—¸é—¨-æµé‡å…³ç³»ï¼‰
        self.f_input = self.input_nonlinearity

        # çº¿æ€§åŠ¨æ€éƒ¨åˆ†
        self.G = None  # ä¼ é€’å‡½æ•°

        # è¾“å‡ºéçº¿æ€§
        self.g_output = self.output_nonlinearity

    def input_nonlinearity(self, u):
        """
        é—¸é—¨å¼€åº¦ u â†’ æµé‡ Q
        Q = Cd * u * A * sqrt(2*g*h_upstream)
        """
        # å¤šé¡¹å¼è¿‘ä¼¼
        return self.poly_input(u)

    def output_nonlinearity(self, w):
        """æµé‡ â†’ æ°´ä½"""
        return self.poly_output(w)

    def fit(self, u_data, y_data):
        """
        è¿­ä»£è¾¨è¯†ç®—æ³•
        """
        # 1. åˆå§‹åŒ–ï¼šå‡è®¾çº¿æ€§
        self.G = identify_linear_part(u_data, y_data)

        # 2. è¿­ä»£ä¼˜åŒ–
        for iter in range(max_iter):
            # å›ºå®š Gï¼Œè¾¨è¯† f å’Œ g
            self.fit_nonlinearities(u_data, y_data)

            # å›ºå®š f å’Œ gï¼Œè¾¨è¯† G
            v = self.f_input(u_data)
            w = self.G.output(v)
            self.G = identify_linear_part(v, inverse(self.g_output, y_data))

            # æ£€æŸ¥æ”¶æ•›
            if converged:
                break

        return self

def identify_hammerstein_wiener(u, y):
    """å®Œæ•´è¾¨è¯†æµç¨‹"""
    model = HammersteinWienerModel()
    model.fit(u, y)
    return model

# åº”ç”¨
model = identify_hammerstein_wiener(gate_openings, water_levels)

# é¢„æµ‹
y_pred = model.predict(u_test)
```

**é«˜çº§ï¼šVolterraçº§æ•°**:
```python
class VolterraModel:
    """
    y(t) = h0 + Î£ h1(Ï„1)*u(t-Ï„1) +
           Î£Î£ h2(Ï„1,Ï„2)*u(t-Ï„1)*u(t-Ï„2) +
           ...
    """
    def __init__(self, order=2, memory=10):
        self.order = order
        self.memory = memory
        self.kernels = []

    def fit(self, u, y):
        # Lee-Schetzenæ–¹æ³•
        # ä½¿ç”¨é«˜æ–¯ç™½å™ªå£°æ¿€åŠ±
        ...

# å¯¹äºä¸¥é‡éçº¿æ€§çš„æ¸ é“ç³»ç»Ÿ
volterra_model = VolterraModel(order=2, memory=20)
volterra_model.fit(u, y)
```

**å®éªŒ**:
1. Hammerstein vs Wiener vs HWå¯¹æ¯”
2. ä¸åŒéçº¿æ€§å‡½æ•°å½¢å¼
3. çº¿æ€§éƒ¨åˆ†é˜¶æ•°å½±å“
4. ä¸ç¥ç»ç½‘ç»œæ¨¡å‹å¯¹æ¯”

**éš¾åº¦**: â­â­â­â­â­
**ä»£ç é‡**: ~1200è¡Œ

---

#### æ¡ˆä¾‹11ï¼šæ•°æ®é©±åŠ¨è¾¨è¯† - SINDyä¸ç¨€ç–è¾¨è¯†
**ç†è®ºåŸºç¡€**:
- Sparse Identification of Nonlinear Dynamics (SINDy)
- ç¨€ç–å›å½’
- ç¬¦å·å›å½’

**SINDyç®—æ³•**:
```python
from sklearn.linear_model import Lasso

def sindy(X, dX_dt, poly_order=3, threshold=0.01):
    """
    X: çŠ¶æ€æ•°æ® (n_samples Ã— n_states)
    dX_dt: çŠ¶æ€å¯¼æ•° (n_samples Ã— n_states)
    """
    # 1. æ„é€ å€™é€‰å‡½æ•°åº“
    # Î˜(X) = [1, x1, x2, x1Â², x1*x2, x2Â², x1Â³, ...]

    Theta = build_library(X, poly_order)
    # Theta shape: (n_samples Ã— n_library_functions)

    # 2. ç¨€ç–å›å½’
    # dX/dt = Î˜(X) * Î
    # æ±‚è§£ Îï¼ˆç³»æ•°çŸ©é˜µï¼‰

    Xi = np.zeros((Theta.shape[1], X.shape[1]))

    for i in range(X.shape[1]):
        # Lassoå›å½’ï¼ˆL1æ­£åˆ™åŒ– â†’ ç¨€ç–ï¼‰
        model = Lasso(alpha=threshold)
        model.fit(Theta, dX_dt[:, i])
        Xi[:, i] = model.coef_

    return Xi, Theta

def build_library(X, poly_order):
    """æ„é€ å¤šé¡¹å¼åº“"""
    n_samples, n_vars = X.shape
    library = [np.ones(n_samples)]  # å¸¸æ•°é¡¹

    # ä¸€æ¬¡é¡¹
    for i in range(n_vars):
        library.append(X[:, i])

    # äºŒæ¬¡é¡¹
    if poly_order >= 2:
        for i in range(n_vars):
            for j in range(i, n_vars):
                library.append(X[:, i] * X[:, j])

    # ä¸‰æ¬¡é¡¹
    if poly_order >= 3:
        for i in range(n_vars):
            for j in range(i, n_vars):
                for k in range(j, n_vars):
                    library.append(X[:, i] * X[:, j] * X[:, k])

    # ä¸‰è§’å‡½æ•°é¡¹ï¼ˆå¯é€‰ï¼‰
    for i in range(n_vars):
        library.append(np.sin(X[:, i]))
        library.append(np.cos(X[:, i]))

    return np.column_stack(library)

# åº”ç”¨åˆ°æ¸ é“ç³»ç»Ÿ
# çŠ¶æ€ï¼šx = [h1, h2, ..., h_N, Q1, Q2, ..., Q_M]

# ä»æ•°æ®è®¡ç®—å¯¼æ•°
X = state_data
dX_dt = np.gradient(X, dt, axis=0)

# è¾¨è¯†
Xi, Theta = sindy(X, dX_dt, poly_order=3)

# å¾—åˆ°çš„æ¨¡å‹ï¼š
# dh1/dt = Î¾_{11} + Î¾_{21}*h1 + Î¾_{31}*Q1 + Î¾_{41}*h1Â² + ...
# dh2/dt = Î¾_{12} + Î¾_{22}*h2 + Î¾_{32}*Q2 + ...

# æ‰“å°å‘ç°çš„æ–¹ç¨‹
def print_equations(Xi, Theta, feature_names):
    for i, eq in enumerate(Xi.T):
        terms = []
        for j, coef in enumerate(eq):
            if abs(coef) > 1e-6:
                terms.append(f"{coef:.4f}*{feature_names[j]}")
        print(f"dx{i}/dt = {' + '.join(terms)}")

print_equations(Xi, Theta, feature_names)
```

**è¾“å‡ºç¤ºä¾‹**:
```
# å‘ç°çš„æ–¹ç¨‹ï¼ˆå¯èƒ½ç»“æœï¼‰
dh1/dt = -0.0123*Q1 + 0.0045*Q0
dQ1/dt = -9.81*h1 + 9.81*h0 - 0.0234*Q1*|Q1|
...
# å¯ä»¥çœ‹å‡ºæ˜¯Saint-Venantæ–¹ç¨‹çš„ç¦»æ•£å½¢å¼ï¼
```

**PySINDyåº“åº”ç”¨**:
```python
import pysindy as ps

model = ps.SINDy(
    optimizer=ps.STLSQ(threshold=0.01),
    feature_library=ps.PolynomialLibrary(degree=3),
    differentiation_method=ps.FiniteDifference()
)

model.fit(X, t=t, u=u)  # uæ˜¯æ§åˆ¶è¾“å…¥
model.print()

# ç”¨äºé¢„æµ‹
X_pred = model.simulate(X[0], t, u=u)
```

**å®éªŒ**:
1. ä¸åŒåº“å‡½æ•°ç»„åˆ
2. ç¨€ç–åº¦é˜ˆå€¼å½±å“
3. å™ªå£°é²æ£’æ€§æµ‹è¯•
4. ä¸ç‰©ç†æ¨¡å‹ç¬¦å·å¯¹æ¯”

**éš¾åº¦**: â­â­â­â­â­
**ä»£ç é‡**: ~1000è¡Œ

---

### ç¬¬å››ç« ï¼šæ•°å­—å­ªç”ŸæŠ€æœ¯ â­â­â­ **ã€æ–°å¢æ ¸å¿ƒç« èŠ‚ã€‘**

#### æ¡ˆä¾‹12ï¼šæ•°å­—å­ªç”Ÿæ¶æ„ - çŠ¶æ€ä¼°è®¡ä¸è™šæ‹Ÿä¼ æ„Ÿ
**ç†è®ºåŸºç¡€**:
- æ•°å­—å­ªç”Ÿæ¦‚å¿µ
- çŠ¶æ€ä¼°è®¡ç†è®º
- æ•°æ®åŒåŒ–

**æ•°å­—å­ªç”Ÿæ¶æ„**:
```python
class DigitalTwin:
    """
    æ¸ é“ç³»ç»Ÿæ•°å­—å­ªç”Ÿ
    """
    def __init__(self):
        # ç‰©ç†æ¨¡å‹
        self.physical_model = SaintVenantSolver()

        # æ•°æ®é©±åŠ¨æ¨¡å‹ï¼ˆé™é˜¶/NNï¼‰
        self.data_model = None

        # çŠ¶æ€ä¼°è®¡å™¨
        self.estimator = ExtendedKalmanFilter()

        # ä¼ æ„Ÿå™¨æ¨¡å‹
        self.sensors = SensorNetwork()

        # è™šæ‹Ÿä¼ æ„Ÿå™¨
        self.virtual_sensors = {}

    def synchronize(self, measurements):
        """
        åŒæ­¥ç‰©ç†ç³»ç»ŸçŠ¶æ€
        """
        # 1. é¢„æµ‹æ­¥ï¼ˆç‰©ç†æ¨¡å‹å‰å‘ï¼‰
        x_pred = self.physical_model.step(u=self.current_control)

        # 2. æ›´æ–°æ­¥ï¼ˆèåˆæµ‹é‡ï¼‰
        x_est = self.estimator.update(x_pred, measurements)

        # 3. æ›´æ–°æ•°å­—å­ªç”ŸçŠ¶æ€
        self.state = x_est

        return x_est

    def predict_future(self, horizon, control_scenario):
        """
        æœªæ¥çŠ¶æ€é¢„æµ‹
        """
        x_future = []
        x = self.state

        for k in range(horizon):
            u = control_scenario[k]
            x = self.physical_model.step(x, u)
            x_future.append(x)

        return x_future

    def create_virtual_sensor(self, location):
        """
        åˆ›å»ºè™šæ‹Ÿä¼ æ„Ÿå™¨ï¼ˆè½¯æµ‹é‡ï¼‰
        """
        def virtual_sensor_reading():
            # ä»å®Œæ•´çŠ¶æ€ä¼°è®¡ä¸­æå–
            return self.interpolate_state(location)

        self.virtual_sensors[location] = virtual_sensor_reading
        return virtual_sensor_reading

    def anomaly_detection(self):
        """
        å¼‚å¸¸æ£€æµ‹
        """
        # æ¨¡å‹é¢„æµ‹ vs å®é™…æµ‹é‡
        residual = self.measurements - self.model_prediction

        # ç»Ÿè®¡æ£€éªŒ
        if np.linalg.norm(residual) > threshold:
            return True, residual
        return False, residual

    def what_if_analysis(self, scenario):
        """
        What-ifåˆ†æ
        """
        # å…‹éš†å½“å‰çŠ¶æ€
        twin_copy = copy.deepcopy(self)

        # æ¨¡æ‹Ÿä¸åŒåœºæ™¯
        results = twin_copy.simulate(scenario)

        return results
```

**æ‰©å±•å¡å°”æ›¼æ»¤æ³¢å®ç°**:
```python
class ExtendedKalmanFilter:
    """
    é’ˆå¯¹éçº¿æ€§Saint-Venantæ–¹ç¨‹çš„EKF
    """
    def __init__(self, n_states, n_measurements):
        self.n = n_states
        self.m = n_measurements

        # çŠ¶æ€åæ–¹å·®
        self.P = np.eye(n_states)

        # è¿‡ç¨‹å™ªå£°
        self.Q = np.eye(n_states) * 0.01

        # æµ‹é‡å™ªå£°
        self.R = np.eye(n_measurements) * 0.1

    def predict(self, x, u, dt):
        """
        é¢„æµ‹æ­¥
        """
        # éçº¿æ€§çŠ¶æ€è½¬ç§»
        x_pred = self.f(x, u, dt)  # Saint-Venantæ±‚è§£

        # é›…å¯æ¯”çŸ©é˜µ
        F = self.jacobian_f(x, u, dt)

        # åæ–¹å·®é¢„æµ‹
        P_pred = F @ self.P @ F.T + self.Q

        return x_pred, P_pred

    def update(self, x_pred, P_pred, z):
        """
        æ›´æ–°æ­¥
        """
        # é¢„æµ‹æµ‹é‡
        z_pred = self.h(x_pred)

        # æµ‹é‡é›…å¯æ¯”
        H = self.jacobian_h(x_pred)

        # å¡å°”æ›¼å¢ç›Š
        S = H @ P_pred @ H.T + self.R
        K = P_pred @ H.T @ np.linalg.inv(S)

        # çŠ¶æ€æ›´æ–°
        innovation = z - z_pred
        x_est = x_pred + K @ innovation

        # åæ–¹å·®æ›´æ–°
        P_est = (np.eye(self.n) - K @ H) @ P_pred

        self.P = P_est
        return x_est

    def f(self, x, u, dt):
        """çŠ¶æ€è½¬ç§»å‡½æ•°ï¼ˆSaint-Venantï¼‰"""
        return solve_saint_venant_one_step(x, u, dt)

    def h(self, x):
        """æµ‹é‡å‡½æ•°ï¼ˆæå–ä¼ æ„Ÿå™¨ä½ç½®çš„çŠ¶æ€ï¼‰"""
        return x[self.sensor_indices]

    def jacobian_f(self, x, u, dt):
        """æ•°å€¼å¾®åˆ†è®¡ç®—F"""
        F = np.zeros((self.n, self.n))
        eps = 1e-6

        for i in range(self.n):
            x_plus = x.copy()
            x_plus[i] += eps
            f_plus = self.f(x_plus, u, dt)

            x_minus = x.copy()
            x_minus[i] -= eps
            f_minus = self.f(x_minus, u, dt)

            F[:, i] = (f_plus - f_minus) / (2*eps)

        return F
```

**å®æ—¶æ•°å­—å­ªç”Ÿç³»ç»Ÿ**:
```python
class RealtimeDigitalTwin:
    def __init__(self):
        self.twin = DigitalTwin()
        self.history = []

    def run_realtime(self):
        """å®æ—¶è¿è¡Œå¾ªç¯"""
        while True:
            # 1. è·å–ä¼ æ„Ÿå™¨æ•°æ®
            measurements = self.acquire_sensor_data()

            # 2. åŒæ­¥çŠ¶æ€
            state_est = self.twin.synchronize(measurements)

            # 3. å¼‚å¸¸æ£€æµ‹
            is_anomaly, residual = self.twin.anomaly_detection()
            if is_anomaly:
                self.trigger_alarm(residual)

            # 4. çŸ­æœŸé¢„æµ‹ï¼ˆç”¨äºMPCï¼‰
            x_future = self.twin.predict_future(horizon=10, control_scenario=self.mpc_plan)

            # 5. æ›´æ–°å¯è§†åŒ–
            self.update_dashboard(state_est, x_future)

            # 6. è®°å½•å†å²
            self.history.append({
                'time': time.time(),
                'state': state_est,
                'measurements': measurements,
                'prediction': x_future
            })

            time.sleep(60)  # 1åˆ†é’Ÿå‘¨æœŸ
```

**å®éªŒ**:
1. ä¸åŒçŠ¶æ€ä¼°è®¡å™¨å¯¹æ¯”ï¼ˆEKF vs UKF vs PFï¼‰
2. ä¼ æ„Ÿå™¨é…ç½®ä¼˜åŒ–
3. è™šæ‹Ÿä¼ æ„Ÿå™¨ç²¾åº¦éªŒè¯
4. å¼‚å¸¸æ£€æµ‹ç®—æ³•å¯¹æ¯”

**éš¾åº¦**: â­â­â­â­â­
**ä»£ç é‡**: ~1500è¡Œ

---

#### æ¡ˆä¾‹13ï¼šæ•°å­—å­ªç”Ÿ - é¢„æµ‹æ€§ç»´æŠ¤
**åº”ç”¨åœºæ™¯**:
- é—¸é—¨æœºæ¢°ç£¨æŸ
- æ³µç«™è®¾å¤‡åŠ£åŒ–
- æ¸ é“æ·¤ç§¯é¢„æµ‹

**é€€åŒ–æ¨¡å‹**:
```python
class EquipmentDegradationModel:
    """
    è®¾å¤‡é€€åŒ–æ¨¡å‹
    """
    def __init__(self, equipment_type):
        self.type = equipment_type
        self.health_index = 100.0  # å¥åº·æŒ‡æ•° 0-100

    def update_health(self, operating_conditions, dt):
        """
        æ ¹æ®è¿è¡Œæ¡ä»¶æ›´æ–°å¥åº·æŒ‡æ•°
        """
        if self.type == 'gate':
            # é—¸é—¨ç£¨æŸæ¨¡å‹
            wear_rate = self.compute_gate_wear(
                opening_cycles=operating_conditions['cycles'],
                load=operating_conditions['head_difference']
            )
            self.health_index -= wear_rate * dt

        elif self.type == 'pump':
            # æ³µé€€åŒ–æ¨¡å‹
            degradation = self.compute_pump_degradation(
                flow=operating_conditions['flow'],
                cavitation_events=operating_conditions['cavitation']
            )
            self.health_index -= degradation * dt

        # é™åˆ¶åœ¨[0, 100]
        self.health_index = np.clip(self.health_index, 0, 100)

    def predict_rul(self):
        """
        é¢„æµ‹å‰©ä½™ä½¿ç”¨å¯¿å‘½ (Remaining Useful Life)
        """
        # ç®€åŒ–çº¿æ€§æ¨¡å‹
        degradation_rate = self.estimate_degradation_rate()
        rul = self.health_index / degradation_rate
        return rul

    def maintenance_threshold(self):
        """ç»´æŠ¤é˜ˆå€¼"""
        return 30.0  # å¥åº·æŒ‡æ•°<30éœ€è¦ç»´æŠ¤

class PredictiveMaintenanceSystem:
    def __init__(self, digital_twin):
        self.twin = digital_twin
        self.equipment_models = {}

    def add_equipment(self, name, equipment_type):
        self.equipment_models[name] = EquipmentDegradationModel(equipment_type)

    def update(self, operating_data, dt):
        """æ›´æ–°æ‰€æœ‰è®¾å¤‡çŠ¶æ€"""
        for name, model in self.equipment_models.items():
            conditions = operating_data[name]
            model.update_health(conditions, dt)

    def generate_maintenance_plan(self, horizon_days):
        """
        ç”Ÿæˆç»´æŠ¤è®¡åˆ’
        """
        plan = []

        for name, model in self.equipment_models.items():
            rul = model.predict_rul()

            if rul < horizon_days:
                plan.append({
                    'equipment': name,
                    'current_health': model.health_index,
                    'rul_days': rul,
                    'urgency': 'high' if rul < 7 else 'medium',
                    'recommended_action': self.get_maintenance_action(model)
                })

        # æŒ‰ç´§æ€¥ç¨‹åº¦æ’åº
        plan.sort(key=lambda x: x['rul_days'])
        return plan
```

**æ•°æ®é©±åŠ¨çš„RULé¢„æµ‹**:
```python
# ä½¿ç”¨LSTMé¢„æµ‹RUL
class RUL_Predictor:
    def __init__(self):
        self.model = nn.LSTM(
            input_size=10,   # ç‰¹å¾ç»´åº¦
            hidden_size=64,
            num_layers=2,
            output_size=1    # RULé¢„æµ‹
        )

    def train(self, historical_data):
        """
        historical_data: {
            'features': [vibration, temperature, pressure, ...],
            'rul': [remaining days until failure]
        }
        """
        X = historical_data['features']
        y = historical_data['rul']

        # è®­ç»ƒ...

    def predict(self, current_features):
        """é¢„æµ‹å½“å‰RUL"""
        return self.model(current_features)
```

**å®éªŒ**:
1. ä¸åŒé€€åŒ–æ¨¡å‹å¯¹æ¯”
2. RULé¢„æµ‹ç²¾åº¦è¯„ä¼°
3. ç»´æŠ¤ç­–ç•¥ä¼˜åŒ–ï¼ˆé¢„é˜²æ€§vsé¢„æµ‹æ€§ï¼‰
4. æˆæœ¬-æ•ˆç›Šåˆ†æ

**éš¾åº¦**: â­â­â­â­â­
**ä»£ç é‡**: ~1200è¡Œ

---

### ç¬¬äº”ç« ï¼šç®¡é“ç³»ç»Ÿæ§åˆ¶ï¼ˆæ¡ˆä¾‹14-15ï¼‰

#### æ¡ˆä¾‹14ï¼šç®¡ç½‘å¤šæ³µç«™åè°ƒæ§åˆ¶
ï¼ˆå†…å®¹ä»ä¹‹å‰çš„æ¡ˆä¾‹11ç§»åˆ°è¿™é‡Œï¼‰

#### æ¡ˆä¾‹15ï¼šæ°´é”¤é˜²æŠ¤æ§åˆ¶
ï¼ˆå†…å®¹ä»ä¹‹å‰çš„æ¡ˆä¾‹10ç§»åˆ°è¿™é‡Œï¼‰

---

### ç¬¬å…­ç« ï¼šå…ˆè¿›æ§åˆ¶æ–¹æ³•ï¼ˆæ¡ˆä¾‹16-17ï¼‰

#### æ¡ˆä¾‹16ï¼šåŸºäºé™é˜¶æ¨¡å‹çš„MPCæ§åˆ¶
**ç»“åˆæ¡ˆä¾‹4-7çš„é™é˜¶æ¨¡å‹**

```python
# ä½¿ç”¨PODé™é˜¶æ¨¡å‹è¿›è¡ŒMPC
class ROM_MPC_Controller:
    def __init__(self, pod_model, horizon=10):
        self.pod = pod_model  # æ¥è‡ªæ¡ˆä¾‹4
        self.N = horizon
        self.r = pod_model.n_modes  # é™é˜¶ç»´æ•°

    def solve(self, a_current, a_target, constraints):
        """
        min  Î£ ||a[k] - a_target||Â²_Q + ||u[k]||Â²_R
        s.t. a[k+1] = Ar*a[k] + Br*u[k]
             u_min <= u[k] <= u_max
        """
        import cvxpy as cp

        # å†³ç­–å˜é‡ï¼ˆä½ç»´ï¼ï¼‰
        a = cp.Variable((self.r, self.N+1))
        u = cp.Variable((self.m, self.N))

        # ç›®æ ‡å‡½æ•°
        cost = 0
        for k in range(self.N):
            cost += cp.quad_form(a[:,k] - a_target, self.Q)
            cost += cp.quad_form(u[:,k], self.R)

        # çº¦æŸ
        constraints_list = [a[:,0] == a_current]
        for k in range(self.N):
            # é™é˜¶åŠ¨åŠ›å­¦
            constraints_list.append(
                a[:,k+1] == self.pod.Ar @ a[:,k] + self.pod.Br @ u[:,k]
            )

            # æ§åˆ¶çº¦æŸ
            constraints_list.append(u[:,k] >= constraints['u_min'])
            constraints_list.append(u[:,k] <= constraints['u_max'])

            # çŠ¶æ€çº¦æŸï¼ˆé‡æ„åˆ°ç‰©ç†ç©ºé—´ï¼‰
            h_k = self.pod.Phi @ a[:,k]  # N_xç»´
            constraints_list.append(h_k >= constraints['h_min'])
            constraints_list.append(h_k <= constraints['h_max'])

        # æ±‚è§£
        prob = cp.Problem(cp.Minimize(cost), constraints_list)
        prob.solve(solver=cp.OSQP)

        return u[:,0].value  # è¿”å›ç¬¬ä¸€æ­¥æ§åˆ¶

# å®Œæ•´é—­ç¯
pod_model = POD_Model(...)  # æ¥è‡ªæ¡ˆä¾‹4
mpc = ROM_MPC_Controller(pod_model, horizon=10)

for t in time_steps:
    # å½“å‰çŠ¶æ€ï¼ˆé™é˜¶ç©ºé—´ï¼‰
    a_current = pod_model.project(h_current)

    # MPCæ±‚è§£
    u_opt = mpc.solve(a_current, a_target, constraints)

    # åº”ç”¨æ§åˆ¶
    apply_control(u_opt)

    # ç‰©ç†ç³»ç»Ÿæ¼”åŒ–
    h_next = solve_saint_venant(h_current, u_opt)
    h_current = h_next
```

**å¯¹æ¯”å®éªŒ**:
- å…¨é˜¶MPC vs é™é˜¶MPC
- è®¡ç®—æ—¶é—´å¯¹æ¯”
- æ§åˆ¶æ€§èƒ½å¯¹æ¯”
- ä¸åŒé™é˜¶æ–¹æ³•ï¼ˆPOD vs DMD vs NNï¼‰

**éš¾åº¦**: â­â­â­â­â­
**ä»£ç é‡**: ~1100è¡Œ

---

#### æ¡ˆä¾‹17ï¼šè‡ªé€‚åº”MPC - åœ¨çº¿æ¨¡å‹æ›´æ–°
**ç»“åˆæ¡ˆä¾‹8-11çš„ç³»ç»Ÿè¾¨è¯†**

```python
class AdaptiveMPC:
    """
    è‡ªé€‚åº”MPCï¼šåœ¨çº¿æ›´æ–°æ¨¡å‹
    """
    def __init__(self, initial_model):
        self.model = initial_model
        self.mpc = MPCController(self.model)

        # åœ¨çº¿è¾¨è¯†å™¨
        self.identifier = RecursiveLeastSquares()

        # æ•°æ®ç¼“å†²
        self.buffer = collections.deque(maxlen=100)

    def control(self, x_current, x_target):
        # 1. ä½¿ç”¨å½“å‰æ¨¡å‹è®¡ç®—MPC
        u = self.mpc.solve(x_current, x_target)

        # 2. åº”ç”¨æ§åˆ¶ï¼Œè§‚æµ‹ç»“æœ
        x_next = self.system.step(u)

        # 3. æ›´æ–°æ•°æ®ç¼“å†²
        self.buffer.append((x_current, u, x_next))

        # 4. åœ¨çº¿æ›´æ–°æ¨¡å‹ï¼ˆæ¯Næ­¥ï¼‰
        if len(self.buffer) >= self.update_threshold:
            self.update_model()

        return u

    def update_model(self):
        """åœ¨çº¿æ›´æ–°æ¨¡å‹å‚æ•°"""
        X = np.array([d[0] for d in self.buffer])
        U = np.array([d[1] for d in self.buffer])
        X_next = np.array([d[2] for d in self.buffer])

        # RLSæ›´æ–°
        A_new, B_new = self.identifier.update(X, U, X_next)

        # æ›´æ–°MPCæ¨¡å‹
        self.model.A = A_new
        self.model.B = B_new
        self.mpc.update_model(self.model)
```

**å®éªŒ**:
1. å›ºå®šæ¨¡å‹MPC vs è‡ªé€‚åº”MPC
2. å‚æ•°çªå˜å“åº”
3. é•¿æœŸè¿è¡Œæ€§èƒ½
4. ä¸åŒè¾¨è¯†ç®—æ³•å¯¹æ¯”

**éš¾åº¦**: â­â­â­â­â­
**ä»£ç é‡**: ~1200è¡Œ

---

### ç¬¬ä¸ƒç« ï¼šæ™ºèƒ½æ§åˆ¶ä¸ä¼˜åŒ–ï¼ˆæ¡ˆä¾‹18-19ï¼‰

#### æ¡ˆä¾‹18ï¼šå¼ºåŒ–å­¦ä¹  - å¤šé—¸é—¨ååŒè°ƒåº¦
ï¼ˆä»ä¹‹å‰æ¡ˆä¾‹ç§»åŠ¨ï¼Œå¢åŠ ä¸æ•°å­—å­ªç”Ÿçš„ç»“åˆï¼‰

#### æ¡ˆä¾‹19ï¼šç»¼åˆæ€§èƒ½å¯¹æ¯”
ï¼ˆæ‰€æœ‰æ–¹æ³•çš„å¯¹æ¯”ï¼‰

---

### ç¬¬å…«ç« ï¼šç»¼åˆåº”ç”¨ï¼ˆæ¡ˆä¾‹20ï¼‰

#### æ¡ˆä¾‹20ï¼šå—æ°´åŒ—è°ƒå·¥ç¨‹ - å®Œæ•´æ•°å­—å­ªç”Ÿç³»ç»Ÿ
**é›†æˆæ‰€æœ‰æŠ€æœ¯**:
- é™é˜¶æ¨¡å‹ï¼ˆåŠ é€Ÿè®¡ç®—ï¼‰
- ç³»ç»Ÿè¾¨è¯†ï¼ˆå‚æ•°æ ¡å‡†ï¼‰
- æ•°å­—å­ªç”Ÿï¼ˆè™šå®æ˜ å°„ï¼‰
- é¢„æµ‹æ€§ç»´æŠ¤ï¼ˆè®¾å¤‡ç®¡ç†ï¼‰
- å¤šå±‚æ§åˆ¶ï¼ˆä¼˜åŒ–è°ƒåº¦ï¼‰

---

## ğŸ› ï¸ æŠ€æœ¯å®ç°æ€»ç»“

### æ–°å¢çš„æ ¸å¿ƒå·¥å…·åº“

```python
# æ¨¡å‹é™é˜¶
books/canal_pipeline_control/code/rom/
â”œâ”€â”€ pod.py              # PODé™é˜¶
â”œâ”€â”€ dmd.py              # åŠ¨æ€æ¨¡æ€åˆ†è§£
â”œâ”€â”€ galerkin.py         # GalerkinæŠ•å½±
â””â”€â”€ neural_rom.py       # ç¥ç»ç½‘ç»œé™é˜¶

# ç³»ç»Ÿè¾¨è¯†
books/canal_pipeline_control/code/identification/
â”œâ”€â”€ n4sid.py            # å­ç©ºé—´è¾¨è¯†
â”œâ”€â”€ frequency.py        # é¢‘åŸŸè¾¨è¯†
â”œâ”€â”€ hammerstein.py      # éçº¿æ€§è¾¨è¯†
â””â”€â”€ sindy.py            # ç¨€ç–è¾¨è¯†

# æ•°å­—å­ªç”Ÿ
books/canal_pipeline_control/code/digital_twin/
â”œâ”€â”€ twin_core.py        # å­ªç”Ÿæ ¸å¿ƒ
â”œâ”€â”€ state_estimation.py # çŠ¶æ€ä¼°è®¡
â”œâ”€â”€ virtual_sensor.py   # è™šæ‹Ÿä¼ æ„Ÿ
â””â”€â”€ predictive_maintenance.py  # é¢„æµ‹ç»´æŠ¤
```

---

## ğŸ“… æ›´æ–°åçš„å¼€å‘è®¡åˆ’

### é˜¶æ®µ1ï¼šåŸºç¡€ï¼ˆ1å‘¨ï¼‰
- æ¡ˆä¾‹1-3ï¼šåˆ†å¸ƒå¼PID

### é˜¶æ®µ2ï¼šæ¨¡å‹é™é˜¶ï¼ˆ3å‘¨ï¼‰â­ é‡ç‚¹
- æ¡ˆä¾‹4ï¼šPOD
- æ¡ˆä¾‹5ï¼šDMD
- æ¡ˆä¾‹6ï¼šGalerkin
- æ¡ˆä¾‹7ï¼šNN-ROM

### é˜¶æ®µ3ï¼šç³»ç»Ÿè¾¨è¯†ï¼ˆ3å‘¨ï¼‰â­ é‡ç‚¹
- æ¡ˆä¾‹8ï¼šN4SID
- æ¡ˆä¾‹9ï¼šé¢‘åŸŸè¾¨è¯†
- æ¡ˆä¾‹10ï¼šéçº¿æ€§è¾¨è¯†
- æ¡ˆä¾‹11ï¼šSINDy

### é˜¶æ®µ4ï¼šæ•°å­—å­ªç”Ÿï¼ˆ2å‘¨ï¼‰â­ é‡ç‚¹
- æ¡ˆä¾‹12ï¼šå­ªç”Ÿæ¶æ„
- æ¡ˆä¾‹13ï¼šé¢„æµ‹ç»´æŠ¤

### é˜¶æ®µ5ï¼šç®¡é“æ§åˆ¶ï¼ˆ2å‘¨ï¼‰
- æ¡ˆä¾‹14-15

### é˜¶æ®µ6ï¼šå…ˆè¿›æ§åˆ¶ï¼ˆ2å‘¨ï¼‰
- æ¡ˆä¾‹16-17

### é˜¶æ®µ7ï¼šæ™ºèƒ½æ§åˆ¶ï¼ˆ2å‘¨ï¼‰
- æ¡ˆä¾‹18-19

### é˜¶æ®µ8ï¼šç»¼åˆåº”ç”¨ï¼ˆ3å‘¨ï¼‰
- æ¡ˆä¾‹20ï¼šå—æ°´åŒ—è°ƒ

**æ€»è®¡**: çº¦18å‘¨ï¼ˆä¿æŒä¸å˜ï¼‰

---

## ğŸ“– æ–°å¢å‚è€ƒæ–‡çŒ®

### æ¨¡å‹é™é˜¶
1. *Model Reduction and Approximation* - Benner et al.
2. *Reduced Order Methods for Modeling and Computational Reduction* - Quarteroni & Rozza
3. *Dynamic Mode Decomposition* - Kutz et al.

### ç³»ç»Ÿè¾¨è¯†
4. *System Identification* - Ljung
5. *Subspace Methods for System Identification* - Katayama
6. *Nonlinear System Identification* - Nelles

### æ•°å­—å­ªç”Ÿ
7. *Digital Twin: Enabling Technologies, Challenges and Open Research* - IEEE
8. *Digital Twins for Smart Cities* - IBMç™½çš®ä¹¦
9. *Predictive Maintenance 4.0* - Siemensç ”ç©¶æŠ¥å‘Š

---

## âœ… v3.0ç‰ˆæœ¬æ›´æ–°æ€»ç»“

### æ–°å¢å†…å®¹

1. **æ¨¡å‹é™é˜¶æ–¹æ³•**ï¼ˆ4ä¸ªæ¡ˆä¾‹ï¼‰
   - POD/SVDé™é˜¶
   - åŠ¨æ€æ¨¡æ€åˆ†è§£ï¼ˆDMDï¼‰
   - GalerkinæŠ•å½±
   - ç¥ç»ç½‘ç»œé™é˜¶

2. **ç³»ç»Ÿè¾¨è¯†æ–¹æ³•**ï¼ˆ4ä¸ªæ¡ˆä¾‹ï¼‰
   - å­ç©ºé—´è¾¨è¯†ï¼ˆN4SIDï¼‰
   - é¢‘åŸŸè¾¨è¯†
   - éçº¿æ€§è¾¨è¯†ï¼ˆHammerstein-Wienerï¼‰
   - æ•°æ®é©±åŠ¨è¾¨è¯†ï¼ˆSINDyï¼‰

3. **æ•°å­—å­ªç”ŸæŠ€æœ¯**ï¼ˆ2ä¸ªæ¡ˆä¾‹ï¼‰
   - å®Œæ•´å­ªç”Ÿæ¶æ„
   - é¢„æµ‹æ€§ç»´æŠ¤åº”ç”¨

### ä»·å€¼æå‡

- **ç†è®ºå®Œæ•´æ€§**: ä»ç‰©ç†å»ºæ¨¡ â†’ é™é˜¶ â†’ è¾¨è¯† â†’ æ§åˆ¶ â†’ å­ªç”Ÿï¼Œå½¢æˆå®Œæ•´é—­ç¯
- **å·¥ç¨‹å®ç”¨æ€§**: æ‰€æœ‰æ–¹æ³•éƒ½æ˜¯å®é™…å·¥ç¨‹å¿…éœ€çš„
- **å‰æ²¿æ€§**: æ¶µç›–æœ€æ–°çš„æ•°å­—å­ªç”Ÿã€SINDyç­‰å‰æ²¿æŠ€æœ¯
- **æ•™å­¦ä»·å€¼**: æ¯ä¸ªæ–¹æ³•éƒ½æœ‰è¯¦ç»†çš„ç†è®ºæ¨å¯¼å’Œä»£ç å®ç°

---

**æçº²å®Œæˆæ—¥æœŸ**: 2025-10-30
**ç‰ˆæœ¬**: v3.0-complete
**çŠ¶æ€**: ğŸ“ å¾…å®¡é˜…
