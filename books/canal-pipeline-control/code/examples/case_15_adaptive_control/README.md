# 案例15：自适应控制（Model Reference Adaptive Control, MRAC）

## 1. 案例简介

本案例演示**模型参考自适应控制（MRAC）**在运河系统中的应用。自适应控制是一种能够在线调整控制器参数以适应系统不确定性和时变特性的控制方法。MRAC通过定义一个理想的参考模型，使实际系统的输出跟踪参考模型的输出，同时自适应律在线调整控制器参数。

### 应用场景

在运河-管道系统中，自适应控制适用于以下场景：

1. **参数不确定性**：渠道糙率、渗漏系数等参数随季节变化
2. **结构时变**：设备老化、淤积导致系统特性缓慢变化
3. **工况变化**：不同流量区间下系统动态特性差异
4. **未建模动态**：简化模型无法完全描述真实系统

### 关键优势

- ✅ **在线学习**：无需精确数学模型，通过实时数据调整参数
- ✅ **鲁棒性强**：能适应系统参数的缓慢变化
- ✅ **理论保证**：基于Lyapunov稳定性理论，有严格的收敛证明
- ✅ **工程实用**：算法简单，计算量小，易于实现

---

## 2. 理论基础

### 2.1 MRAC基本思想

MRAC的核心思想是：
1. 设计一个**参考模型**，描述期望的系统行为
2. 实际被控系统尝试跟踪参考模型的输出
3. **自适应律**根据跟踪误差在线调整控制器参数

```json
       r(t) ───→ [参考模型] ───→ y_m(t)
                                      │
                                      ↓ (误差 e = y - y_m)
       u(t)                           │
         ↑                            │
         │                            │
    [自适应控制器] ←─────────────────┘
    (参数 θ(t))
         ↑
         │
    [被控系统] ───→ y(t)
```

### 2.2 数学描述

#### 被控系统（实际系统）

假设被控对象为SISO线性系统：

```python
y(s) = K_p * G_p(s) * u(s)
```

其中：
- `K_p` 是未知的系统增益
- `G_p(s)` 是已知的传递函数（相对阶≤2）
- `u(t)` 是控制输入
- `y(t)` 是系统输出

#### 参考模型

参考模型描述期望的动态响应：

```python
y_m(s) = K_m * G_m(s) * r(s)
```

其中：
- `K_m` 是参考模型增益
- `G_m(s)` 是稳定的参考传递函数
- `r(t)` 是参考输入
- `y_m(t)` 是参考模型输出

通常选择G_m(s)为标准二阶系统：

```python
G_m(s) = ω_n² / (s² + 2ζω_n·s + ω_n²)
```

- `ω_n`：自然频率（决定响应速度）
- `ζ`：阻尼比（决定超调量，通常取0.7~1.0）

#### 控制律

MRAC控制律包含三个反馈项：

```python
u(t) = θ_r(t)·r(t) - θ_y(t)·y(t) - θ_u(t)·u(t)
```

其中：
- `θ_r(t)`：前馈增益（跟踪参考输入）
- `θ_y(t)`：输出反馈增益（修正输出误差）
- `θ_u(t)`：控制反馈增益（阻尼振荡）

### 2.3 自适应律

自适应律决定如何根据误差更新参数。有两种主要方法：

#### (1) MIT规则（梯度法）

MIT规则是最简单的自适应律，基于梯度下降：

```python
定义跟踪误差：e(t) = y(t) - y_m(t)

目标：最小化 J = ½e²(t)

参数更新：
dθ_r/dt = -γ_r · (∂e/∂θ_r) · e = -γ_r · r · e
dθ_y/dt = -γ_y · (∂e/∂θ_y) · e = γ_y · y · e
dθ_u/dt = -γ_u · (∂e/∂θ_u) · e = γ_u · u · e
```

其中：
- `γ_r, γ_y, γ_u > 0` 是自适应增益（学习率）
- 更大的γ导致更快的适应，但可能引起振荡
- MIT规则简单但缺乏稳定性保证

#### (2) Lyapunov设计（直接法）

基于Lyapunov稳定性理论，保证闭环系统稳定：

```python
定义参数误差：
φ_r = θ_r - θ_r*
φ_y = θ_y - θ_y*
φ_u = θ_u - θ_u*

其中 θ* 是理想参数（使 e ≡ 0）

构造Lyapunov函数：
V = ½e² + ½(φ_r²/γ_r + φ_y²/γ_y + φ_u²/γ_u)

要求 dV/dt ≤ 0，推导出自适应律：
dθ_r/dt = -γ_r · r · e · sgn(K_p)
dθ_y/dt = γ_y · y · e · sgn(K_p)
dθ_u/dt = γ_u · u · e · sgn(K_p)
```

注意：
- 需要知道系统增益K_p的**符号**（正或负）
- 保证 `dV/dt = -e²·sgn²(K_p) ≤ 0`
- 系统全局稳定，但参数收敛需要**持续激励条件**

### 2.4 持续激励（Persistent Excitation, PE）

参数收敛到真值需要满足PE条件：

```python
参考输入 r(t) 必须"充分丰富"，数学上：

∃ α > 0, T > 0, ∀t：
∫[t, t+T] r²(τ) dτ ≥ α
```

实际意义：
- 阶跃输入不满足PE → 参数不收敛（但e→0）
- 正弦输入满足PE → 参数收敛到真值
- 多频率组合最好（如chirp信号、PRBS）

### 2.5 稳定性分析

**Lyapunov直接法的稳定性结论：**

1. **全局稳定**：所有信号有界（e, θ, u, y ∈ L∞）
2. **渐近收敛**：e(t) → 0 as t → ∞
3. **参数收敛**：如果满足PE条件，则 φ(t) → 0

**MIT规则的局限：**
- 仅局部稳定（小初始误差和慢时变）
- 高增益γ可能导致振荡或不稳定
- 需要通过仿真调试γ的值

---

## 3. 运河系统的MRAC设计

### 3.1 运河段简化模型

考虑单个运河段的水位动态（线性化模型）：

```json
状态空间形式：
dx/dt = A·x + B·u
y = C·x

其中：
x = [h, Q]ᵀ  （水位，流量）
u = Q_in     （入流量）
y = h        （测量的水位）

A = [[-v/L,        1/L],
     [-g·A_c·S_0,  -g·n²·|Q_0|/(A_c·R_h^(4/3))]]

B = [0, 1/A_c]ᵀ

C = [1, 0]
```

参数说明：
- `L`：渠段长度
- `v`：流速
- `g`：重力加速度
- `A_c`：过水断面积
- `S_0`：底坡
- `n`：糙率（可能未知或时变）
- `R_h`：水力半径

### 3.2 不确定性来源

运河系统的参数不确定性：

1. **糙率n**：受植物生长、淤积影响，季节性变化±30%
2. **渗漏**：改变有效流量，相当于B矩阵不确定
3. **几何变化**：淤积/冲刷改变A_c和R_h
4. **工况变化**：不同流量区间的动态特性差异

### 3.3 MRAC设计步骤

#### Step 1: 选择参考模型

选择标准二阶系统作为参考模型：

```python
G_m(s) = ω_n² / (s² + 2ζω_n·s + ω_n²)

参数选择：
- ω_n = 0.1 rad/s  （响应时间约30秒）
- ζ = 0.8          （轻微超调，快速稳定）
```

#### Step 2: 设计控制律

```python
u(t) = θ_r(t)·r(t) - θ_y(t)·y(t) - θ_u(t)·u(t)
```

初始参数可根据名义模型设计（极点配置）：
```python
θ_r(0) = K_m / K_p_nominal
θ_y(0) = (2ζω_n - a_11) / b_1
θ_u(0) = 0
```

#### Step 3: 选择自适应律

推荐使用**Lyapunov直接法**（更可靠）：

```python
dθ_r/dt = -γ_r · r · e · sgn(K_p)  （γ_r = 0.01）
dθ_y/dt = γ_y · y · e · sgn(K_p)   （γ_y = 0.02）
dθ_u/dt = γ_u · u · e · sgn(K_p)   （γ_u = 0.01）
```

注意：
- 运河系统K_p > 0（入流增加→水位上升）
- 自适应增益γ需要试凑，通常从小值开始

#### Step 4: 加入鲁棒修正（可选）

实际应用中常加入以下修正：

**1) 参数投影（Parameter Projection）**
防止参数漂移到不合理范围：
```python
θ_min ≤ θ(t) ≤ θ_max
```

**2) σ修正（σ-modification）**
防止高频未建模动态激励：
```python
dθ/dt = -γ·∂e/∂θ·e - σ·θ
```
其中σ是小的正常数（如0.001）

**3) 死区（Dead Zone）**
忽略小误差（测量噪声）：
```python
如果 |e| < ε，则 dθ/dt = 0
```

---

## 4. 工程实现要点

### 4.1 数值积分方法

自适应律是微分方程，需要数值积分：

```python
# 欧拉法（简单但精度低）
theta_next = theta + dt * (-gamma * signal * error)

# 推荐：四阶龙格-库塔法（RK4）
k1 = -gamma * signal * error
k2 = -gamma * signal * (error + 0.5*dt*k1)
k3 = -gamma * signal * (error + 0.5*dt*k2)
k4 = -gamma * signal * (error + dt*k3)
theta_next = theta + (dt/6) * (k1 + 2*k2 + 2*k3 + k4)
```python

### 4.2 参数初始化

好的初始值能加速收敛：

1. **基于名义模型**：如果有粗略模型，用极点配置计算初值
2. **基于经验**：根据历史运行数据统计
3. **保守策略**：从小值开始（如θ_y=0.1），避免初期大幅振荡

### 4.3 自适应增益选择

增益γ的选择是工程关键：

| 增益大小 | 优点 | 缺点 |
|---------|------|------|
| 大（γ > 0.1） | 快速适应 | 易振荡，对噪声敏感 |
| 小（γ < 0.01） | 平稳，鲁棒 | 适应慢，瞬态长 |

**调试策略**：
1. 从小值开始（γ = 0.001）
2. 观察e(t)的收敛速度和θ(t)的变化
3. 逐步增大γ直到出现轻微振荡
4. 回退到振荡前的值

### 4.4 实时实现考虑

```python
class MRACController:
    def __init__(self, Am, Bm, Cm, gamma_r, gamma_y, gamma_u):
        self.Am = Am
        self.Bm = Bm
        self.Cm = Cm

        # 自适应参数
        self.theta_r = 1.0
        self.theta_y = 0.1
        self.theta_u = 0.0

        # 自适应增益
        self.gamma_r = gamma_r
        self.gamma_y = gamma_y
        self.gamma_u = gamma_u

        # 参考模型状态
        self.x_m = np.zeros((Am.shape[0],))

        # 参数约束
        self.theta_min = [0.0, 0.0, -1.0]
        self.theta_max = [10.0, 5.0, 1.0]

    def update(self, y, r, u_prev, dt):
        """单步更新（实时控制循环）"""
        # 1. 更新参考模型
        self.x_m += dt * (self.Am @ self.x_m + self.Bm * r)
        y_m = self.Cm @ self.x_m

        # 2. 计算跟踪误差
        e = y - y_m

        # 3. 更新自适应参数（Lyapunov方法）
        self.theta_r += dt * (-self.gamma_r * r * e)
        self.theta_y += dt * (self.gamma_y * y * e)
        self.theta_u += dt * (self.gamma_u * u_prev * e)

        # 4. 参数投影（防止漂移）
        self.theta_r = np.clip(self.theta_r,
                                self.theta_min[0],
                                self.theta_max[0])
        self.theta_y = np.clip(self.theta_y,
                                self.theta_min[1],
                                self.theta_max[1])
        self.theta_u = np.clip(self.theta_u,
                                self.theta_min[2],
                                self.theta_max[2])

        # 5. 计算控制输入
        u = self.theta_r * r - self.theta_y * y - self.theta_u * u_prev

        # 6. 控制饱和（物理约束）
        u = np.clip(u, 0, 50)  # 流量范围 [0, 50] m³/s

        return u, e, y_m
```python

---

## 5. 性能评估指标

### 5.1 跟踪性能

```python
# 积分绝对误差
IAE = ∫|e(t)| dt

# 积分平方误差
ISE = ∫e²(t) dt

# 稳态误差
e_ss = lim[t→∞] e(t)
```python

### 5.2 适应性能

```python
# 参数收敛速度（时间常数）
τ_adapt = 到达真值95%的时间

# 参数稳定性
σ_θ = std(θ[t_stable:]) / mean(θ[t_stable:])
```python

### 5.3 控制代价

```python
# 控制能量
E_u = ∫u²(t) dt

# 控制变化率（平滑性）
E_du = ∫(du/dt)² dt
```

---

## 6. 本案例演示内容

本案例包含4个演示部分：

### Part 1: MRAC基础 - 标量系统
- 一阶系统：dy/dt = -a·y + b·u（a, b未知）
- MIT规则和Lyapunov方法对比
- 参数收敛过程可视化

### Part 2: 运河系统MRAC - 参数不确定性
- 简化运河模型（糙率n未知或时变）
- 水位跟踪控制
- 参数在线辨识效果

### Part 3: MRAC鲁棒性测试 - 扰动和噪声
- 外部扰动（侧向入流变化）
- 测量噪声影响
- 鲁棒修正效果（σ修正、死区）

### Part 4: 持续激励条件验证
- 不同参考输入对比（阶跃、正弦、chirp）
- 参数收敛条件验证
- PE条件的重要性

---

## 7. 与其他控制方法对比

| 控制方法 | 模型需求 | 适应能力 | 计算复杂度 | 稳定性保证 |
|---------|---------|---------|-----------|-----------|
| PID | 无需模型 | 无 | 极低 | 经验调试 |
| LQR | 精确模型 | 无 | 中 | 强（线性系统） |
| MPC | 精确模型 | 弱 | 高 | 强（有约束） |
| **MRAC** | 部分模型 | **强** | 低 | 强（Lyapunov） |
| 鲁棒控制（H∞） | 不确定性界 | 无 | 高 | 强 |

MRAC的**独特优势**：
- 无需精确参数（仅需结构信息）
- 在线学习，自动适应变化
- 理论完备，稳定性有保证
- 计算量小，易于实时实现

---

## 8. 工程应用建议

### 8.1 何时使用MRAC？

✅ **适合场景**：
- 系统参数缓慢时变（如季节变化、老化）
- 模型结构已知但参数不确定
- 需要长期无人值守运行
- 对控制性能要求不极端严苛

❌ **不适合场景**：
- 快速时变系统（切换、故障）
- 完全未知的系统结构
- 强非线性系统（需要非线性自适应）
- 对暂态性能要求极高（初期有学习过程）

### 8.2 实际部署checklist

- [ ] **参考模型设计**：ω_n和ζ根据实际需求选择
- [ ] **增益调试**：仿真中确定γ范围，现场微调
- [ ] **参数约束**：设置θ的物理合理范围
- [ ] **初值设置**：基于名义模型或经验值
- [ ] **鲁棒修正**：加入σ修正或死区（对抗噪声）
- [ ] **监控机制**：记录e(t)和θ(t)，检测异常
- [ ] **切换策略**：如果e长期过大，切换到备用控制器

### 8.3 常见问题排查

| 问题现象 | 可能原因 | 解决方案 |
|---------|---------|---------|
| 持续振荡 | γ过大 | 减小自适应增益 |
| 收敛极慢 | γ过小 | 适当增大γ |
| 参数漂移 | 无PE或有bias | 加参数投影和σ修正 |
| 初期超调大 | 初值偏差大 | 改善初值估计 |
| 对噪声敏感 | 无滤波/死区 | 加测量滤波或误差死区 |

---

## 9. 扩展阅读

### 经典教材
1. Åström, K. J., & Wittenmark, B. (1995). *Adaptive Control* (2nd ed.). Addison-Wesley.
2. Ioannou, P. A., & Sun, J. (1996). *Robust Adaptive Control*. Prentice Hall.
3. Narendra, K. S., & Annaswamy, A. M. (2005). *Stable Adaptive Systems*. Dover.

### 运河控制应用
4. Litrico, X., & Fromion, V. (2009). *Modeling and Control of Hydrosystems*. Springer.
5. Malaterre, P. O. (1998). PILOTE: Linear quadratic optimal controller for irrigation canals. *ASCE Journal of Irrigation and Drainage Engineering*.

### 前沿方向
- L1自适应控制（快速适应 + 鲁棒性）
- 非线性MRAC（backstepping, dynamic inversion）
- 数据驱动自适应（与强化学习结合）

---

## 10. 总结

### 核心要点

1. **MRAC解决什么问题**：参数不确定的系统控制
2. **如何工作**：参考模型 + 自适应律 + Lyapunov稳定性
3. **关键设计**：参考模型、控制律、自适应律、增益选择
4. **工程实现**：参数投影、鲁棒修正、噪声处理

### 学习目标

通过本案例，你将掌握：
- ✅ MRAC的基本原理和数学推导
- ✅ MIT规则和Lyapunov方法的区别
- ✅ 持续激励条件的重要性
- ✅ 运河系统的MRAC设计和参数调试
- ✅ 实际工程中的鲁棒性增强技术

### 实际意义

在运河-管道系统中，MRAC能够：
- 🎯 应对季节性参数变化（糙率、渗漏）
- 🎯 减少建模工作量（只需结构，不需精确参数）
- 🎯 提高长期运行可靠性（自动适应老化）
- 🎯 降低维护成本（无需频繁重新整定参数）

---

**下一步**：运行 `main.py` 查看MRAC的实际效果！
