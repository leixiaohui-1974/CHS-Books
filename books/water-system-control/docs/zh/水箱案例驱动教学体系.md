# 水系统控制论案例驱动教学体系
## 以12个经典水箱案例为主线的理论与实践

**制定日期：** 2025-10-28  
**教学理念：** 案例驱动学习（Case-Based Learning）  
**核心原则：** 从问题出发，在解决问题中学习理论

---

## 📚 教学设计理念

### 案例驱动教学的优势

1. **情境化学习**：在真实工程情境中理解抽象概念
2. **问题导向**：带着问题学习理论，增强学习动机
3. **渐进式难度**：从简单到复杂，符合认知规律
4. **知识迁移**：通过系列案例培养举一反三能力
5. **工程思维**：培养分析问题、建模、验证、优化的完整思维链

### 案例设计原则

- **真实性**：案例源自真实工程问题
- **递进性**：每个案例在前一个基础上增加新的复杂度
- **完整性**：每个案例覆盖"问题→建模→仿真→辨识→控制→验证"全流程
- **可操作性**：配套完整代码和硬件实验指导
- **理论深度**：每个案例对应2-3个核心理论知识点

---

## 🎯 12个经典水箱案例系统

### 【案例1】家庭水塔自动供水系统 ⭐
**难度等级：** 入门  
**工程背景：** 农村家庭水塔水位自动控制

#### 问题描述
某农村家庭安装了屋顶水塔，需要自动控制水泵，当水位低于2米时启动水泵，高于2.5米时停止，要求避免频繁启停。

#### 涉及理论
- **建模**：一阶系统传递函数 G(s) = K/(τs+1)
- **控制**：开关控制（On-Off Control）+ 滞环（Hysteresis）
- **分析**：时间常数的物理意义、稳态误差

#### 学习目标
1. 理解水箱的质量守恒方程：dV/dt = Q_in - Q_out
2. 掌握线性化方法：在平衡点附近泰勒展开
3. 推导传递函数：从微分方程到拉普拉斯变换
4. 理解开关控制的优缺点

#### 实验内容
- **仿真实验1.1**：绘制不同时间常数下的阶跃响应曲线
- **仿真实验1.2**：对比不同滞环宽度对启停次数的影响
- **硬件实验1.3**：搭建单水箱Arduino控制系统

#### 代码结构
```python
# case_01_home_water_tower/
├── modeling.py              # 单水箱建模
├── on_off_control.py        # 开关控制器
├── simulation.py            # 仿真主程序
├── notebook_01.ipynb        # 交互式教学笔记本
└── arduino_code/            # 硬件实验代码
    └── on_off_controller.ino
```

#### 典型结果展示
- 水位-时间曲线
- 泵启停序列
- 能耗分析

---

### 【案例2】工业冷却塔精确水位控制 ⭐⭐
**难度等级：** 基础  
**工程背景：** 化工厂冷却塔水位需要精确维持在3.0±0.1米

#### 问题描述
工业冷却塔要求水位精确控制，开关控制导致水位波动过大，需要设计比例控制器，要求超调量<5%，调节时间<30秒。

#### 涉及理论
- **控制**：比例控制（P控制）、稳态误差分析
- **性能指标**：超调量、上升时间、调节时间、稳态误差
- **分析**：根轨迹法初步介绍

#### 学习目标
1. 理解比例控制原理：u(t) = K_p * e(t)
2. 掌握性能指标的计算和测量方法
3. 分析比例增益对系统性能的影响
4. 理解稳态误差产生的原因

#### 实验内容
- **仿真实验2.1**：不同K_p下的阶跃响应对比
- **仿真实验2.2**：性能指标自动计算程序
- **仿真实验2.3**：根轨迹法分析闭环极点位置
- **硬件实验2.4**：PWM调速水泵的比例控制

#### 关键代码示例
```python
class ProportionalController:
    def __init__(self, Kp, setpoint):
        self.Kp = Kp
        self.setpoint = setpoint
    
    def compute(self, measurement):
        error = self.setpoint - measurement
        output = self.Kp * error
        return np.clip(output, 0, 100)  # 限制在0-100%

# 性能指标计算
def calculate_performance_metrics(t, y, setpoint):
    """计算超调量、上升时间、调节时间、稳态误差"""
    # 超调量
    overshoot = (max(y) - setpoint) / setpoint * 100
    
    # 上升时间（10%-90%）
    idx_10 = np.where(y >= 0.1 * setpoint)[0][0]
    idx_90 = np.where(y >= 0.9 * setpoint)[0][0]
    rise_time = t[idx_90] - t[idx_10]
    
    # 调节时间（2%误差带）
    settling_band = 0.02 * setpoint
    settled_idx = np.where(np.abs(y - setpoint) <= settling_band)[0]
    if len(settled_idx) > 0:
        settling_time = t[settled_idx[0]]
    else:
        settling_time = np.inf
    
    # 稳态误差
    steady_state_error = abs(y[-1] - setpoint)
    
    return {
        'overshoot': overshoot,
        'rise_time': rise_time,
        'settling_time': settling_time,
        'steady_state_error': steady_state_error
    }
```

---

### 【案例3】城市供水泵站无静差控制 ⭐⭐
**难度等级：** 基础-中级  
**工程背景：** 城市供水二级泵站要求水位无静差

#### 问题描述
供水泵站发现比例控制存在稳态误差（设定3.0米，实际稳定在2.85米），影响供水压力。需要引入积分作用消除稳态误差，但要避免积分饱和。

#### 涉及理论
- **控制**：PI控制、积分饱和与抗饱和技术
- **分析**：稳态误差定理、I型/II型系统
- **频域**：伯德图初步介绍

#### 学习目标
1. 理解积分作用消除稳态误差的原理
2. 掌握PI控制器设计：u(t) = K_p*e(t) + K_i*∫e(t)dt
3. 学习抗积分饱和策略（条件积分、积分分离）
4. 初步接触伯德图分析稳定裕度

#### 实验内容
- **仿真实验3.1**：对比P控制和PI控制的稳态误差
- **仿真实验3.2**：积分饱和现象演示
- **仿真实验3.3**：不同抗饱和策略的效果对比
- **仿真实验3.4**：伯德图绘制与增益/相位裕度分析
- **硬件实验3.5**：PI控制器的实际调试

#### 抗积分饱和代码示例
```python
class PIControllerWithAntiWindup:
    def __init__(self, Kp, Ki, dt, output_limits=(-100, 100)):
        self.Kp = Kp
        self.Ki = Ki
        self.dt = dt
        self.output_limits = output_limits
        self.integral = 0
        
    def compute(self, error):
        # 比例项
        P = self.Kp * error
        
        # 积分项（先计算）
        self.integral += error * self.dt
        I = self.Ki * self.integral
        
        # 总输出（未限幅）
        output_raw = P + I
        
        # 限幅输出
        output = np.clip(output_raw, *self.output_limits)
        
        # 抗饱和：如果输出饱和，回退积分项
        if output != output_raw:
            # 反向计算允许的积分值
            allowed_I = output - P
            self.integral = allowed_I / self.Ki if self.Ki != 0 else 0
        
        return output
```

---

### 【案例4】双水箱串联系统的动态响应 ⭐⭐⭐
**难度等级：** 中级  
**工程背景：** 污水处理厂的两级沉淀池水位控制

#### 问题描述
污水处理厂有两个串联的沉淀池，上游池通过阀门向下游池放水。发现控制下游池水位时，响应明显比单池慢，且有振荡。需要分析二阶系统特性。

#### 涉及理论
- **建模**：多水箱耦合系统建模、二阶系统传递函数
- **分析**：阻尼比ζ、自然频率ω_n、极点位置与动态响应的关系
- **控制**：PID控制器完整设计、Ziegler-Nichols整定法

#### 学习目标
1. 推导双水箱串联系统的传递函数 G(s) = K/(s²+2ζω_n·s+ω_n²)
2. 理解阻尼比对响应特性的影响（欠阻尼/临界阻尼/过阻尼）
3. 掌握PID三项作用的协调配合
4. 学习经典的Ziegler-Nichols整定法

#### 实验内容
- **仿真实验4.1**：双水箱系统建模与验证
- **仿真实验4.2**：不同阻尼比下的阶跃响应（ζ=0.3, 0.7, 1.0, 1.5）
- **仿真实验4.3**：微分作用对振荡的抑制效果
- **仿真实验4.4**：Ziegler-Nichols临界增益法整定
- **仿真实验4.5**：PID三项作用的可视化解析
- **硬件实验4.6**：双水箱物理装置实验

#### 双水箱建模代码
```python
class DoubleTankCascade:
    """双水箱串联系统"""
    
    def __init__(self, A1=0.5, A2=0.5, R1=2.0, R2=2.0, K=1.0):
        """
        A1, A2: 上下水箱横截面积 [m²]
        R1: 上水箱出口阻力 [s/m²]
        R2: 下水箱出口阻力 [s/m²]
        K: 泵增益 [m³/s/V]
        """
        self.A1 = A1
        self.A2 = A2
        self.R1 = R1
        self.R2 = R2
        self.K = K
        
        # 时间常数
        self.tau1 = A1 * R1
        self.tau2 = A2 * R2
        
    def get_transfer_function(self):
        """
        传递函数（h2相对于u）：
        G(s) = (K*R1*R2) / [(τ1·s+1)(τ2·s+1)]
              = K_static / (τ1·τ2·s² + (τ1+τ2)·s + 1)
        """
        num = [self.K * self.R1 * self.R2]
        den = [self.tau1 * self.tau2, self.tau1 + self.tau2, 1]
        return control.TransferFunction(num, den)
    
    def get_natural_freq_damping(self):
        """计算等效的自然频率和阻尼比"""
        omega_n = 1 / np.sqrt(self.tau1 * self.tau2)
        zeta = (self.tau1 + self.tau2) / (2 * np.sqrt(self.tau1 * self.tau2))
        return omega_n, zeta
    
    def state_space_model(self):
        """状态空间表示
        状态变量: x1=h1 (上水箱水位), x2=h2 (下水箱水位)
        """
        A = np.array([
            [-1/self.tau1, 0],
            [self.R1/self.A2, -1/self.tau2]
        ])
        B = np.array([[self.K/self.A1], [0]])
        C = np.array([[0, 1]])  # 只测量下水箱水位
        D = np.array([[0]])
        
        return A, B, C, D
```

#### Ziegler-Nichols整定法实现
```python
def ziegler_nichols_tuning(plant, method='ultimate_gain'):
    """Ziegler-Nichols PID整定
    
    Args:
        plant: 被控对象传递函数
        method: 'ultimate_gain' (临界增益法) 或 'reaction_curve' (反应曲线法)
    
    Returns:
        Kp, Ki, Kd: PID参数
    """
    if method == 'ultimate_gain':
        # 1. 找到临界增益Ku（系统开始持续振荡的增益）
        # 通过二分法搜索
        Ku = find_ultimate_gain(plant)
        
        # 2. 测量临界周期Tu
        Tu = find_oscillation_period(plant, Ku)
        
        # 3. 根据ZN经验公式计算PID参数
        Kp = 0.6 * Ku
        Ki = Kp / (0.5 * Tu)
        Kd = Kp * (0.125 * Tu)
        
        return Kp, Ki, Kd
    
    elif method == 'reaction_curve':
        # 反应曲线法（适用于无积分环节的系统）
        # 施加阶跃输入，测量响应曲线
        t, y = control.step_response(plant)
        
        # 找到拐点切线
        L, T = find_tangent_parameters(t, y)  # L=延迟时间，T=时间常数
        K = y[-1]  # 静态增益
        
        # ZN公式
        Kp = 1.2 * T / (K * L)
        Ki = Kp / (2 * L)
        Kd = Kp * 0.5 * L
        
        return Kp, Ki, Kd
```

---

### 【案例5】多水箱网络的状态空间建模 ⭐⭐⭐
**难度等级：** 中级  
**工程背景：** 水处理厂多级处理池的协同控制

#### 问题描述
某水厂有4个相互连接的处理池（2个串联，2个并联），需要同时控制多个水位。传递函数方法变得复杂，引入状态空间方法。

#### 涉及理论
- **建模**：MIMO系统的状态空间建模、状态变量选择
- **分析**：可控性（Controllability）、可观测性（Observability）
- **线性代数**：特征值、特征向量、模态分解
- **仿真**：状态空间模型的数值求解

#### 学习目标
1. 理解状态空间表示：dx/dt = Ax + Bu, y = Cx + D
2. 掌握可控性矩阵和可观测性矩阵的计算
3. 理解状态变量的物理意义
4. 学习矩阵指数e^(At)的计算

#### 实验内容
- **仿真实验5.1**：4水箱系统的状态空间建模
- **仿真实验5.2**：可控性和可观测性判别
- **仿真实验5.3**：模态分析与主导极点
- **仿真实验5.4**：状态空间与传递函数的转换
- **仿真实验5.5**：不同初始状态下的系统响应

#### 多水箱网络建模
```python
class MultiTankNetwork:
    """多水箱网络系统（拓扑可配置）"""
    
    def __init__(self, config):
        """
        config: 字典，定义水箱参数和连接关系
        例如：
        {
            'tanks': [
                {'id': 1, 'A': 0.5, 'R_out': 2.0},
                {'id': 2, 'A': 0.5, 'R_out': 2.0},
                ...
            ],
            'connections': [
                {'from': 1, 'to': 2, 'R': 1.5},  # 水箱1通过阻力R流向水箱2
                ...
            ],
            'pumps': [
                {'to': 1, 'K': 1.0},  # 泵入水箱1，增益K
                ...
            ]
        }
        """
        self.config = config
        self.n_tanks = len(config['tanks'])
        self.A, self.B, self.C = self._build_state_space()
    
    def _build_state_space(self):
        """构建状态空间矩阵"""
        n = self.n_tanks
        A = np.zeros((n, n))
        B = np.zeros((n, len(self.config['pumps'])))
        C = np.eye(n)  # 假设所有状态都可测
        
        # 构建A矩阵（水箱间的耦合）
        for i, tank in enumerate(self.config['tanks']):
            # 自身的流出
            A[i, i] = -1 / (tank['A'] * tank['R_out'])
        
        for conn in self.config['connections']:
            from_idx = conn['from'] - 1  # 索引从0开始
            to_idx = conn['to'] - 1
            R = conn['R']
            A_from = self.config['tanks'][from_idx]['A']
            A_to = self.config['tanks'][to_idx]['A']
            
            # from水箱的流出
            A[from_idx, from_idx] -= 1 / (A_from * R)
            # to水箱的流入
            A[to_idx, from_idx] += 1 / (A_to * R)
        
        # 构建B矩阵（泵的输入）
        for j, pump in enumerate(self.config['pumps']):
            to_idx = pump['to'] - 1
            A_to = self.config['tanks'][to_idx]['A']
            B[to_idx, j] = pump['K'] / A_to
        
        return A, B, C
    
    def check_controllability(self):
        """检查可控性"""
        n = self.A.shape[0]
        m = self.B.shape[1]
        
        # 可控性矩阵 [B, AB, A²B, ..., A^(n-1)B]
        controllability_matrix = np.zeros((n, n * m))
        for i in range(n):
            controllability_matrix[:, i*m:(i+1)*m] = np.linalg.matrix_power(self.A, i) @ self.B
        
        rank = np.linalg.matrix_rank(controllability_matrix)
        return rank == n, rank
    
    def check_observability(self):
        """检查可观测性"""
        n = self.A.shape[0]
        p = self.C.shape[0]
        
        # 可观测性矩阵 [C; CA; CA²; ...; CA^(n-1)]
        observability_matrix = np.zeros((n * p, n))
        for i in range(n):
            observability_matrix[i*p:(i+1)*p, :] = self.C @ np.linalg.matrix_power(self.A, i)
        
        rank = np.linalg.matrix_rank(observability_matrix)
        return rank == n, rank
```

---

### 【案例6】实际水箱系统的参数辨识 ⭐⭐⭐
**难度等级：** 中级-高级  
**工程背景：** 已有水箱系统，参数未知，需要通过实验数据辨识

#### 问题描述
工厂有一个老旧的水箱系统，没有设计图纸，需要通过输入-输出数据辨识系统参数（时间常数τ、增益K），以便设计控制器。

#### 涉及理论
- **辨识**：最小二乘法（LS）、递推最小二乘（RLS）
- **信号**：激励信号设计（阶跃、PRBS、扫频）
- **统计**：参数置信区间、模型验证（R²、AIC、BIC）
- **频域辨识**：频率响应函数估计

#### 学习目标
1. 理解系统辨识的基本流程
2. 掌握最小二乘法的原理和实现
3. 学习设计合适的激励信号
4. 理解模型验证的重要性

#### 实验内容
- **仿真实验6.1**：从仿真数据辨识单水箱参数
- **仿真实验6.2**：噪声对辨识精度的影响
- **仿真实验6.3**：不同激励信号的对比（阶跃 vs PRBS）
- **仿真实验6.4**：递推最小二乘在线辨识
- **仿真实验6.5**：频域辨识方法
- **硬件实验6.6**：真实水箱系统的参数辨识

#### 系统辨识完整流程
```python
class SystemIdentification:
    """系统辨识工具类"""
    
    @staticmethod
    def design_prbs_input(duration, dt, amplitude=1.0, bit_length=5):
        """设计伪随机二进制序列(PRBS)激励信号"""
        from scipy.signal import max_len_seq
        
        # 生成PRBS序列
        n_bits = int(duration / (dt * bit_length))
        prbs_bits, _ = max_len_seq(8, length=n_bits)  # 8阶LFSR
        
        # 转换为连续信号
        t = np.arange(0, duration, dt)
        u = np.zeros_like(t)
        
        for i in range(len(t)):
            bit_idx = int(i / bit_length) % len(prbs_bits)
            u[i] = amplitude if prbs_bits[bit_idx] else -amplitude
        
        return t, u
    
    @staticmethod
    def least_squares_arx(y, u, na=1, nb=1, nk=0):
        """
        ARX模型辨识：A(q)y(t) = B(q)u(t-nk) + e(t)
        
        Args:
            y: 输出数据
            u: 输入数据
            na: A多项式阶数
            nb: B多项式阶数
            nk: 延迟步数
        
        Returns:
            a_coeffs: A多项式系数 [a1, a2, ..., ana]
            b_coeffs: B多项式系数 [b0, b1, ..., bnb]
        """
        N = len(y)
        max_order = max(na, nb + nk)
        
        # 构建回归矩阵
        Phi = np.zeros((N - max_order, na + nb + 1))
        Y = y[max_order:]
        
        for i in range(N - max_order):
            idx = i + max_order
            
            # A多项式的项 (过去的输出)
            for j in range(na):
                Phi[i, j] = -y[idx - j - 1]
            
            # B多项式的项 (过去的输入)
            for j in range(nb + 1):
                if idx - nk - j >= 0:
                    Phi[i, na + j] = u[idx - nk - j]
        
        # 最小二乘求解
        theta = np.linalg.lstsq(Phi, Y, rcond=None)[0]
        
        a_coeffs = theta[:na]
        b_coeffs = theta[na:]
        
        return a_coeffs, b_coeffs
    
    @staticmethod
    def convert_arx_to_transfer_function(a_coeffs, b_coeffs, dt):
        """将ARX模型转换为传递函数"""
        # 离散传递函数
        num_z = b_coeffs
        den_z = np.concatenate(([1], a_coeffs))
        
        # 转换为连续时间（双线性变换）
        sys_discrete = control.TransferFunction(num_z, den_z, dt)
        sys_continuous = control.sample_system(sys_discrete, dt, method='tustin')
        
        return sys_continuous
    
    @staticmethod
    def validate_model(y_true, y_pred):
        """模型验证指标"""
        # R² (决定系数)
        ss_res = np.sum((y_true - y_pred) ** 2)
        ss_tot = np.sum((y_true - np.mean(y_true)) ** 2)
        r_squared = 1 - (ss_res / ss_tot)
        
        # FIT (拟合百分比)
        fit_percent = (1 - np.linalg.norm(y_true - y_pred) / np.linalg.norm(y_true - np.mean(y_true))) * 100
        
        # RMSE (均方根误差)
        rmse = np.sqrt(np.mean((y_true - y_pred) ** 2))
        
        # NRMSE (归一化RMSE)
        nrmse = rmse / (np.max(y_true) - np.min(y_true))
        
        return {
            'R²': r_squared,
            'FIT': fit_percent,
            'RMSE': rmse,
            'NRMSE': nrmse
        }
```

#### 完整辨识实验示例
```python
def complete_identification_experiment():
    """完整的辨识实验流程"""
    
    # 1. 真实系统（未知参数）
    true_system = SingleTank(A=0.5, R=2.5, K=1.2)  # 真实参数未知
    
    # 2. 设计激励信号
    duration = 200
    dt = 0.1
    t, u = SystemIdentification.design_prbs_input(duration, dt, amplitude=2.0)
    
    # 3. 采集输入-输出数据（模拟真实实验）
    y = np.zeros_like(t)
    x = 0  # 初始水位
    
    for i in range(1, len(t)):
        # 系统动态
        Q_in = true_system.K * u[i-1]
        Q_out = x / true_system.R if x > 0 else 0
        dx = (Q_in - Q_out) / true_system.A
        x = x + dx * dt
        
        # 添加测量噪声
        y[i] = x + np.random.normal(0, 0.05)
    
    # 4. 数据预处理（去除初始瞬态）
    t_train = t[500:]
    u_train = u[500:]
    y_train = y[500:]
    
    # 5. 辨识（ARX模型）
    a_coeffs, b_coeffs = SystemIdentification.least_squares_arx(
        y_train, u_train, na=1, nb=1, nk=1
    )
    
    # 6. 转换为传递函数
    sys_identified = SystemIdentification.convert_arx_to_transfer_function(
        a_coeffs, b_coeffs, dt
    )
    
    # 7. 模型验证（用另一段数据）
    t_test, u_test = SystemIdentification.design_prbs_input(100, dt, amplitude=1.5)
    _, y_test_true = true_system.simulate(t_test, u_test)
    _, y_test_pred = control.forced_response(sys_identified, t_test, u_test)
    
    metrics = SystemIdentification.validate_model(y_test_true, y_test_pred)
    
    # 8. 结果展示
    print(f"辨识参数: K={b_coeffs[0]/b_coeffs[1]:.3f}, τ={-1/a_coeffs[0]:.3f}")
    print(f"真实参数: K={true_system.gain:.3f}, τ={true_system.tau:.3f}")
    print(f"验证指标: R²={metrics['R²']:.4f}, FIT={metrics['FIT']:.2f}%")
    
    # 绘图对比
    plt.figure(figsize=(12, 8))
    
    plt.subplot(3, 1, 1)
    plt.plot(t_train, u_train)
    plt.ylabel('Input (u)')
    plt.title('Identification Data')
    plt.grid()
    
    plt.subplot(3, 1, 2)
    plt.plot(t_train, y_train, label='Measured')
    plt.ylabel('Output (y)')
    plt.legend()
    plt.grid()
    
    plt.subplot(3, 1, 3)
    plt.plot(t_test, y_test_true, label='True System', linewidth=2)
    plt.plot(t_test, y_test_pred, '--', label='Identified Model')
    plt.xlabel('Time (s)')
    plt.ylabel('Output (y)')
    plt.title(f"Model Validation (R²={metrics['R²']:.4f})")
    plt.legend()
    plt.grid()
    
    plt.tight_layout()
    plt.show()
```

---

### 【案例7】水箱系统的数字孪生平台 ⭐⭐⭐⭐
**难度等级：** 高级  
**工程背景：** 建立水箱系统的数字孪生，实现虚实同步和预测性维护

#### 问题描述
工厂希望建立水箱系统的数字孪生，实时同步物理系统状态，预测未来30分钟的水位变化，并在传感器故障时提供软测量值。

#### 涉及理论
- **数字孪生**：五维模型（物理实体、虚拟模型、数据、服务、连接）
- **滤波**：卡尔曼滤波器（Kalman Filter）、扩展卡尔曼滤波（EKF）
- **故障诊断**：残差生成、阈值设计、故障隔离
- **预测**：基于模型的短期预测

#### 学习目标
1. 理解数字孪生的架构和关键技术
2. 掌握卡尔曼滤波器的设计和实现
3. 学习故障检测与隔离（FDI）方法
4. 理解在线模型校准的必要性

#### 实验内容
- **仿真实验7.1**：数字孪生系统架构搭建
- **仿真实验7.2**：卡尔曼滤波器状态估计
- **仿真实验7.3**：传感器故障检测
- **仿真实验7.4**：模型参数在线校准
- **仿真实验7.5**：基于孪生模型的短期预测
- **硬件实验7.6**：真实水箱系统的数字孪生集成

#### 数字孪生系统实现
```python
class WaterTankDigitalTwin:
    """水箱系统数字孪生"""
    
    def __init__(self, physical_system, model_params):
        """
        Args:
            physical_system: 物理系统接口（传感器、执行器）
            model_params: 初始模型参数 {'A': 0.5, 'R': 2.0, 'K': 1.0}
        """
        self.physical = physical_system
        self.model = SingleTank(**model_params)
        
        # 卡尔曼滤波器
        self.kf = self._initialize_kalman_filter()
        
        # 状态历史
        self.state_history = []
        self.time_history = []
        
        # 故障检测
        self.residual_buffer = deque(maxlen=50)
        self.fault_threshold = 0.2
    
    def _initialize_kalman_filter(self):
        """初始化卡尔曼滤波器"""
        # 状态: [h, K, tau] (水位 + 参数)
        dt = 0.1
        
        # 状态转移矩阵（扩展卡尔曼滤波，线性化）
        A = np.array([
            [1 - dt/(self.model.tau), 0, 0],
            [0, 1, 0],  # K是常数
            [0, 0, 1]   # tau是常数
        ])
        
        # 控制输入矩阵
        B = np.array([[dt * self.model.K / self.model.A], [0], [0]])
        
        # 观测矩阵
        C = np.array([[1, 0, 0]])  # 只观测水位
        
        # 噪声协方差
        Q = np.diag([0.01, 0.001, 0.001])  # 过程噪声
        R = np.array([[0.05]])  # 测量噪声
        
        # 初始状态和协方差
        x0 = np.array([2.0, self.model.K, self.model.tau])
        P0 = np.eye(3) * 0.1
        
        return KalmanFilter(A, B, C, Q, R, x0, P0)
    
    def sync_step(self, u, dt=0.1):
        """
        执行一步虚实同步
        
        Args:
            u: 控制输入
            dt: 时间步长
        
        Returns:
            twin_state: 孪生模型估计的状态
            physical_measurement: 物理系统测量值
            fault_detected: 是否检测到故障
        """
        # 1. 从物理系统获取测量值
        physical_measurement = self.physical.read_level_sensor()
        
        # 2. 卡尔曼滤波器预测
        self.kf.predict(u)
        
        # 3. 卡尔曼滤波器更新（融合测量值）
        twin_state = self.kf.update(physical_measurement)
        
        # 4. 残差生成（模型预测 vs 实际测量）
        residual = abs(twin_state[0] - physical_measurement)
        self.residual_buffer.append(residual)
        
        # 5. 故障检测
        fault_detected = self._detect_fault()
        
        # 6. 如果检测到故障，使用孪生模型提供软测量
        if fault_detected:
            print(f"[WARNING] Sensor fault detected! Using twin model estimate.")
            physical_measurement = twin_state[0]  # 用模型估计替代
        
        # 7. 参数在线校准（每100步）
        if len(self.state_history) % 100 == 0:
            self._calibrate_parameters()
        
        # 8. 记录历史
        self.state_history.append(twin_state.copy())
        self.time_history.append(len(self.state_history) * dt)
        
        return twin_state, physical_measurement, fault_detected
    
    def _detect_fault(self):
        """基于残差的故障检测"""
        if len(self.residual_buffer) < 10:
            return False
        
        # 统计检验（3-sigma准则）
        residual_mean = np.mean(self.residual_buffer)
        residual_std = np.std(self.residual_buffer)
        
        # 最近的残差是否超过阈值
        recent_residual = self.residual_buffer[-1]
        threshold = residual_mean + 3 * residual_std
        
        return recent_residual > max(threshold, self.fault_threshold)
    
    def _calibrate_parameters(self):
        """在线参数校准（简化版）"""
        if len(self.state_history) < 100:
            return
        
        # 使用最近的数据重新辨识参数
        recent_data = self.state_history[-100:]
        # ... 辨识算法 ...
        # 更新self.model和self.kf的参数
        pass
    
    def predict_future(self, horizon=30, dt=0.1, future_u=None):
        """
        基于孪生模型预测未来状态
        
        Args:
            horizon: 预测时域（步数）
            dt: 时间步长
            future_u: 未来的控制输入序列（如果为None，假设保持当前输入）
        
        Returns:
            t_pred: 预测时间序列
            y_pred: 预测输出序列
        """
        current_state = self.state_history[-1][0]  # 当前水位
        current_u = future_u[0] if future_u is not None else 0
        
        t_pred = np.arange(0, horizon * dt, dt)
        y_pred = np.zeros(len(t_pred))
        y_pred[0] = current_state
        
        x = current_state
        for i in range(1, len(t_pred)):
            u = future_u[i] if future_u is not None else current_u
            
            # 使用当前孪生模型参数预测
            Q_in = self.model.K * u
            Q_out = x / self.model.R if x > 0 else 0
            dx = (Q_in - Q_out) / self.model.A
            x = x + dx * dt
            
            y_pred[i] = x
        
        return t_pred, y_pred
    
    def visualize_dashboard(self):
        """实时可视化仪表盘"""
        fig, axes = plt.subplots(3, 1, figsize=(12, 10))
        
        # 子图1：水位对比（物理 vs 孪生）
        axes[0].plot(self.time_history, [s[0] for s in self.state_history], 
                     label='Twin Model', linewidth=2)
        # ... 物理测量值 ...
        axes[0].set_ylabel('Water Level (m)')
        axes[0].legend()
        axes[0].grid()
        
        # 子图2：残差
        axes[1].plot(self.time_history[-len(self.residual_buffer):], 
                     list(self.residual_buffer))
        axes[1].axhline(self.fault_threshold, color='r', linestyle='--', 
                        label='Fault Threshold')
        axes[1].set_ylabel('Residual')
        axes[1].legend()
        axes[1].grid()
        
        # 子图3：参数演化
        axes[2].plot(self.time_history, [s[1] for s in self.state_history], 
                     label='K estimate')
        axes[2].plot(self.time_history, [s[2] for s in self.state_history], 
                     label='τ estimate')
        axes[2].set_xlabel('Time (s)')
        axes[2].set_ylabel('Parameter Value')
        axes[2].legend()
        axes[2].grid()
        
        plt.tight_layout()
        plt.show()


class KalmanFilter:
    """卡尔曼滤波器（线性/扩展）"""
    
    def __init__(self, A, B, C, Q, R, x0, P0):
        self.A = A  # 状态转移矩阵
        self.B = B  # 控制输入矩阵
        self.C = C  # 观测矩阵
        self.Q = Q  # 过程噪声协方差
        self.R = R  # 测量噪声协方差
        
        self.x = x0  # 状态估计
        self.P = P0  # 状态协方差
    
    def predict(self, u):
        """预测步"""
        self.x = self.A @ self.x + self.B.flatten() * u
        self.P = self.A @ self.P @ self.A.T + self.Q
    
    def update(self, z):
        """更新步（融合测量）"""
        # 卡尔曼增益
        S = self.C @ self.P @ self.C.T + self.R
        K = self.P @ self.C.T @ np.linalg.inv(S)
        
        # 状态更新
        innovation = z - self.C @ self.x
        self.x = self.x + K.flatten() * innovation
        
        # 协方差更新
        I = np.eye(self.P.shape[0])
        self.P = (I - K @ self.C) @ self.P
        
        return self.x
```

---

### 【案例8】水箱系统的状态反馈与LQR控制 ⭐⭐⭐⭐
**难度等级：** 高级  
**工程背景：** 使用现代控制理论优化多目标性能

#### 问题描述
某水处理系统需要在保证水位精度的同时，最小化泵的功耗和开关次数。传统PID难以平衡多目标，引入LQR（线性二次调节器）。

#### 涉及理论
- **现代控制**：状态反馈 u = -Kx、极点配置
- **最优控制**：LQR（Linear Quadratic Regulator）、代价函数设计
- **观测器**：全维状态观测器、Luenberger观测器
- **分离定理**：控制器与观测器独立设计

#### 学习目标
1. 理解状态反馈控制的原理
2. 掌握LQR的推导和求解（Riccati方程）
3. 学习权重矩阵Q、R的调整对性能的影响
4. 理解观测器的设计（当状态不可全部测量时）

#### 实验内容
- **仿真实验8.1**：极点配置法设计状态反馈增益
- **仿真实验8.2**：LQR控制器设计与调优
- **仿真实验8.3**：不同Q、R权重的性能对比
- **仿真实验8.4**：全维状态观测器设计
- **仿真实验8.5**：基于观测器的输出反馈控制
- **仿真实验8.6**：LQR vs PID性能对比

#### LQR控制器设计
```python
class LQRController:
    """线性二次调节器（LQR）"""
    
    def __init__(self, A, B, C, Q, R):
        """
        Args:
            A, B, C: 状态空间矩阵
            Q: 状态权重矩阵（n×n，半正定）
            R: 控制权重矩阵（m×m，正定）
        """
        self.A = A
        self.B = B
        self.C = C
        self.Q = Q
        self.R = R
        
        # 求解Riccati方程得到最优增益K
        self.K, self.S, self.E = self._solve_lqr()
    
    def _solve_lqr(self):
        """求解连续时间LQR（求解代数Riccati方程）"""
        try:
            # 使用scipy的lqr求解器
            from scipy import linalg
            S = linalg.solve_continuous_are(self.A, self.B, self.Q, self.R)
            K = np.linalg.inv(self.R) @ self.B.T @ S
            E = np.linalg.eigvals(self.A - self.B @ K)
            return K, S, E
        except:
            # 如果scipy版本不支持，使用control库
            K, S, E = control.lqr(self.A, self.B, self.Q, self.R)
            return K, S, E
    
    def compute(self, x, x_ref=None):
        """
        计算控制输入
        
        Args:
            x: 当前状态
            x_ref: 参考状态（如果为None，则默认为零）
        
        Returns:
            u: 控制输入
        """
        if x_ref is None:
            x_ref = np.zeros_like(x)
        
        # 状态反馈: u = -K(x - x_ref)
        u = -self.K @ (x - x_ref)
        
        return u.flatten()[0] if u.shape[0] == 1 else u
    
    def analyze_performance(self):
        """分析LQR性能"""
        print("=== LQR Controller Analysis ===")
        print(f"Optimal Gain K: {self.K.flatten()}")
        print(f"Closed-loop Eigenvalues: {self.E}")
        print(f"All eigenvalues have negative real parts: {np.all(np.real(self.E) < 0)}")
        
        # 计算代价函数的一些性质
        # ... 更多分析 ...


class LuenbergerObserver:
    """Luenberger状态观测器"""
    
    def __init__(self, A, B, C, L, x0=None):
        """
        Args:
            A, B, C: 状态空间矩阵
            L: 观测器增益矩阵（n×p）
            x0: 初始状态估计
        """
        self.A = A
        self.B = B
        self.C = C
        self.L = L
        
        n = A.shape[0]
        self.x_hat = np.zeros(n) if x0 is None else x0
    
    def update(self, u, y, dt):
        """
        更新状态估计
        
        观测器动态: dx̂/dt = Ax̂ + Bu + L(y - Cx̂)
        
        Args:
            u: 控制输入
            y: 测量输出
            dt: 时间步长
        
        Returns:
            x_hat: 状态估计
        """
        # 预测
        x_pred = self.x_hat + (self.A @ self.x_hat + self.B.flatten() * u) * dt
        
        # 校正（基于测量残差）
        y_pred = self.C @ x_pred
        innovation = y - y_pred
        self.x_hat = x_pred + (self.L @ innovation).flatten() * dt
        
        return self.x_hat
    
    @staticmethod
    def design_observer_gain(A, C, desired_poles):
        """
        设计观测器增益L，使得(A-LC)的特征值为desired_poles
        
        等价于对偶系统的状态反馈设计
        """
        # 对偶系统
        A_dual = A.T
        B_dual = C.T
        
        # 极点配置
        K_dual = control.place(A_dual, B_dual, desired_poles)
        
        # 观测器增益
        L = K_dual.T
        
        return L


def lqr_vs_pid_comparison():
    """LQR与PID性能对比实验"""
    
    # 1. 系统模型（双水箱）
    tank = DoubleTankCascade(A1=0.5, A2=0.5, R1=2.0, R2=2.0, K=1.0)
    A, B, C, D = tank.state_space_model()
    
    # 2. LQR控制器设计
    # 权重矩阵：更关注下水箱水位（x2），适度惩罚控制输入
    Q = np.diag([1, 100])  # x1权重小，x2权重大
    R = np.array([[1]])
    
    lqr = LQRController(A, B, C, Q, R)
    lqr.analyze_performance()
    
    # 3. PID控制器（仅基于输出y=x2）
    pid = PIDController(Kp=2.0, Ki=0.5, Kd=0.1, setpoint=3.0, dt=0.1)
    
    # 4. 仿真对比
    t_sim = np.arange(0, 200, 0.1)
    setpoint = 3.0
    x_ref = np.array([setpoint * tank.R1, setpoint])  # 稳态参考状态
    
    # LQR仿真
    x_lqr = np.zeros((len(t_sim), 2))
    u_lqr = np.zeros(len(t_sim))
    x_lqr[0] = [1.0, 1.0]  # 初始状态
    
    for i in range(1, len(t_sim)):
        u_lqr[i-1] = lqr.compute(x_lqr[i-1], x_ref)
        dx = A @ x_lqr[i-1] + B.flatten() * u_lqr[i-1]
        x_lqr[i] = x_lqr[i-1] + dx * 0.1
    
    # PID仿真
    x_pid = np.zeros((len(t_sim), 2))
    u_pid = np.zeros(len(t_sim))
    x_pid[0] = [1.0, 1.0]
    
    for i in range(1, len(t_sim)):
        y = C @ x_pid[i-1]
        u_pid[i-1] = pid.compute(y[0])
        dx = A @ x_pid[i-1] + B.flatten() * u_pid[i-1]
        x_pid[i] = x_pid[i-1] + dx * 0.1
    
    # 5. 性能指标计算
    # 控制精度（RMSE）
    rmse_lqr = np.sqrt(np.mean((x_lqr[:, 1] - setpoint)**2))
    rmse_pid = np.sqrt(np.mean((x_pid[:, 1] - setpoint)**2))
    
    # 控制能耗
    energy_lqr = np.sum(u_lqr**2) * 0.1
    energy_pid = np.sum(u_pid**2) * 0.1
    
    print(f"\n=== Performance Comparison ===")
    print(f"LQR - RMSE: {rmse_lqr:.4f}, Energy: {energy_lqr:.2f}")
    print(f"PID - RMSE: {rmse_pid:.4f}, Energy: {energy_pid:.2f}")
    
    # 6. 可视化
    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
    
    axes[0].plot(t_sim, x_lqr[:, 1], label='LQR', linewidth=2)
    axes[0].plot(t_sim, x_pid[:, 1], label='PID', linewidth=2)
    axes[0].axhline(setpoint, color='k', linestyle='--', label='Setpoint')
    axes[0].set_ylabel('Water Level h2 (m)')
    axes[0].legend()
    axes[0].grid()
    axes[0].set_title('Output Response')
    
    axes[1].plot(t_sim, u_lqr, label='LQR')
    axes[1].plot(t_sim, u_pid, label='PID')
    axes[1].set_ylabel('Control Input u')
    axes[1].legend()
    axes[1].grid()
    axes[1].set_title('Control Effort')
    
    axes[2].plot(t_sim, np.abs(x_lqr[:, 1] - setpoint), label='LQR Error')
    axes[2].plot(t_sim, np.abs(x_pid[:, 1] - setpoint), label='PID Error')
    axes[2].set_xlabel('Time (s)')
    axes[2].set_ylabel('Absolute Error')
    axes[2].set_yscale('log')
    axes[2].legend()
    axes[2].grid()
    axes[2].set_title('Tracking Error (log scale)')
    
    plt.tight_layout()
    plt.show()
```

---

### 【案例9】约束水箱系统的模型预测控制 ⭐⭐⭐⭐⭐
**难度等级：** 高级  
**工程背景：** 水箱有物理约束（水位限制、泵流量限制），需要最优控制

#### 问题描述
化工厂的反应釜供料水箱，水位必须严格保持在1.5-3.5米之间（安全约束），泵流量0-10 m³/h（物理限制）。需要设计能处理约束的先进控制器。

#### 涉及理论
- **MPC**：滚动优化、预测模型、约束处理
- **优化**：二次规划（QP）、凸优化
- **实时计算**：快速QP求解器（OSQP、qpOASES）

#### 学习目标
1. 理解MPC的基本原理（预测→优化→反馈）
2. 掌握MPC的数学表达（代价函数+约束）
3. 学习将MPC转化为QP问题
4. 理解预测时域和控制时域的作用

#### 实验内容
- **仿真实验9.1**：MPC基本框架实现
- **仿真实验9.2**：约束违反的演示（与无约束控制对比）
- **仿真实验9.3**：不同预测时域的影响
- **仿真实验9.4**：MPC处理扰动的能力
- **仿真实验9.5**：MPC vs LQR vs PID三方对比
- **硬件实验9.6**：实时MPC实现（需要快速求解器）

#### 模型预测控制实现
```python
import cvxpy as cp

class MPCController:
    """模型预测控制器（处理约束）"""
    
    def __init__(self, A, B, C, Q, R, N, dt,
                 x_min=None, x_max=None, 
                 u_min=None, u_max=None,
                 du_max=None):
        """
        Args:
            A, B, C: 离散状态空间矩阵
            Q: 状态权重矩阵 (n×n)
            R: 控制权重矩阵 (m×m)
            N: 预测时域
            dt: 采样时间
            x_min, x_max: 状态约束 (n×1数组)
            u_min, u_max: 控制输入约束 (m×1数组)
            du_max: 控制增量约束 (m×1数组)
        """
        self.A = A
        self.B = B
        self.C = C
        self.Q = Q
        self.R = R
        self.N = N  # 预测时域
        self.dt = dt
        
        self.n = A.shape[0]  # 状态维数
        self.m = B.shape[1]  # 控制维数
        
        # 约束
        self.x_min = x_min if x_min is not None else np.full(self.n, -np.inf)
        self.x_max = x_max if x_max is not None else np.full(self.n, np.inf)
        self.u_min = u_min if u_min is not None else np.full(self.m, -np.inf)
        self.u_max = u_max if u_max is not None else np.full(self.m, np.inf)
        self.du_max = du_max if du_max is not None else np.full(self.m, np.inf)
        
        # 上一时刻的控制输入（用于计算控制增量）
        self.u_prev = np.zeros(self.m)
        
        # 预构建优化问题（加速在线求解）
        self.x_var, self.u_var, self.x0_param, self.xref_param, self.problem = \
            self._build_optimization_problem()
    
    def _build_optimization_problem(self):
        """构建CVXPY优化问题（离线构建，在线求解）"""
        
        # 决策变量
        x = cp.Variable((self.n, self.N + 1))  # 状态序列 x[0], x[1], ..., x[N]
        u = cp.Variable((self.m, self.N))      # 控制序列 u[0], u[1], ..., u[N-1]
        
        # 参数（在线更新）
        x0 = cp.Parameter(self.n)              # 当前状态
        x_ref = cp.Parameter(self.n)           # 参考状态
        
        # 代价函数
        cost = 0
        
        for k in range(self.N):
            # 状态代价: (x[k] - x_ref)' Q (x[k] - x_ref)
            cost += cp.quad_form(x[:, k] - x_ref, self.Q)
            
            # 控制代价: u[k]' R u[k]
            cost += cp.quad_form(u[:, k], self.R)
        
        # 终端代价
        cost += cp.quad_form(x[:, self.N] - x_ref, self.Q)
        
        # 约束
        constraints = []
        
        # 初始状态约束
        constraints.append(x[:, 0] == x0)
        
        for k in range(self.N):
            # 系统动态约束: x[k+1] = A x[k] + B u[k]
            constraints.append(x[:, k+1] == self.A @ x[:, k] + self.B @ u[:, k])
            
            # 状态约束: x_min <= x[k] <= x_max
            constraints.append(x[:, k] >= self.x_min)
            constraints.append(x[:, k] <= self.x_max)
            
            # 控制约束: u_min <= u[k] <= u_max
            constraints.append(u[:, k] >= self.u_min)
            constraints.append(u[:, k] <= self.u_max)
            
            # 控制增量约束: |u[k] - u[k-1]| <= du_max
            if k > 0:
                constraints.append(cp.abs(u[:, k] - u[:, k-1]) <= self.du_max)
        
        # 终端状态约束
        constraints.append(x[:, self.N] >= self.x_min)
        constraints.append(x[:, self.N] <= self.x_max)
        
        # 构建优化问题
        problem = cp.Problem(cp.Minimize(cost), constraints)
        
        return x, u, x0, x_ref, problem
    
    def compute(self, x_current, x_reference=None):
        """
        计算MPC控制输入
        
        Args:
            x_current: 当前状态 (n×1)
            x_reference: 参考状态 (n×1)，如果为None则为零
        
        Returns:
            u_optimal: 最优控制输入（应用第一个元素）
            u_sequence: 完整的最优控制序列（用于可视化）
            solve_time: 求解时间
        """
        import time
        
        if x_reference is None:
            x_reference = np.zeros(self.n)
        
        # 更新参数
        self.x0_param.value = x_current
        self.xref_param.value = x_reference
        
        # 求解优化问题
        start_time = time.time()
        
        try:
            self.problem.solve(solver=cp.OSQP, warm_start=True, verbose=False)
            solve_time = time.time() - start_time
            
            if self.problem.status not in ["optimal", "optimal_inaccurate"]:
                print(f"[WARNING] MPC solve status: {self.problem.status}")
                # 返回安全的默认控制
                return np.zeros(self.m), None, solve_time
            
            # 提取最优解（MPC策略：只应用第一个控制）
            u_optimal = self.u_var[:, 0].value
            u_sequence = self.u_var.value
            
            # 更新u_prev用于下一次的增量约束
            self.u_prev = u_optimal
            
            return u_optimal, u_sequence, solve_time
            
        except Exception as e:
            print(f"[ERROR] MPC solve failed: {e}")
            return np.zeros(self.m), None, 0.0
    
    def visualize_prediction(self, x_current, x_reference):
        """可视化预测轨迹"""
        u_opt, u_seq, _ = self.compute(x_current, x_reference)
        
        if u_seq is None:
            return
        
        # 预测状态轨迹
        x_pred = self.x_var.value
        
        t_pred = np.arange(self.N + 1) * self.dt
        
        plt.figure(figsize=(12, 8))
        
        # 子图1：状态预测
        plt.subplot(2, 1, 1)
        for i in range(self.n):
            plt.plot(t_pred, x_pred[i, :], 'o-', label=f'x{i+1} prediction')
            plt.axhline(x_reference[i], color='k', linestyle='--', alpha=0.3)
            
            # 绘制约束
            if np.isfinite(self.x_min[i]):
                plt.axhline(self.x_min[i], color='r', linestyle=':', label=f'x{i+1} min' if i==0 else '')
            if np.isfinite(self.x_max[i]):
                plt.axhline(self.x_max[i], color='r', linestyle=':', label=f'x{i+1} max' if i==0 else '')
        
        plt.ylabel('State')
        plt.legend()
        plt.grid()
        plt.title('MPC State Prediction over Horizon')
        
        # 子图2：控制序列
        plt.subplot(2, 1, 2)
        t_ctrl = np.arange(self.N) * self.dt
        
        for i in range(self.m):
            plt.step(t_ctrl, u_seq[i, :], where='post', label=f'u{i+1}')
            
            # 绘制约束
            if np.isfinite(self.u_min[i]):
                plt.axhline(self.u_min[i], color='r', linestyle=':', label=f'u{i+1} min' if i==0 else '')
            if np.isfinite(self.u_max[i]):
                plt.axhline(self.u_max[i], color='r', linestyle=':', label=f'u{i+1} max' if i==0 else '')
        
        plt.xlabel('Time (s)')
        plt.ylabel('Control Input')
        plt.legend()
        plt.grid()
        plt.title('Optimal Control Sequence')
        
        plt.tight_layout()
        plt.show()


def mpc_constraint_handling_demo():
    """MPC约束处理演示"""
    
    # 1. 系统（单水箱离散化）
    A_c = np.array([[-0.5]])  # 连续时间
    B_c = np.array([[1.0]])
    C_c = np.array([[1.0]])
    
    dt = 0.1
    A_d = np.eye(1) + A_c * dt
    B_d = B_c * dt
    
    # 2. 约束
    x_min = np.array([1.5])  # 最低水位1.5m
    x_max = np.array([3.5])  # 最高水位3.5m
    u_min = np.array([0])    # 泵不能反转
    u_max = np.array([10])   # 泵最大流量10 m³/h
    du_max = np.array([2])   # 流量变化率限制（避免水击）
    
    # 3. MPC控制器
    Q = np.array([[10]])
    R = np.array([[0.1]])
    N = 20  # 预测时域20步
    
    mpc = MPCController(A_d, B_d, C_c, Q, R, N, dt,
                        x_min, x_max, u_min, u_max, du_max)
    
    # 4. 仿真（大幅度设定值变化 + 扰动）
    t_sim = np.arange(0, 100, dt)
    x = np.array([2.0])  # 初始水位2m
    x_ref = np.array([3.0])  # 目标水位3m
    
    x_history = [x.copy()]
    u_history = []
    solve_times = []
    
    for i, t in enumerate(t_sim[:-1]):
        # 设定值变化
        if t > 40:
            x_ref = np.array([2.0])  # 在40s时降低目标
        
        # 添加扰动（在t=60s时，突然的外部流入）
        disturbance = 3.0 if 60 < t < 65 else 0
        
        # MPC控制
        u, _, solve_time = mpc.compute(x, x_ref)
        
        # 系统演化（含扰动）
        x = A_d @ x + B_d @ u + disturbance * dt
        
        # 约束检验（后验）
        if x < x_min or x > x_max:
            print(f"[WARNING] Constraint violated at t={t:.1f}: x={x[0]:.2f}")
        
        x_history.append(x.copy())
        u_history.append(u.copy())
        solve_times.append(solve_time)
    
    x_history = np.array(x_history).squeeze()
    u_history = np.array(u_history).squeeze()
    
    # 5. 结果可视化
    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
    
    # 水位
    axes[0].plot(t_sim, x_history, linewidth=2, label='Water Level')
    axes[0].axhline(x_min[0], color='r', linestyle='--', label='Min Constraint')
    axes[0].axhline(x_max[0], color='r', linestyle='--', label='Max Constraint')
    axes[0].fill_between(t_sim, x_min[0], x_max[0], alpha=0.2, color='green', label='Safe Region')
    axes[0].set_ylabel('Water Level (m)')
    axes[0].legend()
    axes[0].grid()
    axes[0].set_title('MPC with Constraints - State Response')
    
    # 控制输入
    axes[1].step(t_sim[:-1], u_history, where='post', linewidth=2, label='Control Input')
    axes[1].axhline(u_min[0], color='r', linestyle='--', label='Min')
    axes[1].axhline(u_max[0], color='r', linestyle='--', label='Max')
    axes[1].fill_between(t_sim[:-1], u_min[0], u_max[0], alpha=0.2, color='green')
    axes[1].set_ylabel('Flow Rate (m³/h)')
    axes[1].legend()
    axes[1].grid()
    axes[1].set_title('Control Input (respecting constraints)')
    
    # 求解时间
    axes[2].plot(t_sim[:-1], solve_times, linewidth=1, label='Solve Time')
    axes[2].axhline(dt, color='r', linestyle='--', label='Sampling Time')
    axes[2].set_xlabel('Time (s)')
    axes[2].set_ylabel('Solve Time (s)')
    axes[2].set_yscale('log')
    axes[2].legend()
    axes[2].grid()
    axes[2].set_title('Computational Performance (must be < sampling time)')
    
    plt.tight_layout()
    plt.show()
    
    print(f"\n=== MPC Performance ===")
    print(f"Average solve time: {np.mean(solve_times)*1000:.2f} ms")
    print(f"Max solve time: {np.max(solve_times)*1000:.2f} ms")
    print(f"Constraint violations: {np.sum((x_history < x_min) | (x_history > x_max))}")
```

---

### 【案例10】水箱系统的在环测试（HIL/SIL） ⭐⭐⭐⭐
**难度等级：** 高级  
**工程背景：** 在部署到真实系统前，通过在环测试验证控制算法

#### 问题描述
开发了一个复杂的MPC控制器，需要在部署到PLC前进行充分测试，包括边界条件、故障场景、实时性能。

#### 涉及理论
- **在环测试**：MIL、SIL、PIL、HIL的概念和流程
- **实时系统**：实时调度、最坏执行时间（WCET）
- **硬件接口**：DAQ、I/O、通信协议（Modbus、CAN）
- **故障注入**：传感器故障、执行器故障、通信故障

#### 学习目标
1. 理解在环测试在V模型中的位置
2. 掌握SIL测试环境搭建
3. 学习HIL平台的组成和使用
4. 理解实时性验证的重要性

#### 实验内容
- **实验10.1**：MIL测试（纯Python/MATLAB仿真）
- **实验10.2**：SIL测试（C代码生成+联合仿真）
- **实验10.3**：PIL测试（目标MCU仿真）
- **实验10.4**：HIL测试（Arduino/dSPACE）
- **实验10.5**：故障注入测试（传感器漂移、饱和、断线）
- **实验10.6**：实时性能分析（执行时间分布）

#### SIL测试框架

```python
class SILTestFramework:
    """软件在环(SIL)测试框架"""
    
    def __init__(self, controller_code, plant_model):
        """
        Args:
            controller_code: 控制器代码（Python函数或C共享库）
            plant_model: 被控对象模型
        """
        self.controller = controller_code
        self.plant = plant_model
        
        # 测试记录
        self.test_cases = []
        self.test_results = []
    
    def add_test_case(self, name, scenario, expected_behavior, pass_criteria):
        """添加测试用例"""
        self.test_cases.append({
            'name': name,
            'scenario': scenario,
            'expected': expected_behavior,
            'criteria': pass_criteria
        })
    
    def run_all_tests(self):
        """运行所有测试用例"""
        print("=== SIL Test Suite ===")
        
        for i, test in enumerate(self.test_cases):
            print(f"\n[Test {i+1}/{len(self.test_cases)}] {test['name']}")
            
            result = self._run_single_test(test)
            self.test_results.append(result)
            
            status = "PASS" if result['passed'] else "FAIL"
            print(f"Result: {status}")
            
            if not result['passed']:
                print(f"  Reason: {result['reason']}")
        
        # 汇总
        n_pass = sum(r['passed'] for r in self.test_results)
        n_total = len(self.test_results)
        print(f"\n=== Test Summary ===")
        print(f"Passed: {n_pass}/{n_total} ({n_pass/n_total*100:.1f}%)")
    
    def _run_single_test(self, test):
        """运行单个测试"""
        try:
            # 执行场景
            t, x, u = test['scenario'](self.controller, self.plant)
            
            # 检查通过准则
            passed, reason = test['criteria'](t, x, u)
            
            return {
                'passed': passed,
                'reason': reason,
                'data': {'t': t, 'x': x, 'u': u}
            }
        except Exception as e:
            return {
                'passed': False,
                'reason': f"Exception: {str(e)}",
                'data': None
            }


# 示例：定义测试场景和通过准则
def test_scenario_nominal(controller, plant):
    """名义工况测试"""
    t = np.arange(0, 100, 0.1)
    x = np.zeros(len(t))
    u = np.zeros(len(t))
    
    x[0] = 1.0  # 初始水位
    setpoint = 3.0
    
    for i in range(1, len(t)):
        u[i-1] = controller(x[i-1], setpoint)
        x[i] = plant.step(x[i-1], u[i-1], 0.1)
    
    return t, x, u


def pass_criteria_steady_state(t, x, u):
    """稳态误差准则"""
    setpoint = 3.0
    steady_state_error = abs(x[-1] - setpoint)
    
    if steady_state_error < 0.1:
        return True, ""
    else:
        return False, f"Steady-state error {steady_state_error:.3f} > 0.1"


# 使用示例
sil_test = SILTestFramework(pid_controller, single_tank_model)
sil_test.add_test_case(
    name="Nominal Operation",
    scenario=test_scenario_nominal,
    expected_behavior="Converge to setpoint within 50s",
    pass_criteria=pass_criteria_steady_state
)
# ... 添加更多测试用例 ...
sil_test.run_all_tests()
```

#### HIL测试平台（Arduino示例）

```python
# Python端（运行在PC，实时仿真被控对象）
import serial
import time
import struct

class HILSimulator:
    """硬件在环仿真器"""
    
    def __init__(self, port, baudrate=115200):
        self.serial = serial.Serial(port, baudrate, timeout=0.01)
        time.sleep(2)  # 等待Arduino复位
        
        self.plant = SingleTank(A=0.5, R=2.0, K=1.0)
        self.x = 2.0  # 初始水位
        
    def run(self, duration=100, dt=0.1):
        """运行HIL仿真"""
        t_start = time.time()
        t_sim = 0
        
        data_log = {'t': [], 'x': [], 'u': [], 'latency': []}
        
        while t_sim < duration:
            loop_start = time.time()
            
            # 1. 发送传感器值到控制器（Arduino）
            self._send_sensor_data(self.x)
            
            # 2. 接收控制器输出
            u = self._receive_control_input()
            
            if u is not None:
                # 3. 更新被控对象
                Q_in = self.plant.K * u
                Q_out = self.x / self.plant.R if self.x > 0 else 0
                dx = (Q_in - Q_out) / self.plant.A
                self.x = self.x + dx * dt
                
                # 4. 记录数据
                latency = time.time() - loop_start
                data_log['t'].append(t_sim)
                data_log['x'].append(self.x)
                data_log['u'].append(u)
                data_log['latency'].append(latency)
                
                # 5. 实时同步（保持固定采样周期）
                elapsed = time.time() - loop_start
                if elapsed < dt:
                    time.sleep(dt - elapsed)
            
            t_sim += dt
        
        return data_log
    
    def _send_sensor_data(self, water_level):
        """发送传感器数据（float，4字节）"""
        data = struct.pack('f', water_level)
        self.serial.write(b'S' + data)  # 'S'标识sensor data
    
    def _receive_control_input(self):
        """接收控制输入"""
        if self.serial.in_waiting >= 5:  # 'C' + 4 bytes float
            header = self.serial.read(1)
            if header == b'C':
                data = self.serial.read(4)
                u = struct.unpack('f', data)[0]
                return u
        return None
```

```cpp
// Arduino端（控制器，运行在MCU）
// arduino_hil_controller.ino

float setpoint = 3.0;
float Kp = 2.0, Ki = 0.5, Kd = 0.1;
float integral = 0, prev_error = 0;
float dt = 0.1;

void setup() {
  Serial.begin(115200);
}

void loop() {
  // 1. 接收传感器数据
  if (Serial.available() >= 5) {
    char header = Serial.read();
    
    if (header == 'S') {
      float water_level;
      Serial.readBytes((char*)&water_level, 4);
      
      // 2. 计算控制输出（PID）
      float error = setpoint - water_level;
      
      float P = Kp * error;
      integral += error * dt;
      float I = Ki * integral;
      float derivative = (error - prev_error) / dt;
      float D = Kd * derivative;
      
      float u = P + I + D;
      u = constrain(u, 0, 100);  // 限幅
      
      prev_error = error;
      
      // 3. 发送控制输出
      Serial.write('C');
      Serial.write((byte*)&u, 4);
      
      // 性能监控（可选）
      unsigned long exec_time = micros();
      // ... 记录执行时间 ...
    }
  }
}
```

---

### 【案例11】多水箱网络的分布式协同控制 ⭐⭐⭐⭐⭐
**难度等级：** 高级  
**工程背景：** 城市供水网络中多个水箱需要协同控制

#### 问题描述
城市有5个分布式水箱，通过管网连接，各水箱有不同的供水任务，需要设计分布式控制策略，在满足各自水位要求的同时，优化全局能耗和供水公平性。

#### 涉及理论
- **分布式控制**：多智能体系统、一致性协议
- **网络拓扑**：图论基础、通信拓扑对控制性能的影响
- **协同优化**：ADMM（Alternating Direction Method of Multipliers）
- **鲁棒性**：通信延迟、丢包的影响

#### 学习目标
1. 理解集中式控制与分布式控制的区别
2. 掌握一致性协议的设计
3. 学习分布式优化算法（ADMM）
4. 理解通信网络对控制性能的影响

#### 实验内容
- **仿真实验11.1**：5水箱网络建模
- **仿真实验11.2**：集中式MPC vs 分布式MPC对比
- **仿真实验11.3**：一致性协议下的水位同步
- **仿真实验11.4**：通信延迟和丢包的影响
- **仿真实验11.5**：故障情况下的自适应重构

#### 分布式控制实现（简化版）

```python
class DistributedWaterTankNetwork:
    """分布式水箱网络控制系统"""
    
    def __init__(self, n_tanks, adjacency_matrix, tank_params):
        """
        Args:
            n_tanks: 水箱数量
            adjacency_matrix: 通信拓扑矩阵（n×n）
            tank_params: 各水箱参数列表
        """
        self.n = n_tanks
        self.A_comm = adjacency_matrix  # 通信拓扑
        self.tanks = [SingleTank(**params) for params in tank_params]
        
        # 各水箱的本地控制器
        self.local_controllers = [None] * n_tanks
        
        # 一致性协议参数
        self.consensus_gain = 0.1
        
    def design_local_controllers(self, Q, R, N):
        """为每个水箱设计本地MPC控制器"""
        for i in range(self.n):
            A, B, C, D = self.tanks[i].get_state_space()
            self.local_controllers[i] = MPCController(A, B, C, Q, R, N, dt=0.1)
    
    def consensus_step(self, states, setpoints):
        """一致性协议更新（信息交换）
        
        目标：相邻水箱的水位差距逐渐减小
        """
        new_setpoints = setpoints.copy()
        
        for i in range(self.n):
            # 从邻居收集信息
            neighbors = np.where(self.A_comm[i, :] > 0)[0]
            
            if len(neighbors) > 0:
                # 一致性更新：向邻居平均值靠拢
                neighbor_avg = np.mean([states[j] for j in neighbors])
                consensus_term = self.consensus_gain * (neighbor_avg - states[i])
                
                # 修正本地设定值
                new_setpoints[i] += consensus_term
        
        return new_setpoints
    
    def distributed_control_loop(self, duration, dt, global_objective='fairness'):
        """分布式控制主循环"""
        t = np.arange(0, duration, dt)
        n_steps = len(t)
        
        # 状态记录
        states = np.zeros((n_steps, self.n))
        controls = np.zeros((n_steps, self.n))
        setpoints_history = np.zeros((n_steps, self.n))
        
        # 初始条件
        states[0, :] = [2.0, 2.5, 1.8, 3.0, 2.2]  # 各水箱初始水位
        setpoints = np.array([3.0] * self.n)  # 初始目标
        
        for k in range(1, n_steps):
            # 1. 一致性协议更新（全局目标：公平性）
            if global_objective == 'fairness':
                setpoints = self.consensus_step(states[k-1, :], setpoints)
            
            # 2. 各水箱本地控制（并行执行）
            for i in range(self.n):
                x_current = states[k-1, i]
                x_ref = setpoints[i]
                
                # 本地MPC
                u, _, _ = self.local_controllers[i].compute(
                    np.array([x_current]),
                    np.array([x_ref])
                )
                controls[k-1, i] = u[0] if isinstance(u, np.ndarray) else u
            
            # 3. 系统演化
            for i in range(self.n):
                # 本水箱动态
                Q_in = self.tanks[i].K * controls[k-1, i]
                Q_out = states[k-1, i] / self.tanks[i].R if states[k-1, i] > 0 else 0
                
                # 与邻居的水流交换（简化模型）
                neighbors = np.where(self.A_comm[i, :] > 0)[0]
                for j in neighbors:
                    flow_ij = 0.1 * (states[k-1, i] - states[k-1, j])  # 压差驱动
                    Q_out += flow_ij
                
                dx = (Q_in - Q_out) / self.tanks[i].A
                states[k, i] = states[k-1, i] + dx * dt
            
            setpoints_history[k, :] = setpoints
        
        return t, states, controls, setpoints_history
    
    def visualize_network_dynamics(self, t, states, setpoints):
        """可视化网络动态"""
        fig, axes = plt.subplots(2, 1, figsize=(14, 10))
        
        # 子图1：各水箱水位
        for i in range(self.n):
            axes[0].plot(t, states[:, i], label=f'Tank {i+1}', linewidth=2)
            axes[0].plot(t, setpoints[:, i], '--', alpha=0.5)
        
        axes[0].set_ylabel('Water Level (m)')
        axes[0].legend(ncol=5)
        axes[0].grid()
        axes[0].set_title('Distributed Control - All Tanks')
        
        # 子图2：水位方差（衡量公平性）
        variance = np.var(states, axis=1)
        axes[1].plot(t, variance, linewidth=2, color='red')
        axes[1].set_xlabel('Time (s)')
        axes[1].set_ylabel('Water Level Variance')
        axes[1].grid()
        axes[1].set_title('Fairness Metric (lower is better)')
        
        plt.tight_layout()
        plt.show()
```

---

### 【案例12】工业应用综合案例：智能水厂数字孪生系统 ⭐⭐⭐⭐⭐
**难度等级：** 综合（集大成）  
**工程背景：** 真实水处理厂的完整数字孪生系统开发

#### 问题描述
为某市水处理厂开发完整的数字孪生系统，包含：
- 5个处理池（原水池、混凝池、沉淀池×2、清水池）
- 多个泵站和阀门
- 全自动控制（多级PID + MPC）
- 实时监控和故障预警
- 能耗优化
- 水质预测

#### 涉及理论（综合应用）
- **建模**：多池耦合的复杂系统建模
- **辨识**：在线参数自适应
- **控制**：分层控制架构（上层MPC + 下层PID）
- **孪生**：实时同步、预测性维护
- **优化**：能耗优化、调度优化
- **可视化**：3D可视化、实时仪表盘

#### 系统架构

```
┌─────────────────────────────────────────────────────────┐
│              数字孪生系统总体架构                        │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  ┌──────────────┐      ┌──────────────┐                │
│  │ 物理水厂      │◄────►│  数据采集层   │                │
│  │ (传感器/执行器)│      │ (SCADA/PLC)  │                │
│  └──────────────┘      └──────────────┘                │
│                             │                           │
│                             ▼                           │
│                    ┌──────────────┐                    │
│                    │ 通信接口层    │                    │
│                    │ (MQTT/OPC-UA)│                    │
│                    └──────────────┘                    │
│                             │                           │
│         ┌───────────────────┼───────────────────┐      │
│         ▼                   ▼                   ▼      │
│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐  │
│  │ 数字孪生引擎│   │ 控制算法层  │   │  数据分析层  │  │
│  │ (实时仿真)  │   │(MPC/PID)    │   │(机器学习)    │  │
│  └─────────────┘   └─────────────┘   └─────────────┘  │
│         │                   │                   │      │
│         └───────────────────┼───────────────────┘      │
│                             ▼                           │
│                    ┌──────────────┐                    │
│                    │  应用服务层   │                    │
│                    │ (预警/优化)  │                    │
│                    └──────────────┘                    │
│                             │                           │
│                             ▼                           │
│                    ┌──────────────┐                    │
│                    │ 可视化展示层  │                    │
│                    │ (Web Dashboard)│                  │
│                    └──────────────┘                    │
└─────────────────────────────────────────────────────────┘
```

#### 关键模块实现（框架）

```python
class SmartWaterPlantDigitalTwin:
    """智能水厂数字孪生系统（综合案例）"""
    
    def __init__(self, config_file):
        self.config = self.load_config(config_file)
        
        # 1. 物理模型
        self.plant_model = self._build_plant_model()
        
        # 2. 控制系统
        self.hierarchical_controller = self._build_controller()
        
        # 3. 数字孪生引擎
        self.twin_engine = WaterTankDigitalTwin(
            physical_system=None,  # 连接真实系统
            model_params=self.config['model_params']
        )
        
        # 4. 数据分析
        self.ml_predictor = WaterQualityPredictor()
        
        # 5. 优化调度
        self.optimizer = EnergyOptimizer()
        
        # 6. 可视化
        self.dashboard = WebDashboard(port=8050)
    
    def _build_plant_model(self):
        """构建5池耦合模型"""
        # 定义各池参数
        pools = {
            'raw_water': {'A': 10.0, 'R': 5.0},
            'coagulation': {'A': 5.0, 'R': 3.0},
            'sedimentation_1': {'A': 8.0, 'R': 4.0},
            'sedimentation_2': {'A': 8.0, 'R': 4.0},
            'clear_water': {'A': 12.0, 'R': 6.0}
        }
        
        # 构建状态空间模型（5状态，3输入）
        # ... 详细实现 ...
        pass
    
    def _build_controller(self):
        """构建分层控制器"""
        return {
            'upper_layer': MPCController(...),  # 全局优化
            'lower_layer': {
                'pool_1': PIDController(...),
                'pool_2': PIDController(...),
                # ...
            }
        }
    
    def run_realtime_simulation(self):
        """实时运行数字孪生"""
        while True:
            # 1. 从SCADA采集数据
            sensor_data = self.acquire_sensor_data()
            
            # 2. 数字孪生同步
            twin_state = self.twin_engine.sync_step(...)
            
            # 3. 控制决策
            control_output = self.hierarchical_controller.compute(...)
            
            # 4. 发送控制指令
            self.send_control_commands(control_output)
            
            # 5. 预测分析
            predictions = self.ml_predictor.predict(...)
            
            # 6. 故障检测
            faults = self.twin_engine._detect_fault()
            
            # 7. 更新可视化
            self.dashboard.update(sensor_data, twin_state, predictions, faults)
            
            time.sleep(0.1)  # 100ms采样周期
    
    def optimize_energy_consumption(self, horizon=24):
        """能耗优化（24小时调度）"""
        # 考虑分时电价、需求预测、设备约束
        schedule = self.optimizer.solve(
            demand_forecast=...,
            electricity_price=...,
            constraints=...
        )
        return schedule
```

#### 学生综合设计项目要求

**项目交付物：**
1. **系统建模报告**（20页）
   - 物理过程描述
   - 数学模型推导
   - 参数辨识结果

2. **控制系统设计文档**（30页）
   - 控制策略选型
   - 参数整定过程
   - 性能仿真结果

3. **完整代码仓库**（GitHub）
   - 模型代码
   - 控制算法
   - 可视化界面
   - 单元测试

4. **演示视频**（10分钟）
   - 系统功能演示
   - 关键技术讲解
   - 创新点展示

5. **答辩PPT**（15-20页）

**评分标准：**
- 建模准确性（20分）
- 控制性能（25分）
- 数字孪生功能（20分）
- 代码质量（15分）
- 文档完整性（10分）
- 创新与展示（10分）

---

## 📊 案例体系总览表

| 案例编号 | 案例名称 | 难度 | 核心理论 | 实验类型 | 学时 |
|---------|---------|------|---------|---------|------|
| 案例1 | 家庭水塔自动供水 | ⭐ | 一阶系统、开关控制 | 仿真+硬件 | 4 |
| 案例2 | 工业冷却塔精确控制 | ⭐⭐ | 比例控制、性能指标 | 仿真+硬件 | 4 |
| 案例3 | 供水泵站无静差控制 | ⭐⭐ | PI控制、抗饱和 | 仿真+硬件 | 4 |
| 案例4 | 双水箱串联系统 | ⭐⭐⭐ | 二阶系统、PID整定 | 仿真+硬件 | 6 |
| 案例5 | 多水箱网络建模 | ⭐⭐⭐ | 状态空间、可控可观 | 仿真 | 6 |
| 案例6 | 系统参数辨识 | ⭐⭐⭐ | 最小二乘、模型验证 | 仿真+硬件 | 6 |
| 案例7 | 数字孪生平台 | ⭐⭐⭐⭐ | 卡尔曼滤波、故障检测 | 仿真+硬件 | 8 |
| 案例8 | 状态反馈与LQR | ⭐⭐⭐⭐ | 最优控制、观测器 | 仿真 | 6 |
| 案例9 | 约束MPC控制 | ⭐⭐⭐⭐⭐ | 模型预测控制 | 仿真+硬件 | 8 |
| 案例10 | 在环测试 | ⭐⭐⭐⭐ | SIL/HIL、实时性 | 硬件为主 | 6 |
| 案例11 | 分布式协同控制 | ⭐⭐⭐⭐⭐ | 多智能体、一致性 | 仿真 | 8 |
| 案例12 | 智能水厂综合案例 | ⭐⭐⭐⭐⭐ | 综合应用 | 综合项目 | 12 |
| **总计** | | | | | **78学时** |

---

## 🎓 教学实施建议

### 教学模式：翻转课堂 + 项目驱动

#### 课前（自主学习）
- 观看案例背景视频（5-10分钟）
- 阅读理论材料（教材章节）
- 运行基础Jupyter Notebook（预习性实验）

#### 课中（课堂活动，2学时/案例）
- **第1学时**：
  - 案例问题讨论（15分钟）
  - 教师讲解核心理论（30分钟）
  - 建模演示与代码讲解（20分钟）
- **第2学时**：
  - 学生分组实验（40分钟）
  - 结果展示与讨论（20分钟）
  - 总结与作业布置（5分钟）

#### 课后（巩固提升）
- 完成Jupyter Notebook的扩展练习
- 撰写实验报告
- 硬件实验（预约实验室时间）

### 评分权重

| 评分项 | 占比 | 说明 |
|--------|------|------|
| 案例实验报告 | 30% | 12个案例，每个2.5分 |
| 期中考试 | 20% | 案例1-6理论+编程 |
| 综合设计项目 | 35% | 案例12，分组完成 |
| 课堂表现 | 10% | 讨论、提问、演示 |
| 创新加分 | 5% | 改进算法、新功能开发 |

---

## 💻 配套资源开发清单

### 代码库结构

```
water_tank_control_cases/
├── case_01_home_water_tower/
│   ├── models.py
│   ├── controllers.py
│   ├── simulation.py
│   ├── notebook.ipynb
│   ├── hardware/
│   │   └── arduino_code.ino
│   └── README.md
├── case_02_industrial_cooling/
│   ├── ...
├── ...
├── case_12_smart_water_plant/
│   ├── ...
├── shared/
│   ├── visualization.py
│   ├── performance_metrics.py
│   ├── hardware_interface.py
│   └── utils.py
├── tests/
│   ├── test_case_01.py
│   ├── ...
├── requirements.txt
├── environment.yml
└── README.md
```

### Jupyter Notebook设计

每个案例配套1个主Notebook + 3-5个补充Notebook：

**主Notebook结构**（约100-150个cell）：
1. **案例背景**（Markdown）：工程情境、问题描述
2. **理论回顾**（Markdown + LaTeX）：核心公式（5-10个重要公式）
3. **建模推导**（Code + Markdown）：一步步推导
4. **仿真实验**（Code）：交互式参数调整
5. **结果分析**（Code + Markdown）：可视化+讨论
6. **练习题**（Markdown）：3-5道引导式问题
7. **扩展阅读**（Markdown）：论文链接、工程案例

**补充Notebook**：
- `case_XX_theory_deep_dive.ipynb`：理论深入讲解
- `case_XX_parameter_tuning.ipynb`：参数影响分析
- `case_XX_comparison.ipynb`：方法对比实验
- `case_XX_hardware_guide.ipynb`：硬件实验指导
- `case_XX_challenge.ipynb`：挑战性拓展任务

---

## 🚀 开发时间线（12个月）

| 月份 | 主要任务 | 交付物 |
|------|---------|--------|
| M1 | 案例1-3开发 | 代码+3个Notebooks |
| M2 | 案例4-6开发 | 代码+3个Notebooks |
| M3 | 案例7-9开发 | 代码+3个Notebooks |
| M4 | 案例10-12开发 | 代码+3个Notebooks |
| M5 | 硬件平台设计与测试 | 物料清单+PCB+Arduino代码 |
| M6 | Web虚拟实验平台开发 | 前端+后端原型 |
| M7 | 教材编写（第1-6章） | LaTeX草稿 |
| M8 | 教材编写（第7-12章） | LaTeX草稿 |
| M9 | 课堂PPT制作 | 12套PPT |
| M10 | 试点教学与反馈收集 | 学生反馈报告 |
| M11 | 内容优化与完善 | 修订版所有资源 |
| M12 | 最终审校与发布 | 正式出版教材+开源代码 |

---

## 📚 预期成果

### 1. 教材出版
- **主教材**：《水系统控制论：12个经典案例》（中文，400-500页）
- **配套教师手册**：含答案和教学建议（100页）
- **实验指导书**：硬件实验详细步骤（80页）

### 2. 开源资源
- **GitHub仓库**：完整代码（10000+ lines）
- **Jupyter Book**：在线交互式教材
- **YouTube/B站**：案例讲解视频（12集，每集30-40分钟）

### 3. 教学平台
- **Web虚拟实验平台**：支持500+并发用户
- **自动评分系统**：即时反馈学生作业

### 4. 学术产出
- 教学研究论文2-3篇
- 教改项目申报
- 精品课程/虚拟仿真项目申报

---

## ✅ 总结

本方案采用**案例驱动教学法**，以12个精心设计的水箱案例为主线，涵盖从入门到高级的完整知识体系。每个案例都是一个完整的工程故事，学生在解决实际问题中自然地学习控制理论，真正实现"做中学"。

### 核心优势
1. **渐进式难度**：从简单到复杂，符合认知规律
2. **完整知识链**：建模→仿真→辨识→控制→孪生→测试
3. **理实一体**：每个案例都有仿真和硬件实验
4. **开源共享**：惠及更多学习者
5. **工业相关**：案例源自真实工程问题

### 创新点
- 国内首个以单一对象（水箱）贯穿全教程的控制论教材
- 融合数字孪生、在环测试等前沿技术
- 提供完整的开源代码和虚拟实验平台
- 采用Jupyter Notebook交互式教学

**让我们一起开启水系统控制论的精彩之旅！** 🚀💧
