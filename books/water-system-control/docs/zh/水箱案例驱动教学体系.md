# æ°´ç³»ç»Ÿæ§åˆ¶è®ºæ¡ˆä¾‹é©±åŠ¨æ•™å­¦ä½“ç³»
## ä»¥12ä¸ªç»å…¸æ°´ç®±æ¡ˆä¾‹ä¸ºä¸»çº¿çš„ç†è®ºä¸å®è·µ

**åˆ¶å®šæ—¥æœŸï¼š** 2025-10-28  
**æ•™å­¦ç†å¿µï¼š** æ¡ˆä¾‹é©±åŠ¨å­¦ä¹ ï¼ˆCase-Based Learningï¼‰  
**æ ¸å¿ƒåŸåˆ™ï¼š** ä»é—®é¢˜å‡ºå‘ï¼Œåœ¨è§£å†³é—®é¢˜ä¸­å­¦ä¹ ç†è®º

---

## ğŸ“š æ•™å­¦è®¾è®¡ç†å¿µ

### æ¡ˆä¾‹é©±åŠ¨æ•™å­¦çš„ä¼˜åŠ¿

1. **æƒ…å¢ƒåŒ–å­¦ä¹ **ï¼šåœ¨çœŸå®å·¥ç¨‹æƒ…å¢ƒä¸­ç†è§£æŠ½è±¡æ¦‚å¿µ
2. **é—®é¢˜å¯¼å‘**ï¼šå¸¦ç€é—®é¢˜å­¦ä¹ ç†è®ºï¼Œå¢å¼ºå­¦ä¹ åŠ¨æœº
3. **æ¸è¿›å¼éš¾åº¦**ï¼šä»ç®€å•åˆ°å¤æ‚ï¼Œç¬¦åˆè®¤çŸ¥è§„å¾‹
4. **çŸ¥è¯†è¿ç§»**ï¼šé€šè¿‡ç³»åˆ—æ¡ˆä¾‹åŸ¹å…»ä¸¾ä¸€åä¸‰èƒ½åŠ›
5. **å·¥ç¨‹æ€ç»´**ï¼šåŸ¹å…»åˆ†æé—®é¢˜ã€å»ºæ¨¡ã€éªŒè¯ã€ä¼˜åŒ–çš„å®Œæ•´æ€ç»´é“¾

### æ¡ˆä¾‹è®¾è®¡åŸåˆ™

- **çœŸå®æ€§**ï¼šæ¡ˆä¾‹æºè‡ªçœŸå®å·¥ç¨‹é—®é¢˜
- **é€’è¿›æ€§**ï¼šæ¯ä¸ªæ¡ˆä¾‹åœ¨å‰ä¸€ä¸ªåŸºç¡€ä¸Šå¢åŠ æ–°çš„å¤æ‚åº¦
- **å®Œæ•´æ€§**ï¼šæ¯ä¸ªæ¡ˆä¾‹è¦†ç›–"é—®é¢˜â†’å»ºæ¨¡â†’ä»¿çœŸâ†’è¾¨è¯†â†’æ§åˆ¶â†’éªŒè¯"å…¨æµç¨‹
- **å¯æ“ä½œæ€§**ï¼šé…å¥—å®Œæ•´ä»£ç å’Œç¡¬ä»¶å®éªŒæŒ‡å¯¼
- **ç†è®ºæ·±åº¦**ï¼šæ¯ä¸ªæ¡ˆä¾‹å¯¹åº”2-3ä¸ªæ ¸å¿ƒç†è®ºçŸ¥è¯†ç‚¹

---

## ğŸ¯ 12ä¸ªç»å…¸æ°´ç®±æ¡ˆä¾‹ç³»ç»Ÿ

### ã€æ¡ˆä¾‹1ã€‘å®¶åº­æ°´å¡”è‡ªåŠ¨ä¾›æ°´ç³»ç»Ÿ â­
**éš¾åº¦ç­‰çº§ï¼š** å…¥é—¨  
**å·¥ç¨‹èƒŒæ™¯ï¼š** å†œæ‘å®¶åº­æ°´å¡”æ°´ä½è‡ªåŠ¨æ§åˆ¶

#### é—®é¢˜æè¿°
æŸå†œæ‘å®¶åº­å®‰è£…äº†å±‹é¡¶æ°´å¡”ï¼Œéœ€è¦è‡ªåŠ¨æ§åˆ¶æ°´æ³µï¼Œå½“æ°´ä½ä½äº2ç±³æ—¶å¯åŠ¨æ°´æ³µï¼Œé«˜äº2.5ç±³æ—¶åœæ­¢ï¼Œè¦æ±‚é¿å…é¢‘ç¹å¯åœã€‚

#### æ¶‰åŠç†è®º
- **å»ºæ¨¡**ï¼šä¸€é˜¶ç³»ç»Ÿä¼ é€’å‡½æ•° G(s) = K/(Ï„s+1)
- **æ§åˆ¶**ï¼šå¼€å…³æ§åˆ¶ï¼ˆOn-Off Controlï¼‰+ æ»ç¯ï¼ˆHysteresisï¼‰
- **åˆ†æ**ï¼šæ—¶é—´å¸¸æ•°çš„ç‰©ç†æ„ä¹‰ã€ç¨³æ€è¯¯å·®

#### å­¦ä¹ ç›®æ ‡
1. ç†è§£æ°´ç®±çš„è´¨é‡å®ˆæ’æ–¹ç¨‹ï¼šdV/dt = Q_in - Q_out
2. æŒæ¡çº¿æ€§åŒ–æ–¹æ³•ï¼šåœ¨å¹³è¡¡ç‚¹é™„è¿‘æ³°å‹’å±•å¼€
3. æ¨å¯¼ä¼ é€’å‡½æ•°ï¼šä»å¾®åˆ†æ–¹ç¨‹åˆ°æ‹‰æ™®æ‹‰æ–¯å˜æ¢
4. ç†è§£å¼€å…³æ§åˆ¶çš„ä¼˜ç¼ºç‚¹

#### å®éªŒå†…å®¹
- **ä»¿çœŸå®éªŒ1.1**ï¼šç»˜åˆ¶ä¸åŒæ—¶é—´å¸¸æ•°ä¸‹çš„é˜¶è·ƒå“åº”æ›²çº¿
- **ä»¿çœŸå®éªŒ1.2**ï¼šå¯¹æ¯”ä¸åŒæ»ç¯å®½åº¦å¯¹å¯åœæ¬¡æ•°çš„å½±å“
- **ç¡¬ä»¶å®éªŒ1.3**ï¼šæ­å»ºå•æ°´ç®±Arduinoæ§åˆ¶ç³»ç»Ÿ

#### ä»£ç ç»“æ„
```python
# case_01_home_water_tower/
â”œâ”€â”€ modeling.py              # å•æ°´ç®±å»ºæ¨¡
â”œâ”€â”€ on_off_control.py        # å¼€å…³æ§åˆ¶å™¨
â”œâ”€â”€ simulation.py            # ä»¿çœŸä¸»ç¨‹åº
â”œâ”€â”€ notebook_01.ipynb        # äº¤äº’å¼æ•™å­¦ç¬”è®°æœ¬
â””â”€â”€ arduino_code/            # ç¡¬ä»¶å®éªŒä»£ç 
    â””â”€â”€ on_off_controller.ino
```

#### å…¸å‹ç»“æœå±•ç¤º
- æ°´ä½-æ—¶é—´æ›²çº¿
- æ³µå¯åœåºåˆ—
- èƒ½è€—åˆ†æ

---

### ã€æ¡ˆä¾‹2ã€‘å·¥ä¸šå†·å´å¡”ç²¾ç¡®æ°´ä½æ§åˆ¶ â­â­
**éš¾åº¦ç­‰çº§ï¼š** åŸºç¡€  
**å·¥ç¨‹èƒŒæ™¯ï¼š** åŒ–å·¥å‚å†·å´å¡”æ°´ä½éœ€è¦ç²¾ç¡®ç»´æŒåœ¨3.0Â±0.1ç±³

#### é—®é¢˜æè¿°
å·¥ä¸šå†·å´å¡”è¦æ±‚æ°´ä½ç²¾ç¡®æ§åˆ¶ï¼Œå¼€å…³æ§åˆ¶å¯¼è‡´æ°´ä½æ³¢åŠ¨è¿‡å¤§ï¼Œéœ€è¦è®¾è®¡æ¯”ä¾‹æ§åˆ¶å™¨ï¼Œè¦æ±‚è¶…è°ƒé‡<5%ï¼Œè°ƒèŠ‚æ—¶é—´<30ç§’ã€‚

#### æ¶‰åŠç†è®º
- **æ§åˆ¶**ï¼šæ¯”ä¾‹æ§åˆ¶ï¼ˆPæ§åˆ¶ï¼‰ã€ç¨³æ€è¯¯å·®åˆ†æ
- **æ€§èƒ½æŒ‡æ ‡**ï¼šè¶…è°ƒé‡ã€ä¸Šå‡æ—¶é—´ã€è°ƒèŠ‚æ—¶é—´ã€ç¨³æ€è¯¯å·®
- **åˆ†æ**ï¼šæ ¹è½¨è¿¹æ³•åˆæ­¥ä»‹ç»

#### å­¦ä¹ ç›®æ ‡
1. ç†è§£æ¯”ä¾‹æ§åˆ¶åŸç†ï¼šu(t) = K_p * e(t)
2. æŒæ¡æ€§èƒ½æŒ‡æ ‡çš„è®¡ç®—å’Œæµ‹é‡æ–¹æ³•
3. åˆ†ææ¯”ä¾‹å¢ç›Šå¯¹ç³»ç»Ÿæ€§èƒ½çš„å½±å“
4. ç†è§£ç¨³æ€è¯¯å·®äº§ç”Ÿçš„åŸå› 

#### å®éªŒå†…å®¹
- **ä»¿çœŸå®éªŒ2.1**ï¼šä¸åŒK_pä¸‹çš„é˜¶è·ƒå“åº”å¯¹æ¯”
- **ä»¿çœŸå®éªŒ2.2**ï¼šæ€§èƒ½æŒ‡æ ‡è‡ªåŠ¨è®¡ç®—ç¨‹åº
- **ä»¿çœŸå®éªŒ2.3**ï¼šæ ¹è½¨è¿¹æ³•åˆ†æé—­ç¯æç‚¹ä½ç½®
- **ç¡¬ä»¶å®éªŒ2.4**ï¼šPWMè°ƒé€Ÿæ°´æ³µçš„æ¯”ä¾‹æ§åˆ¶

#### å…³é”®ä»£ç ç¤ºä¾‹
```python
class ProportionalController:
    def __init__(self, Kp, setpoint):
        self.Kp = Kp
        self.setpoint = setpoint
    
    def compute(self, measurement):
        error = self.setpoint - measurement
        output = self.Kp * error
        return np.clip(output, 0, 100)  # é™åˆ¶åœ¨0-100%

# æ€§èƒ½æŒ‡æ ‡è®¡ç®—
def calculate_performance_metrics(t, y, setpoint):
    """è®¡ç®—è¶…è°ƒé‡ã€ä¸Šå‡æ—¶é—´ã€è°ƒèŠ‚æ—¶é—´ã€ç¨³æ€è¯¯å·®"""
    # è¶…è°ƒé‡
    overshoot = (max(y) - setpoint) / setpoint * 100
    
    # ä¸Šå‡æ—¶é—´ï¼ˆ10%-90%ï¼‰
    idx_10 = np.where(y >= 0.1 * setpoint)[0][0]
    idx_90 = np.where(y >= 0.9 * setpoint)[0][0]
    rise_time = t[idx_90] - t[idx_10]
    
    # è°ƒèŠ‚æ—¶é—´ï¼ˆ2%è¯¯å·®å¸¦ï¼‰
    settling_band = 0.02 * setpoint
    settled_idx = np.where(np.abs(y - setpoint) <= settling_band)[0]
    if len(settled_idx) > 0:
        settling_time = t[settled_idx[0]]
    else:
        settling_time = np.inf
    
    # ç¨³æ€è¯¯å·®
    steady_state_error = abs(y[-1] - setpoint)
    
    return {
        'overshoot': overshoot,
        'rise_time': rise_time,
        'settling_time': settling_time,
        'steady_state_error': steady_state_error
    }
```

---

### ã€æ¡ˆä¾‹3ã€‘åŸå¸‚ä¾›æ°´æ³µç«™æ— é™å·®æ§åˆ¶ â­â­
**éš¾åº¦ç­‰çº§ï¼š** åŸºç¡€-ä¸­çº§  
**å·¥ç¨‹èƒŒæ™¯ï¼š** åŸå¸‚ä¾›æ°´äºŒçº§æ³µç«™è¦æ±‚æ°´ä½æ— é™å·®

#### é—®é¢˜æè¿°
ä¾›æ°´æ³µç«™å‘ç°æ¯”ä¾‹æ§åˆ¶å­˜åœ¨ç¨³æ€è¯¯å·®ï¼ˆè®¾å®š3.0ç±³ï¼Œå®é™…ç¨³å®šåœ¨2.85ç±³ï¼‰ï¼Œå½±å“ä¾›æ°´å‹åŠ›ã€‚éœ€è¦å¼•å…¥ç§¯åˆ†ä½œç”¨æ¶ˆé™¤ç¨³æ€è¯¯å·®ï¼Œä½†è¦é¿å…ç§¯åˆ†é¥±å’Œã€‚

#### æ¶‰åŠç†è®º
- **æ§åˆ¶**ï¼šPIæ§åˆ¶ã€ç§¯åˆ†é¥±å’Œä¸æŠ—é¥±å’ŒæŠ€æœ¯
- **åˆ†æ**ï¼šç¨³æ€è¯¯å·®å®šç†ã€Iå‹/IIå‹ç³»ç»Ÿ
- **é¢‘åŸŸ**ï¼šä¼¯å¾·å›¾åˆæ­¥ä»‹ç»

#### å­¦ä¹ ç›®æ ‡
1. ç†è§£ç§¯åˆ†ä½œç”¨æ¶ˆé™¤ç¨³æ€è¯¯å·®çš„åŸç†
2. æŒæ¡PIæ§åˆ¶å™¨è®¾è®¡ï¼šu(t) = K_p*e(t) + K_i*âˆ«e(t)dt
3. å­¦ä¹ æŠ—ç§¯åˆ†é¥±å’Œç­–ç•¥ï¼ˆæ¡ä»¶ç§¯åˆ†ã€ç§¯åˆ†åˆ†ç¦»ï¼‰
4. åˆæ­¥æ¥è§¦ä¼¯å¾·å›¾åˆ†æç¨³å®šè£•åº¦

#### å®éªŒå†…å®¹
- **ä»¿çœŸå®éªŒ3.1**ï¼šå¯¹æ¯”Pæ§åˆ¶å’ŒPIæ§åˆ¶çš„ç¨³æ€è¯¯å·®
- **ä»¿çœŸå®éªŒ3.2**ï¼šç§¯åˆ†é¥±å’Œç°è±¡æ¼”ç¤º
- **ä»¿çœŸå®éªŒ3.3**ï¼šä¸åŒæŠ—é¥±å’Œç­–ç•¥çš„æ•ˆæœå¯¹æ¯”
- **ä»¿çœŸå®éªŒ3.4**ï¼šä¼¯å¾·å›¾ç»˜åˆ¶ä¸å¢ç›Š/ç›¸ä½è£•åº¦åˆ†æ
- **ç¡¬ä»¶å®éªŒ3.5**ï¼šPIæ§åˆ¶å™¨çš„å®é™…è°ƒè¯•

#### æŠ—ç§¯åˆ†é¥±å’Œä»£ç ç¤ºä¾‹
```python
class PIControllerWithAntiWindup:
    def __init__(self, Kp, Ki, dt, output_limits=(-100, 100)):
        self.Kp = Kp
        self.Ki = Ki
        self.dt = dt
        self.output_limits = output_limits
        self.integral = 0
        
    def compute(self, error):
        # æ¯”ä¾‹é¡¹
        P = self.Kp * error
        
        # ç§¯åˆ†é¡¹ï¼ˆå…ˆè®¡ç®—ï¼‰
        self.integral += error * self.dt
        I = self.Ki * self.integral
        
        # æ€»è¾“å‡ºï¼ˆæœªé™å¹…ï¼‰
        output_raw = P + I
        
        # é™å¹…è¾“å‡º
        output = np.clip(output_raw, *self.output_limits)
        
        # æŠ—é¥±å’Œï¼šå¦‚æœè¾“å‡ºé¥±å’Œï¼Œå›é€€ç§¯åˆ†é¡¹
        if output != output_raw:
            # åå‘è®¡ç®—å…è®¸çš„ç§¯åˆ†å€¼
            allowed_I = output - P
            self.integral = allowed_I / self.Ki if self.Ki != 0 else 0
        
        return output
```

---

### ã€æ¡ˆä¾‹4ã€‘åŒæ°´ç®±ä¸²è”ç³»ç»Ÿçš„åŠ¨æ€å“åº” â­â­â­
**éš¾åº¦ç­‰çº§ï¼š** ä¸­çº§  
**å·¥ç¨‹èƒŒæ™¯ï¼š** æ±¡æ°´å¤„ç†å‚çš„ä¸¤çº§æ²‰æ·€æ± æ°´ä½æ§åˆ¶

#### é—®é¢˜æè¿°
æ±¡æ°´å¤„ç†å‚æœ‰ä¸¤ä¸ªä¸²è”çš„æ²‰æ·€æ± ï¼Œä¸Šæ¸¸æ± é€šè¿‡é˜€é—¨å‘ä¸‹æ¸¸æ± æ”¾æ°´ã€‚å‘ç°æ§åˆ¶ä¸‹æ¸¸æ± æ°´ä½æ—¶ï¼Œå“åº”æ˜æ˜¾æ¯”å•æ± æ…¢ï¼Œä¸”æœ‰æŒ¯è¡ã€‚éœ€è¦åˆ†æäºŒé˜¶ç³»ç»Ÿç‰¹æ€§ã€‚

#### æ¶‰åŠç†è®º
- **å»ºæ¨¡**ï¼šå¤šæ°´ç®±è€¦åˆç³»ç»Ÿå»ºæ¨¡ã€äºŒé˜¶ç³»ç»Ÿä¼ é€’å‡½æ•°
- **åˆ†æ**ï¼šé˜»å°¼æ¯”Î¶ã€è‡ªç„¶é¢‘ç‡Ï‰_nã€æç‚¹ä½ç½®ä¸åŠ¨æ€å“åº”çš„å…³ç³»
- **æ§åˆ¶**ï¼šPIDæ§åˆ¶å™¨å®Œæ•´è®¾è®¡ã€Ziegler-Nicholsæ•´å®šæ³•

#### å­¦ä¹ ç›®æ ‡
1. æ¨å¯¼åŒæ°´ç®±ä¸²è”ç³»ç»Ÿçš„ä¼ é€’å‡½æ•° G(s) = K/(sÂ²+2Î¶Ï‰_nÂ·s+Ï‰_nÂ²)
2. ç†è§£é˜»å°¼æ¯”å¯¹å“åº”ç‰¹æ€§çš„å½±å“ï¼ˆæ¬ é˜»å°¼/ä¸´ç•Œé˜»å°¼/è¿‡é˜»å°¼ï¼‰
3. æŒæ¡PIDä¸‰é¡¹ä½œç”¨çš„åè°ƒé…åˆ
4. å­¦ä¹ ç»å…¸çš„Ziegler-Nicholsæ•´å®šæ³•

#### å®éªŒå†…å®¹
- **ä»¿çœŸå®éªŒ4.1**ï¼šåŒæ°´ç®±ç³»ç»Ÿå»ºæ¨¡ä¸éªŒè¯
- **ä»¿çœŸå®éªŒ4.2**ï¼šä¸åŒé˜»å°¼æ¯”ä¸‹çš„é˜¶è·ƒå“åº”ï¼ˆÎ¶=0.3, 0.7, 1.0, 1.5ï¼‰
- **ä»¿çœŸå®éªŒ4.3**ï¼šå¾®åˆ†ä½œç”¨å¯¹æŒ¯è¡çš„æŠ‘åˆ¶æ•ˆæœ
- **ä»¿çœŸå®éªŒ4.4**ï¼šZiegler-Nicholsä¸´ç•Œå¢ç›Šæ³•æ•´å®š
- **ä»¿çœŸå®éªŒ4.5**ï¼šPIDä¸‰é¡¹ä½œç”¨çš„å¯è§†åŒ–è§£æ
- **ç¡¬ä»¶å®éªŒ4.6**ï¼šåŒæ°´ç®±ç‰©ç†è£…ç½®å®éªŒ

#### åŒæ°´ç®±å»ºæ¨¡ä»£ç 
```python
class DoubleTankCascade:
    """åŒæ°´ç®±ä¸²è”ç³»ç»Ÿ"""
    
    def __init__(self, A1=0.5, A2=0.5, R1=2.0, R2=2.0, K=1.0):
        """
        A1, A2: ä¸Šä¸‹æ°´ç®±æ¨ªæˆªé¢ç§¯ [mÂ²]
        R1: ä¸Šæ°´ç®±å‡ºå£é˜»åŠ› [s/mÂ²]
        R2: ä¸‹æ°´ç®±å‡ºå£é˜»åŠ› [s/mÂ²]
        K: æ³µå¢ç›Š [mÂ³/s/V]
        """
        self.A1 = A1
        self.A2 = A2
        self.R1 = R1
        self.R2 = R2
        self.K = K
        
        # æ—¶é—´å¸¸æ•°
        self.tau1 = A1 * R1
        self.tau2 = A2 * R2
        
    def get_transfer_function(self):
        """
        ä¼ é€’å‡½æ•°ï¼ˆh2ç›¸å¯¹äºuï¼‰ï¼š
        G(s) = (K*R1*R2) / [(Ï„1Â·s+1)(Ï„2Â·s+1)]
              = K_static / (Ï„1Â·Ï„2Â·sÂ² + (Ï„1+Ï„2)Â·s + 1)
        """
        num = [self.K * self.R1 * self.R2]
        den = [self.tau1 * self.tau2, self.tau1 + self.tau2, 1]
        return control.TransferFunction(num, den)
    
    def get_natural_freq_damping(self):
        """è®¡ç®—ç­‰æ•ˆçš„è‡ªç„¶é¢‘ç‡å’Œé˜»å°¼æ¯”"""
        omega_n = 1 / np.sqrt(self.tau1 * self.tau2)
        zeta = (self.tau1 + self.tau2) / (2 * np.sqrt(self.tau1 * self.tau2))
        return omega_n, zeta
    
    def state_space_model(self):
        """çŠ¶æ€ç©ºé—´è¡¨ç¤º
        çŠ¶æ€å˜é‡: x1=h1 (ä¸Šæ°´ç®±æ°´ä½), x2=h2 (ä¸‹æ°´ç®±æ°´ä½)
        """
        A = np.array([
            [-1/self.tau1, 0],
            [self.R1/self.A2, -1/self.tau2]
        ])
        B = np.array([[self.K/self.A1], [0]])
        C = np.array([[0, 1]])  # åªæµ‹é‡ä¸‹æ°´ç®±æ°´ä½
        D = np.array([[0]])
        
        return A, B, C, D
```

#### Ziegler-Nicholsæ•´å®šæ³•å®ç°
```python
def ziegler_nichols_tuning(plant, method='ultimate_gain'):
    """Ziegler-Nichols PIDæ•´å®š
    
    Args:
        plant: è¢«æ§å¯¹è±¡ä¼ é€’å‡½æ•°
        method: 'ultimate_gain' (ä¸´ç•Œå¢ç›Šæ³•) æˆ– 'reaction_curve' (ååº”æ›²çº¿æ³•)
    
    Returns:
        Kp, Ki, Kd: PIDå‚æ•°
    """
    if method == 'ultimate_gain':
        # 1. æ‰¾åˆ°ä¸´ç•Œå¢ç›ŠKuï¼ˆç³»ç»Ÿå¼€å§‹æŒç»­æŒ¯è¡çš„å¢ç›Šï¼‰
        # é€šè¿‡äºŒåˆ†æ³•æœç´¢
        Ku = find_ultimate_gain(plant)
        
        # 2. æµ‹é‡ä¸´ç•Œå‘¨æœŸTu
        Tu = find_oscillation_period(plant, Ku)
        
        # 3. æ ¹æ®ZNç»éªŒå…¬å¼è®¡ç®—PIDå‚æ•°
        Kp = 0.6 * Ku
        Ki = Kp / (0.5 * Tu)
        Kd = Kp * (0.125 * Tu)
        
        return Kp, Ki, Kd
    
    elif method == 'reaction_curve':
        # ååº”æ›²çº¿æ³•ï¼ˆé€‚ç”¨äºæ— ç§¯åˆ†ç¯èŠ‚çš„ç³»ç»Ÿï¼‰
        # æ–½åŠ é˜¶è·ƒè¾“å…¥ï¼Œæµ‹é‡å“åº”æ›²çº¿
        t, y = control.step_response(plant)
        
        # æ‰¾åˆ°æ‹ç‚¹åˆ‡çº¿
        L, T = find_tangent_parameters(t, y)  # L=å»¶è¿Ÿæ—¶é—´ï¼ŒT=æ—¶é—´å¸¸æ•°
        K = y[-1]  # é™æ€å¢ç›Š
        
        # ZNå…¬å¼
        Kp = 1.2 * T / (K * L)
        Ki = Kp / (2 * L)
        Kd = Kp * 0.5 * L
        
        return Kp, Ki, Kd
```

---

### ã€æ¡ˆä¾‹5ã€‘å¤šæ°´ç®±ç½‘ç»œçš„çŠ¶æ€ç©ºé—´å»ºæ¨¡ â­â­â­
**éš¾åº¦ç­‰çº§ï¼š** ä¸­çº§  
**å·¥ç¨‹èƒŒæ™¯ï¼š** æ°´å¤„ç†å‚å¤šçº§å¤„ç†æ± çš„ååŒæ§åˆ¶

#### é—®é¢˜æè¿°
æŸæ°´å‚æœ‰4ä¸ªç›¸äº’è¿æ¥çš„å¤„ç†æ± ï¼ˆ2ä¸ªä¸²è”ï¼Œ2ä¸ªå¹¶è”ï¼‰ï¼Œéœ€è¦åŒæ—¶æ§åˆ¶å¤šä¸ªæ°´ä½ã€‚ä¼ é€’å‡½æ•°æ–¹æ³•å˜å¾—å¤æ‚ï¼Œå¼•å…¥çŠ¶æ€ç©ºé—´æ–¹æ³•ã€‚

#### æ¶‰åŠç†è®º
- **å»ºæ¨¡**ï¼šMIMOç³»ç»Ÿçš„çŠ¶æ€ç©ºé—´å»ºæ¨¡ã€çŠ¶æ€å˜é‡é€‰æ‹©
- **åˆ†æ**ï¼šå¯æ§æ€§ï¼ˆControllabilityï¼‰ã€å¯è§‚æµ‹æ€§ï¼ˆObservabilityï¼‰
- **çº¿æ€§ä»£æ•°**ï¼šç‰¹å¾å€¼ã€ç‰¹å¾å‘é‡ã€æ¨¡æ€åˆ†è§£
- **ä»¿çœŸ**ï¼šçŠ¶æ€ç©ºé—´æ¨¡å‹çš„æ•°å€¼æ±‚è§£

#### å­¦ä¹ ç›®æ ‡
1. ç†è§£çŠ¶æ€ç©ºé—´è¡¨ç¤ºï¼šdx/dt = Ax + Bu, y = Cx + D
2. æŒæ¡å¯æ§æ€§çŸ©é˜µå’Œå¯è§‚æµ‹æ€§çŸ©é˜µçš„è®¡ç®—
3. ç†è§£çŠ¶æ€å˜é‡çš„ç‰©ç†æ„ä¹‰
4. å­¦ä¹ çŸ©é˜µæŒ‡æ•°e^(At)çš„è®¡ç®—

#### å®éªŒå†…å®¹
- **ä»¿çœŸå®éªŒ5.1**ï¼š4æ°´ç®±ç³»ç»Ÿçš„çŠ¶æ€ç©ºé—´å»ºæ¨¡
- **ä»¿çœŸå®éªŒ5.2**ï¼šå¯æ§æ€§å’Œå¯è§‚æµ‹æ€§åˆ¤åˆ«
- **ä»¿çœŸå®éªŒ5.3**ï¼šæ¨¡æ€åˆ†æä¸ä¸»å¯¼æç‚¹
- **ä»¿çœŸå®éªŒ5.4**ï¼šçŠ¶æ€ç©ºé—´ä¸ä¼ é€’å‡½æ•°çš„è½¬æ¢
- **ä»¿çœŸå®éªŒ5.5**ï¼šä¸åŒåˆå§‹çŠ¶æ€ä¸‹çš„ç³»ç»Ÿå“åº”

#### å¤šæ°´ç®±ç½‘ç»œå»ºæ¨¡
```python
class MultiTankNetwork:
    """å¤šæ°´ç®±ç½‘ç»œç³»ç»Ÿï¼ˆæ‹“æ‰‘å¯é…ç½®ï¼‰"""
    
    def __init__(self, config):
        """
        config: å­—å…¸ï¼Œå®šä¹‰æ°´ç®±å‚æ•°å’Œè¿æ¥å…³ç³»
        ä¾‹å¦‚ï¼š
        {
            'tanks': [
                {'id': 1, 'A': 0.5, 'R_out': 2.0},
                {'id': 2, 'A': 0.5, 'R_out': 2.0},
                ...
            ],
            'connections': [
                {'from': 1, 'to': 2, 'R': 1.5},  # æ°´ç®±1é€šè¿‡é˜»åŠ›Ræµå‘æ°´ç®±2
                ...
            ],
            'pumps': [
                {'to': 1, 'K': 1.0},  # æ³µå…¥æ°´ç®±1ï¼Œå¢ç›ŠK
                ...
            ]
        }
        """
        self.config = config
        self.n_tanks = len(config['tanks'])
        self.A, self.B, self.C = self._build_state_space()
    
    def _build_state_space(self):
        """æ„å»ºçŠ¶æ€ç©ºé—´çŸ©é˜µ"""
        n = self.n_tanks
        A = np.zeros((n, n))
        B = np.zeros((n, len(self.config['pumps'])))
        C = np.eye(n)  # å‡è®¾æ‰€æœ‰çŠ¶æ€éƒ½å¯æµ‹
        
        # æ„å»ºAçŸ©é˜µï¼ˆæ°´ç®±é—´çš„è€¦åˆï¼‰
        for i, tank in enumerate(self.config['tanks']):
            # è‡ªèº«çš„æµå‡º
            A[i, i] = -1 / (tank['A'] * tank['R_out'])
        
        for conn in self.config['connections']:
            from_idx = conn['from'] - 1  # ç´¢å¼•ä»0å¼€å§‹
            to_idx = conn['to'] - 1
            R = conn['R']
            A_from = self.config['tanks'][from_idx]['A']
            A_to = self.config['tanks'][to_idx]['A']
            
            # fromæ°´ç®±çš„æµå‡º
            A[from_idx, from_idx] -= 1 / (A_from * R)
            # toæ°´ç®±çš„æµå…¥
            A[to_idx, from_idx] += 1 / (A_to * R)
        
        # æ„å»ºBçŸ©é˜µï¼ˆæ³µçš„è¾“å…¥ï¼‰
        for j, pump in enumerate(self.config['pumps']):
            to_idx = pump['to'] - 1
            A_to = self.config['tanks'][to_idx]['A']
            B[to_idx, j] = pump['K'] / A_to
        
        return A, B, C
    
    def check_controllability(self):
        """æ£€æŸ¥å¯æ§æ€§"""
        n = self.A.shape[0]
        m = self.B.shape[1]
        
        # å¯æ§æ€§çŸ©é˜µ [B, AB, AÂ²B, ..., A^(n-1)B]
        controllability_matrix = np.zeros((n, n * m))
        for i in range(n):
            controllability_matrix[:, i*m:(i+1)*m] = np.linalg.matrix_power(self.A, i) @ self.B
        
        rank = np.linalg.matrix_rank(controllability_matrix)
        return rank == n, rank
    
    def check_observability(self):
        """æ£€æŸ¥å¯è§‚æµ‹æ€§"""
        n = self.A.shape[0]
        p = self.C.shape[0]
        
        # å¯è§‚æµ‹æ€§çŸ©é˜µ [C; CA; CAÂ²; ...; CA^(n-1)]
        observability_matrix = np.zeros((n * p, n))
        for i in range(n):
            observability_matrix[i*p:(i+1)*p, :] = self.C @ np.linalg.matrix_power(self.A, i)
        
        rank = np.linalg.matrix_rank(observability_matrix)
        return rank == n, rank
```

---

### ã€æ¡ˆä¾‹6ã€‘å®é™…æ°´ç®±ç³»ç»Ÿçš„å‚æ•°è¾¨è¯† â­â­â­
**éš¾åº¦ç­‰çº§ï¼š** ä¸­çº§-é«˜çº§  
**å·¥ç¨‹èƒŒæ™¯ï¼š** å·²æœ‰æ°´ç®±ç³»ç»Ÿï¼Œå‚æ•°æœªçŸ¥ï¼Œéœ€è¦é€šè¿‡å®éªŒæ•°æ®è¾¨è¯†

#### é—®é¢˜æè¿°
å·¥å‚æœ‰ä¸€ä¸ªè€æ—§çš„æ°´ç®±ç³»ç»Ÿï¼Œæ²¡æœ‰è®¾è®¡å›¾çº¸ï¼Œéœ€è¦é€šè¿‡è¾“å…¥-è¾“å‡ºæ•°æ®è¾¨è¯†ç³»ç»Ÿå‚æ•°ï¼ˆæ—¶é—´å¸¸æ•°Ï„ã€å¢ç›ŠKï¼‰ï¼Œä»¥ä¾¿è®¾è®¡æ§åˆ¶å™¨ã€‚

#### æ¶‰åŠç†è®º
- **è¾¨è¯†**ï¼šæœ€å°äºŒä¹˜æ³•ï¼ˆLSï¼‰ã€é€’æ¨æœ€å°äºŒä¹˜ï¼ˆRLSï¼‰
- **ä¿¡å·**ï¼šæ¿€åŠ±ä¿¡å·è®¾è®¡ï¼ˆé˜¶è·ƒã€PRBSã€æ‰«é¢‘ï¼‰
- **ç»Ÿè®¡**ï¼šå‚æ•°ç½®ä¿¡åŒºé—´ã€æ¨¡å‹éªŒè¯ï¼ˆRÂ²ã€AICã€BICï¼‰
- **é¢‘åŸŸè¾¨è¯†**ï¼šé¢‘ç‡å“åº”å‡½æ•°ä¼°è®¡

#### å­¦ä¹ ç›®æ ‡
1. ç†è§£ç³»ç»Ÿè¾¨è¯†çš„åŸºæœ¬æµç¨‹
2. æŒæ¡æœ€å°äºŒä¹˜æ³•çš„åŸç†å’Œå®ç°
3. å­¦ä¹ è®¾è®¡åˆé€‚çš„æ¿€åŠ±ä¿¡å·
4. ç†è§£æ¨¡å‹éªŒè¯çš„é‡è¦æ€§

#### å®éªŒå†…å®¹
- **ä»¿çœŸå®éªŒ6.1**ï¼šä»ä»¿çœŸæ•°æ®è¾¨è¯†å•æ°´ç®±å‚æ•°
- **ä»¿çœŸå®éªŒ6.2**ï¼šå™ªå£°å¯¹è¾¨è¯†ç²¾åº¦çš„å½±å“
- **ä»¿çœŸå®éªŒ6.3**ï¼šä¸åŒæ¿€åŠ±ä¿¡å·çš„å¯¹æ¯”ï¼ˆé˜¶è·ƒ vs PRBSï¼‰
- **ä»¿çœŸå®éªŒ6.4**ï¼šé€’æ¨æœ€å°äºŒä¹˜åœ¨çº¿è¾¨è¯†
- **ä»¿çœŸå®éªŒ6.5**ï¼šé¢‘åŸŸè¾¨è¯†æ–¹æ³•
- **ç¡¬ä»¶å®éªŒ6.6**ï¼šçœŸå®æ°´ç®±ç³»ç»Ÿçš„å‚æ•°è¾¨è¯†

#### ç³»ç»Ÿè¾¨è¯†å®Œæ•´æµç¨‹
```python
class SystemIdentification:
    """ç³»ç»Ÿè¾¨è¯†å·¥å…·ç±»"""
    
    @staticmethod
    def design_prbs_input(duration, dt, amplitude=1.0, bit_length=5):
        """è®¾è®¡ä¼ªéšæœºäºŒè¿›åˆ¶åºåˆ—(PRBS)æ¿€åŠ±ä¿¡å·"""
        from scipy.signal import max_len_seq
        
        # ç”ŸæˆPRBSåºåˆ—
        n_bits = int(duration / (dt * bit_length))
        prbs_bits, _ = max_len_seq(8, length=n_bits)  # 8é˜¶LFSR
        
        # è½¬æ¢ä¸ºè¿ç»­ä¿¡å·
        t = np.arange(0, duration, dt)
        u = np.zeros_like(t)
        
        for i in range(len(t)):
            bit_idx = int(i / bit_length) % len(prbs_bits)
            u[i] = amplitude if prbs_bits[bit_idx] else -amplitude
        
        return t, u
    
    @staticmethod
    def least_squares_arx(y, u, na=1, nb=1, nk=0):
        """
        ARXæ¨¡å‹è¾¨è¯†ï¼šA(q)y(t) = B(q)u(t-nk) + e(t)
        
        Args:
            y: è¾“å‡ºæ•°æ®
            u: è¾“å…¥æ•°æ®
            na: Aå¤šé¡¹å¼é˜¶æ•°
            nb: Bå¤šé¡¹å¼é˜¶æ•°
            nk: å»¶è¿Ÿæ­¥æ•°
        
        Returns:
            a_coeffs: Aå¤šé¡¹å¼ç³»æ•° [a1, a2, ..., ana]
            b_coeffs: Bå¤šé¡¹å¼ç³»æ•° [b0, b1, ..., bnb]
        """
        N = len(y)
        max_order = max(na, nb + nk)
        
        # æ„å»ºå›å½’çŸ©é˜µ
        Phi = np.zeros((N - max_order, na + nb + 1))
        Y = y[max_order:]
        
        for i in range(N - max_order):
            idx = i + max_order
            
            # Aå¤šé¡¹å¼çš„é¡¹ (è¿‡å»çš„è¾“å‡º)
            for j in range(na):
                Phi[i, j] = -y[idx - j - 1]
            
            # Bå¤šé¡¹å¼çš„é¡¹ (è¿‡å»çš„è¾“å…¥)
            for j in range(nb + 1):
                if idx - nk - j >= 0:
                    Phi[i, na + j] = u[idx - nk - j]
        
        # æœ€å°äºŒä¹˜æ±‚è§£
        theta = np.linalg.lstsq(Phi, Y, rcond=None)[0]
        
        a_coeffs = theta[:na]
        b_coeffs = theta[na:]
        
        return a_coeffs, b_coeffs
    
    @staticmethod
    def convert_arx_to_transfer_function(a_coeffs, b_coeffs, dt):
        """å°†ARXæ¨¡å‹è½¬æ¢ä¸ºä¼ é€’å‡½æ•°"""
        # ç¦»æ•£ä¼ é€’å‡½æ•°
        num_z = b_coeffs
        den_z = np.concatenate(([1], a_coeffs))
        
        # è½¬æ¢ä¸ºè¿ç»­æ—¶é—´ï¼ˆåŒçº¿æ€§å˜æ¢ï¼‰
        sys_discrete = control.TransferFunction(num_z, den_z, dt)
        sys_continuous = control.sample_system(sys_discrete, dt, method='tustin')
        
        return sys_continuous
    
    @staticmethod
    def validate_model(y_true, y_pred):
        """æ¨¡å‹éªŒè¯æŒ‡æ ‡"""
        # RÂ² (å†³å®šç³»æ•°)
        ss_res = np.sum((y_true - y_pred) ** 2)
        ss_tot = np.sum((y_true - np.mean(y_true)) ** 2)
        r_squared = 1 - (ss_res / ss_tot)
        
        # FIT (æ‹Ÿåˆç™¾åˆ†æ¯”)
        fit_percent = (1 - np.linalg.norm(y_true - y_pred) / np.linalg.norm(y_true - np.mean(y_true))) * 100
        
        # RMSE (å‡æ–¹æ ¹è¯¯å·®)
        rmse = np.sqrt(np.mean((y_true - y_pred) ** 2))
        
        # NRMSE (å½’ä¸€åŒ–RMSE)
        nrmse = rmse / (np.max(y_true) - np.min(y_true))
        
        return {
            'RÂ²': r_squared,
            'FIT': fit_percent,
            'RMSE': rmse,
            'NRMSE': nrmse
        }
```

#### å®Œæ•´è¾¨è¯†å®éªŒç¤ºä¾‹
```python
def complete_identification_experiment():
    """å®Œæ•´çš„è¾¨è¯†å®éªŒæµç¨‹"""
    
    # 1. çœŸå®ç³»ç»Ÿï¼ˆæœªçŸ¥å‚æ•°ï¼‰
    true_system = SingleTank(A=0.5, R=2.5, K=1.2)  # çœŸå®å‚æ•°æœªçŸ¥
    
    # 2. è®¾è®¡æ¿€åŠ±ä¿¡å·
    duration = 200
    dt = 0.1
    t, u = SystemIdentification.design_prbs_input(duration, dt, amplitude=2.0)
    
    # 3. é‡‡é›†è¾“å…¥-è¾“å‡ºæ•°æ®ï¼ˆæ¨¡æ‹ŸçœŸå®å®éªŒï¼‰
    y = np.zeros_like(t)
    x = 0  # åˆå§‹æ°´ä½
    
    for i in range(1, len(t)):
        # ç³»ç»ŸåŠ¨æ€
        Q_in = true_system.K * u[i-1]
        Q_out = x / true_system.R if x > 0 else 0
        dx = (Q_in - Q_out) / true_system.A
        x = x + dx * dt
        
        # æ·»åŠ æµ‹é‡å™ªå£°
        y[i] = x + np.random.normal(0, 0.05)
    
    # 4. æ•°æ®é¢„å¤„ç†ï¼ˆå»é™¤åˆå§‹ç¬æ€ï¼‰
    t_train = t[500:]
    u_train = u[500:]
    y_train = y[500:]
    
    # 5. è¾¨è¯†ï¼ˆARXæ¨¡å‹ï¼‰
    a_coeffs, b_coeffs = SystemIdentification.least_squares_arx(
        y_train, u_train, na=1, nb=1, nk=1
    )
    
    # 6. è½¬æ¢ä¸ºä¼ é€’å‡½æ•°
    sys_identified = SystemIdentification.convert_arx_to_transfer_function(
        a_coeffs, b_coeffs, dt
    )
    
    # 7. æ¨¡å‹éªŒè¯ï¼ˆç”¨å¦ä¸€æ®µæ•°æ®ï¼‰
    t_test, u_test = SystemIdentification.design_prbs_input(100, dt, amplitude=1.5)
    _, y_test_true = true_system.simulate(t_test, u_test)
    _, y_test_pred = control.forced_response(sys_identified, t_test, u_test)
    
    metrics = SystemIdentification.validate_model(y_test_true, y_test_pred)
    
    # 8. ç»“æœå±•ç¤º
    print(f"è¾¨è¯†å‚æ•°: K={b_coeffs[0]/b_coeffs[1]:.3f}, Ï„={-1/a_coeffs[0]:.3f}")
    print(f"çœŸå®å‚æ•°: K={true_system.gain:.3f}, Ï„={true_system.tau:.3f}")
    print(f"éªŒè¯æŒ‡æ ‡: RÂ²={metrics['RÂ²']:.4f}, FIT={metrics['FIT']:.2f}%")
    
    # ç»˜å›¾å¯¹æ¯”
    plt.figure(figsize=(12, 8))
    
    plt.subplot(3, 1, 1)
    plt.plot(t_train, u_train)
    plt.ylabel('Input (u)')
    plt.title('Identification Data')
    plt.grid()
    
    plt.subplot(3, 1, 2)
    plt.plot(t_train, y_train, label='Measured')
    plt.ylabel('Output (y)')
    plt.legend()
    plt.grid()
    
    plt.subplot(3, 1, 3)
    plt.plot(t_test, y_test_true, label='True System', linewidth=2)
    plt.plot(t_test, y_test_pred, '--', label='Identified Model')
    plt.xlabel('Time (s)')
    plt.ylabel('Output (y)')
    plt.title(f"Model Validation (RÂ²={metrics['RÂ²']:.4f})")
    plt.legend()
    plt.grid()
    
    plt.tight_layout()
    plt.show()
```

---

### ã€æ¡ˆä¾‹7ã€‘æ°´ç®±ç³»ç»Ÿçš„æ•°å­—å­ªç”Ÿå¹³å° â­â­â­â­
**éš¾åº¦ç­‰çº§ï¼š** é«˜çº§  
**å·¥ç¨‹èƒŒæ™¯ï¼š** å»ºç«‹æ°´ç®±ç³»ç»Ÿçš„æ•°å­—å­ªç”Ÿï¼Œå®ç°è™šå®åŒæ­¥å’Œé¢„æµ‹æ€§ç»´æŠ¤

#### é—®é¢˜æè¿°
å·¥å‚å¸Œæœ›å»ºç«‹æ°´ç®±ç³»ç»Ÿçš„æ•°å­—å­ªç”Ÿï¼Œå®æ—¶åŒæ­¥ç‰©ç†ç³»ç»ŸçŠ¶æ€ï¼Œé¢„æµ‹æœªæ¥30åˆ†é’Ÿçš„æ°´ä½å˜åŒ–ï¼Œå¹¶åœ¨ä¼ æ„Ÿå™¨æ•…éšœæ—¶æä¾›è½¯æµ‹é‡å€¼ã€‚

#### æ¶‰åŠç†è®º
- **æ•°å­—å­ªç”Ÿ**ï¼šäº”ç»´æ¨¡å‹ï¼ˆç‰©ç†å®ä½“ã€è™šæ‹Ÿæ¨¡å‹ã€æ•°æ®ã€æœåŠ¡ã€è¿æ¥ï¼‰
- **æ»¤æ³¢**ï¼šå¡å°”æ›¼æ»¤æ³¢å™¨ï¼ˆKalman Filterï¼‰ã€æ‰©å±•å¡å°”æ›¼æ»¤æ³¢ï¼ˆEKFï¼‰
- **æ•…éšœè¯Šæ–­**ï¼šæ®‹å·®ç”Ÿæˆã€é˜ˆå€¼è®¾è®¡ã€æ•…éšœéš”ç¦»
- **é¢„æµ‹**ï¼šåŸºäºæ¨¡å‹çš„çŸ­æœŸé¢„æµ‹

#### å­¦ä¹ ç›®æ ‡
1. ç†è§£æ•°å­—å­ªç”Ÿçš„æ¶æ„å’Œå…³é”®æŠ€æœ¯
2. æŒæ¡å¡å°”æ›¼æ»¤æ³¢å™¨çš„è®¾è®¡å’Œå®ç°
3. å­¦ä¹ æ•…éšœæ£€æµ‹ä¸éš”ç¦»ï¼ˆFDIï¼‰æ–¹æ³•
4. ç†è§£åœ¨çº¿æ¨¡å‹æ ¡å‡†çš„å¿…è¦æ€§

#### å®éªŒå†…å®¹
- **ä»¿çœŸå®éªŒ7.1**ï¼šæ•°å­—å­ªç”Ÿç³»ç»Ÿæ¶æ„æ­å»º
- **ä»¿çœŸå®éªŒ7.2**ï¼šå¡å°”æ›¼æ»¤æ³¢å™¨çŠ¶æ€ä¼°è®¡
- **ä»¿çœŸå®éªŒ7.3**ï¼šä¼ æ„Ÿå™¨æ•…éšœæ£€æµ‹
- **ä»¿çœŸå®éªŒ7.4**ï¼šæ¨¡å‹å‚æ•°åœ¨çº¿æ ¡å‡†
- **ä»¿çœŸå®éªŒ7.5**ï¼šåŸºäºå­ªç”Ÿæ¨¡å‹çš„çŸ­æœŸé¢„æµ‹
- **ç¡¬ä»¶å®éªŒ7.6**ï¼šçœŸå®æ°´ç®±ç³»ç»Ÿçš„æ•°å­—å­ªç”Ÿé›†æˆ

#### æ•°å­—å­ªç”Ÿç³»ç»Ÿå®ç°
```python
class WaterTankDigitalTwin:
    """æ°´ç®±ç³»ç»Ÿæ•°å­—å­ªç”Ÿ"""
    
    def __init__(self, physical_system, model_params):
        """
        Args:
            physical_system: ç‰©ç†ç³»ç»Ÿæ¥å£ï¼ˆä¼ æ„Ÿå™¨ã€æ‰§è¡Œå™¨ï¼‰
            model_params: åˆå§‹æ¨¡å‹å‚æ•° {'A': 0.5, 'R': 2.0, 'K': 1.0}
        """
        self.physical = physical_system
        self.model = SingleTank(**model_params)
        
        # å¡å°”æ›¼æ»¤æ³¢å™¨
        self.kf = self._initialize_kalman_filter()
        
        # çŠ¶æ€å†å²
        self.state_history = []
        self.time_history = []
        
        # æ•…éšœæ£€æµ‹
        self.residual_buffer = deque(maxlen=50)
        self.fault_threshold = 0.2
    
    def _initialize_kalman_filter(self):
        """åˆå§‹åŒ–å¡å°”æ›¼æ»¤æ³¢å™¨"""
        # çŠ¶æ€: [h, K, tau] (æ°´ä½ + å‚æ•°)
        dt = 0.1
        
        # çŠ¶æ€è½¬ç§»çŸ©é˜µï¼ˆæ‰©å±•å¡å°”æ›¼æ»¤æ³¢ï¼Œçº¿æ€§åŒ–ï¼‰
        A = np.array([
            [1 - dt/(self.model.tau), 0, 0],
            [0, 1, 0],  # Kæ˜¯å¸¸æ•°
            [0, 0, 1]   # tauæ˜¯å¸¸æ•°
        ])
        
        # æ§åˆ¶è¾“å…¥çŸ©é˜µ
        B = np.array([[dt * self.model.K / self.model.A], [0], [0]])
        
        # è§‚æµ‹çŸ©é˜µ
        C = np.array([[1, 0, 0]])  # åªè§‚æµ‹æ°´ä½
        
        # å™ªå£°åæ–¹å·®
        Q = np.diag([0.01, 0.001, 0.001])  # è¿‡ç¨‹å™ªå£°
        R = np.array([[0.05]])  # æµ‹é‡å™ªå£°
        
        # åˆå§‹çŠ¶æ€å’Œåæ–¹å·®
        x0 = np.array([2.0, self.model.K, self.model.tau])
        P0 = np.eye(3) * 0.1
        
        return KalmanFilter(A, B, C, Q, R, x0, P0)
    
    def sync_step(self, u, dt=0.1):
        """
        æ‰§è¡Œä¸€æ­¥è™šå®åŒæ­¥
        
        Args:
            u: æ§åˆ¶è¾“å…¥
            dt: æ—¶é—´æ­¥é•¿
        
        Returns:
            twin_state: å­ªç”Ÿæ¨¡å‹ä¼°è®¡çš„çŠ¶æ€
            physical_measurement: ç‰©ç†ç³»ç»Ÿæµ‹é‡å€¼
            fault_detected: æ˜¯å¦æ£€æµ‹åˆ°æ•…éšœ
        """
        # 1. ä»ç‰©ç†ç³»ç»Ÿè·å–æµ‹é‡å€¼
        physical_measurement = self.physical.read_level_sensor()
        
        # 2. å¡å°”æ›¼æ»¤æ³¢å™¨é¢„æµ‹
        self.kf.predict(u)
        
        # 3. å¡å°”æ›¼æ»¤æ³¢å™¨æ›´æ–°ï¼ˆèåˆæµ‹é‡å€¼ï¼‰
        twin_state = self.kf.update(physical_measurement)
        
        # 4. æ®‹å·®ç”Ÿæˆï¼ˆæ¨¡å‹é¢„æµ‹ vs å®é™…æµ‹é‡ï¼‰
        residual = abs(twin_state[0] - physical_measurement)
        self.residual_buffer.append(residual)
        
        # 5. æ•…éšœæ£€æµ‹
        fault_detected = self._detect_fault()
        
        # 6. å¦‚æœæ£€æµ‹åˆ°æ•…éšœï¼Œä½¿ç”¨å­ªç”Ÿæ¨¡å‹æä¾›è½¯æµ‹é‡
        if fault_detected:
            print(f"[WARNING] Sensor fault detected! Using twin model estimate.")
            physical_measurement = twin_state[0]  # ç”¨æ¨¡å‹ä¼°è®¡æ›¿ä»£
        
        # 7. å‚æ•°åœ¨çº¿æ ¡å‡†ï¼ˆæ¯100æ­¥ï¼‰
        if len(self.state_history) % 100 == 0:
            self._calibrate_parameters()
        
        # 8. è®°å½•å†å²
        self.state_history.append(twin_state.copy())
        self.time_history.append(len(self.state_history) * dt)
        
        return twin_state, physical_measurement, fault_detected
    
    def _detect_fault(self):
        """åŸºäºæ®‹å·®çš„æ•…éšœæ£€æµ‹"""
        if len(self.residual_buffer) < 10:
            return False
        
        # ç»Ÿè®¡æ£€éªŒï¼ˆ3-sigmaå‡†åˆ™ï¼‰
        residual_mean = np.mean(self.residual_buffer)
        residual_std = np.std(self.residual_buffer)
        
        # æœ€è¿‘çš„æ®‹å·®æ˜¯å¦è¶…è¿‡é˜ˆå€¼
        recent_residual = self.residual_buffer[-1]
        threshold = residual_mean + 3 * residual_std
        
        return recent_residual > max(threshold, self.fault_threshold)
    
    def _calibrate_parameters(self):
        """åœ¨çº¿å‚æ•°æ ¡å‡†ï¼ˆç®€åŒ–ç‰ˆï¼‰"""
        if len(self.state_history) < 100:
            return
        
        # ä½¿ç”¨æœ€è¿‘çš„æ•°æ®é‡æ–°è¾¨è¯†å‚æ•°
        recent_data = self.state_history[-100:]
        # ... è¾¨è¯†ç®—æ³• ...
        # æ›´æ–°self.modelå’Œself.kfçš„å‚æ•°
        pass
    
    def predict_future(self, horizon=30, dt=0.1, future_u=None):
        """
        åŸºäºå­ªç”Ÿæ¨¡å‹é¢„æµ‹æœªæ¥çŠ¶æ€
        
        Args:
            horizon: é¢„æµ‹æ—¶åŸŸï¼ˆæ­¥æ•°ï¼‰
            dt: æ—¶é—´æ­¥é•¿
            future_u: æœªæ¥çš„æ§åˆ¶è¾“å…¥åºåˆ—ï¼ˆå¦‚æœä¸ºNoneï¼Œå‡è®¾ä¿æŒå½“å‰è¾“å…¥ï¼‰
        
        Returns:
            t_pred: é¢„æµ‹æ—¶é—´åºåˆ—
            y_pred: é¢„æµ‹è¾“å‡ºåºåˆ—
        """
        current_state = self.state_history[-1][0]  # å½“å‰æ°´ä½
        current_u = future_u[0] if future_u is not None else 0
        
        t_pred = np.arange(0, horizon * dt, dt)
        y_pred = np.zeros(len(t_pred))
        y_pred[0] = current_state
        
        x = current_state
        for i in range(1, len(t_pred)):
            u = future_u[i] if future_u is not None else current_u
            
            # ä½¿ç”¨å½“å‰å­ªç”Ÿæ¨¡å‹å‚æ•°é¢„æµ‹
            Q_in = self.model.K * u
            Q_out = x / self.model.R if x > 0 else 0
            dx = (Q_in - Q_out) / self.model.A
            x = x + dx * dt
            
            y_pred[i] = x
        
        return t_pred, y_pred
    
    def visualize_dashboard(self):
        """å®æ—¶å¯è§†åŒ–ä»ªè¡¨ç›˜"""
        fig, axes = plt.subplots(3, 1, figsize=(12, 10))
        
        # å­å›¾1ï¼šæ°´ä½å¯¹æ¯”ï¼ˆç‰©ç† vs å­ªç”Ÿï¼‰
        axes[0].plot(self.time_history, [s[0] for s in self.state_history], 
                     label='Twin Model', linewidth=2)
        # ... ç‰©ç†æµ‹é‡å€¼ ...
        axes[0].set_ylabel('Water Level (m)')
        axes[0].legend()
        axes[0].grid()
        
        # å­å›¾2ï¼šæ®‹å·®
        axes[1].plot(self.time_history[-len(self.residual_buffer):], 
                     list(self.residual_buffer))
        axes[1].axhline(self.fault_threshold, color='r', linestyle='--', 
                        label='Fault Threshold')
        axes[1].set_ylabel('Residual')
        axes[1].legend()
        axes[1].grid()
        
        # å­å›¾3ï¼šå‚æ•°æ¼”åŒ–
        axes[2].plot(self.time_history, [s[1] for s in self.state_history], 
                     label='K estimate')
        axes[2].plot(self.time_history, [s[2] for s in self.state_history], 
                     label='Ï„ estimate')
        axes[2].set_xlabel('Time (s)')
        axes[2].set_ylabel('Parameter Value')
        axes[2].legend()
        axes[2].grid()
        
        plt.tight_layout()
        plt.show()


class KalmanFilter:
    """å¡å°”æ›¼æ»¤æ³¢å™¨ï¼ˆçº¿æ€§/æ‰©å±•ï¼‰"""
    
    def __init__(self, A, B, C, Q, R, x0, P0):
        self.A = A  # çŠ¶æ€è½¬ç§»çŸ©é˜µ
        self.B = B  # æ§åˆ¶è¾“å…¥çŸ©é˜µ
        self.C = C  # è§‚æµ‹çŸ©é˜µ
        self.Q = Q  # è¿‡ç¨‹å™ªå£°åæ–¹å·®
        self.R = R  # æµ‹é‡å™ªå£°åæ–¹å·®
        
        self.x = x0  # çŠ¶æ€ä¼°è®¡
        self.P = P0  # çŠ¶æ€åæ–¹å·®
    
    def predict(self, u):
        """é¢„æµ‹æ­¥"""
        self.x = self.A @ self.x + self.B.flatten() * u
        self.P = self.A @ self.P @ self.A.T + self.Q
    
    def update(self, z):
        """æ›´æ–°æ­¥ï¼ˆèåˆæµ‹é‡ï¼‰"""
        # å¡å°”æ›¼å¢ç›Š
        S = self.C @ self.P @ self.C.T + self.R
        K = self.P @ self.C.T @ np.linalg.inv(S)
        
        # çŠ¶æ€æ›´æ–°
        innovation = z - self.C @ self.x
        self.x = self.x + K.flatten() * innovation
        
        # åæ–¹å·®æ›´æ–°
        I = np.eye(self.P.shape[0])
        self.P = (I - K @ self.C) @ self.P
        
        return self.x
```

---

### ã€æ¡ˆä¾‹8ã€‘æ°´ç®±ç³»ç»Ÿçš„çŠ¶æ€åé¦ˆä¸LQRæ§åˆ¶ â­â­â­â­
**éš¾åº¦ç­‰çº§ï¼š** é«˜çº§  
**å·¥ç¨‹èƒŒæ™¯ï¼š** ä½¿ç”¨ç°ä»£æ§åˆ¶ç†è®ºä¼˜åŒ–å¤šç›®æ ‡æ€§èƒ½

#### é—®é¢˜æè¿°
æŸæ°´å¤„ç†ç³»ç»Ÿéœ€è¦åœ¨ä¿è¯æ°´ä½ç²¾åº¦çš„åŒæ—¶ï¼Œæœ€å°åŒ–æ³µçš„åŠŸè€—å’Œå¼€å…³æ¬¡æ•°ã€‚ä¼ ç»ŸPIDéš¾ä»¥å¹³è¡¡å¤šç›®æ ‡ï¼Œå¼•å…¥LQRï¼ˆçº¿æ€§äºŒæ¬¡è°ƒèŠ‚å™¨ï¼‰ã€‚

#### æ¶‰åŠç†è®º
- **ç°ä»£æ§åˆ¶**ï¼šçŠ¶æ€åé¦ˆ u = -Kxã€æç‚¹é…ç½®
- **æœ€ä¼˜æ§åˆ¶**ï¼šLQRï¼ˆLinear Quadratic Regulatorï¼‰ã€ä»£ä»·å‡½æ•°è®¾è®¡
- **è§‚æµ‹å™¨**ï¼šå…¨ç»´çŠ¶æ€è§‚æµ‹å™¨ã€Luenbergerè§‚æµ‹å™¨
- **åˆ†ç¦»å®šç†**ï¼šæ§åˆ¶å™¨ä¸è§‚æµ‹å™¨ç‹¬ç«‹è®¾è®¡

#### å­¦ä¹ ç›®æ ‡
1. ç†è§£çŠ¶æ€åé¦ˆæ§åˆ¶çš„åŸç†
2. æŒæ¡LQRçš„æ¨å¯¼å’Œæ±‚è§£ï¼ˆRiccatiæ–¹ç¨‹ï¼‰
3. å­¦ä¹ æƒé‡çŸ©é˜µQã€Rçš„è°ƒæ•´å¯¹æ€§èƒ½çš„å½±å“
4. ç†è§£è§‚æµ‹å™¨çš„è®¾è®¡ï¼ˆå½“çŠ¶æ€ä¸å¯å…¨éƒ¨æµ‹é‡æ—¶ï¼‰

#### å®éªŒå†…å®¹
- **ä»¿çœŸå®éªŒ8.1**ï¼šæç‚¹é…ç½®æ³•è®¾è®¡çŠ¶æ€åé¦ˆå¢ç›Š
- **ä»¿çœŸå®éªŒ8.2**ï¼šLQRæ§åˆ¶å™¨è®¾è®¡ä¸è°ƒä¼˜
- **ä»¿çœŸå®éªŒ8.3**ï¼šä¸åŒQã€Ræƒé‡çš„æ€§èƒ½å¯¹æ¯”
- **ä»¿çœŸå®éªŒ8.4**ï¼šå…¨ç»´çŠ¶æ€è§‚æµ‹å™¨è®¾è®¡
- **ä»¿çœŸå®éªŒ8.5**ï¼šåŸºäºè§‚æµ‹å™¨çš„è¾“å‡ºåé¦ˆæ§åˆ¶
- **ä»¿çœŸå®éªŒ8.6**ï¼šLQR vs PIDæ€§èƒ½å¯¹æ¯”

#### LQRæ§åˆ¶å™¨è®¾è®¡
```python
class LQRController:
    """çº¿æ€§äºŒæ¬¡è°ƒèŠ‚å™¨ï¼ˆLQRï¼‰"""
    
    def __init__(self, A, B, C, Q, R):
        """
        Args:
            A, B, C: çŠ¶æ€ç©ºé—´çŸ©é˜µ
            Q: çŠ¶æ€æƒé‡çŸ©é˜µï¼ˆnÃ—nï¼ŒåŠæ­£å®šï¼‰
            R: æ§åˆ¶æƒé‡çŸ©é˜µï¼ˆmÃ—mï¼Œæ­£å®šï¼‰
        """
        self.A = A
        self.B = B
        self.C = C
        self.Q = Q
        self.R = R
        
        # æ±‚è§£Riccatiæ–¹ç¨‹å¾—åˆ°æœ€ä¼˜å¢ç›ŠK
        self.K, self.S, self.E = self._solve_lqr()
    
    def _solve_lqr(self):
        """æ±‚è§£è¿ç»­æ—¶é—´LQRï¼ˆæ±‚è§£ä»£æ•°Riccatiæ–¹ç¨‹ï¼‰"""
        try:
            # ä½¿ç”¨scipyçš„lqræ±‚è§£å™¨
            from scipy import linalg
            S = linalg.solve_continuous_are(self.A, self.B, self.Q, self.R)
            K = np.linalg.inv(self.R) @ self.B.T @ S
            E = np.linalg.eigvals(self.A - self.B @ K)
            return K, S, E
        except:
            # å¦‚æœscipyç‰ˆæœ¬ä¸æ”¯æŒï¼Œä½¿ç”¨controlåº“
            K, S, E = control.lqr(self.A, self.B, self.Q, self.R)
            return K, S, E
    
    def compute(self, x, x_ref=None):
        """
        è®¡ç®—æ§åˆ¶è¾“å…¥
        
        Args:
            x: å½“å‰çŠ¶æ€
            x_ref: å‚è€ƒçŠ¶æ€ï¼ˆå¦‚æœä¸ºNoneï¼Œåˆ™é»˜è®¤ä¸ºé›¶ï¼‰
        
        Returns:
            u: æ§åˆ¶è¾“å…¥
        """
        if x_ref is None:
            x_ref = np.zeros_like(x)
        
        # çŠ¶æ€åé¦ˆ: u = -K(x - x_ref)
        u = -self.K @ (x - x_ref)
        
        return u.flatten()[0] if u.shape[0] == 1 else u
    
    def analyze_performance(self):
        """åˆ†æLQRæ€§èƒ½"""
        print("=== LQR Controller Analysis ===")
        print(f"Optimal Gain K: {self.K.flatten()}")
        print(f"Closed-loop Eigenvalues: {self.E}")
        print(f"All eigenvalues have negative real parts: {np.all(np.real(self.E) < 0)}")
        
        # è®¡ç®—ä»£ä»·å‡½æ•°çš„ä¸€äº›æ€§è´¨
        # ... æ›´å¤šåˆ†æ ...


class LuenbergerObserver:
    """LuenbergerçŠ¶æ€è§‚æµ‹å™¨"""
    
    def __init__(self, A, B, C, L, x0=None):
        """
        Args:
            A, B, C: çŠ¶æ€ç©ºé—´çŸ©é˜µ
            L: è§‚æµ‹å™¨å¢ç›ŠçŸ©é˜µï¼ˆnÃ—pï¼‰
            x0: åˆå§‹çŠ¶æ€ä¼°è®¡
        """
        self.A = A
        self.B = B
        self.C = C
        self.L = L
        
        n = A.shape[0]
        self.x_hat = np.zeros(n) if x0 is None else x0
    
    def update(self, u, y, dt):
        """
        æ›´æ–°çŠ¶æ€ä¼°è®¡
        
        è§‚æµ‹å™¨åŠ¨æ€: dxÌ‚/dt = AxÌ‚ + Bu + L(y - CxÌ‚)
        
        Args:
            u: æ§åˆ¶è¾“å…¥
            y: æµ‹é‡è¾“å‡º
            dt: æ—¶é—´æ­¥é•¿
        
        Returns:
            x_hat: çŠ¶æ€ä¼°è®¡
        """
        # é¢„æµ‹
        x_pred = self.x_hat + (self.A @ self.x_hat + self.B.flatten() * u) * dt
        
        # æ ¡æ­£ï¼ˆåŸºäºæµ‹é‡æ®‹å·®ï¼‰
        y_pred = self.C @ x_pred
        innovation = y - y_pred
        self.x_hat = x_pred + (self.L @ innovation).flatten() * dt
        
        return self.x_hat
    
    @staticmethod
    def design_observer_gain(A, C, desired_poles):
        """
        è®¾è®¡è§‚æµ‹å™¨å¢ç›ŠLï¼Œä½¿å¾—(A-LC)çš„ç‰¹å¾å€¼ä¸ºdesired_poles
        
        ç­‰ä»·äºå¯¹å¶ç³»ç»Ÿçš„çŠ¶æ€åé¦ˆè®¾è®¡
        """
        # å¯¹å¶ç³»ç»Ÿ
        A_dual = A.T
        B_dual = C.T
        
        # æç‚¹é…ç½®
        K_dual = control.place(A_dual, B_dual, desired_poles)
        
        # è§‚æµ‹å™¨å¢ç›Š
        L = K_dual.T
        
        return L


def lqr_vs_pid_comparison():
    """LQRä¸PIDæ€§èƒ½å¯¹æ¯”å®éªŒ"""
    
    # 1. ç³»ç»Ÿæ¨¡å‹ï¼ˆåŒæ°´ç®±ï¼‰
    tank = DoubleTankCascade(A1=0.5, A2=0.5, R1=2.0, R2=2.0, K=1.0)
    A, B, C, D = tank.state_space_model()
    
    # 2. LQRæ§åˆ¶å™¨è®¾è®¡
    # æƒé‡çŸ©é˜µï¼šæ›´å…³æ³¨ä¸‹æ°´ç®±æ°´ä½ï¼ˆx2ï¼‰ï¼Œé€‚åº¦æƒ©ç½šæ§åˆ¶è¾“å…¥
    Q = np.diag([1, 100])  # x1æƒé‡å°ï¼Œx2æƒé‡å¤§
    R = np.array([[1]])
    
    lqr = LQRController(A, B, C, Q, R)
    lqr.analyze_performance()
    
    # 3. PIDæ§åˆ¶å™¨ï¼ˆä»…åŸºäºè¾“å‡ºy=x2ï¼‰
    pid = PIDController(Kp=2.0, Ki=0.5, Kd=0.1, setpoint=3.0, dt=0.1)
    
    # 4. ä»¿çœŸå¯¹æ¯”
    t_sim = np.arange(0, 200, 0.1)
    setpoint = 3.0
    x_ref = np.array([setpoint * tank.R1, setpoint])  # ç¨³æ€å‚è€ƒçŠ¶æ€
    
    # LQRä»¿çœŸ
    x_lqr = np.zeros((len(t_sim), 2))
    u_lqr = np.zeros(len(t_sim))
    x_lqr[0] = [1.0, 1.0]  # åˆå§‹çŠ¶æ€
    
    for i in range(1, len(t_sim)):
        u_lqr[i-1] = lqr.compute(x_lqr[i-1], x_ref)
        dx = A @ x_lqr[i-1] + B.flatten() * u_lqr[i-1]
        x_lqr[i] = x_lqr[i-1] + dx * 0.1
    
    # PIDä»¿çœŸ
    x_pid = np.zeros((len(t_sim), 2))
    u_pid = np.zeros(len(t_sim))
    x_pid[0] = [1.0, 1.0]
    
    for i in range(1, len(t_sim)):
        y = C @ x_pid[i-1]
        u_pid[i-1] = pid.compute(y[0])
        dx = A @ x_pid[i-1] + B.flatten() * u_pid[i-1]
        x_pid[i] = x_pid[i-1] + dx * 0.1
    
    # 5. æ€§èƒ½æŒ‡æ ‡è®¡ç®—
    # æ§åˆ¶ç²¾åº¦ï¼ˆRMSEï¼‰
    rmse_lqr = np.sqrt(np.mean((x_lqr[:, 1] - setpoint)**2))
    rmse_pid = np.sqrt(np.mean((x_pid[:, 1] - setpoint)**2))
    
    # æ§åˆ¶èƒ½è€—
    energy_lqr = np.sum(u_lqr**2) * 0.1
    energy_pid = np.sum(u_pid**2) * 0.1
    
    print(f"\n=== Performance Comparison ===")
    print(f"LQR - RMSE: {rmse_lqr:.4f}, Energy: {energy_lqr:.2f}")
    print(f"PID - RMSE: {rmse_pid:.4f}, Energy: {energy_pid:.2f}")
    
    # 6. å¯è§†åŒ–
    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
    
    axes[0].plot(t_sim, x_lqr[:, 1], label='LQR', linewidth=2)
    axes[0].plot(t_sim, x_pid[:, 1], label='PID', linewidth=2)
    axes[0].axhline(setpoint, color='k', linestyle='--', label='Setpoint')
    axes[0].set_ylabel('Water Level h2 (m)')
    axes[0].legend()
    axes[0].grid()
    axes[0].set_title('Output Response')
    
    axes[1].plot(t_sim, u_lqr, label='LQR')
    axes[1].plot(t_sim, u_pid, label='PID')
    axes[1].set_ylabel('Control Input u')
    axes[1].legend()
    axes[1].grid()
    axes[1].set_title('Control Effort')
    
    axes[2].plot(t_sim, np.abs(x_lqr[:, 1] - setpoint), label='LQR Error')
    axes[2].plot(t_sim, np.abs(x_pid[:, 1] - setpoint), label='PID Error')
    axes[2].set_xlabel('Time (s)')
    axes[2].set_ylabel('Absolute Error')
    axes[2].set_yscale('log')
    axes[2].legend()
    axes[2].grid()
    axes[2].set_title('Tracking Error (log scale)')
    
    plt.tight_layout()
    plt.show()
```

---

### ã€æ¡ˆä¾‹9ã€‘çº¦æŸæ°´ç®±ç³»ç»Ÿçš„æ¨¡å‹é¢„æµ‹æ§åˆ¶ â­â­â­â­â­
**éš¾åº¦ç­‰çº§ï¼š** é«˜çº§  
**å·¥ç¨‹èƒŒæ™¯ï¼š** æ°´ç®±æœ‰ç‰©ç†çº¦æŸï¼ˆæ°´ä½é™åˆ¶ã€æ³µæµé‡é™åˆ¶ï¼‰ï¼Œéœ€è¦æœ€ä¼˜æ§åˆ¶

#### é—®é¢˜æè¿°
åŒ–å·¥å‚çš„ååº”é‡œä¾›æ–™æ°´ç®±ï¼Œæ°´ä½å¿…é¡»ä¸¥æ ¼ä¿æŒåœ¨1.5-3.5ç±³ä¹‹é—´ï¼ˆå®‰å…¨çº¦æŸï¼‰ï¼Œæ³µæµé‡0-10 mÂ³/hï¼ˆç‰©ç†é™åˆ¶ï¼‰ã€‚éœ€è¦è®¾è®¡èƒ½å¤„ç†çº¦æŸçš„å…ˆè¿›æ§åˆ¶å™¨ã€‚

#### æ¶‰åŠç†è®º
- **MPC**ï¼šæ»šåŠ¨ä¼˜åŒ–ã€é¢„æµ‹æ¨¡å‹ã€çº¦æŸå¤„ç†
- **ä¼˜åŒ–**ï¼šäºŒæ¬¡è§„åˆ’ï¼ˆQPï¼‰ã€å‡¸ä¼˜åŒ–
- **å®æ—¶è®¡ç®—**ï¼šå¿«é€ŸQPæ±‚è§£å™¨ï¼ˆOSQPã€qpOASESï¼‰

#### å­¦ä¹ ç›®æ ‡
1. ç†è§£MPCçš„åŸºæœ¬åŸç†ï¼ˆé¢„æµ‹â†’ä¼˜åŒ–â†’åé¦ˆï¼‰
2. æŒæ¡MPCçš„æ•°å­¦è¡¨è¾¾ï¼ˆä»£ä»·å‡½æ•°+çº¦æŸï¼‰
3. å­¦ä¹ å°†MPCè½¬åŒ–ä¸ºQPé—®é¢˜
4. ç†è§£é¢„æµ‹æ—¶åŸŸå’Œæ§åˆ¶æ—¶åŸŸçš„ä½œç”¨

#### å®éªŒå†…å®¹
- **ä»¿çœŸå®éªŒ9.1**ï¼šMPCåŸºæœ¬æ¡†æ¶å®ç°
- **ä»¿çœŸå®éªŒ9.2**ï¼šçº¦æŸè¿åçš„æ¼”ç¤ºï¼ˆä¸æ— çº¦æŸæ§åˆ¶å¯¹æ¯”ï¼‰
- **ä»¿çœŸå®éªŒ9.3**ï¼šä¸åŒé¢„æµ‹æ—¶åŸŸçš„å½±å“
- **ä»¿çœŸå®éªŒ9.4**ï¼šMPCå¤„ç†æ‰°åŠ¨çš„èƒ½åŠ›
- **ä»¿çœŸå®éªŒ9.5**ï¼šMPC vs LQR vs PIDä¸‰æ–¹å¯¹æ¯”
- **ç¡¬ä»¶å®éªŒ9.6**ï¼šå®æ—¶MPCå®ç°ï¼ˆéœ€è¦å¿«é€Ÿæ±‚è§£å™¨ï¼‰

#### æ¨¡å‹é¢„æµ‹æ§åˆ¶å®ç°
```python
import cvxpy as cp

class MPCController:
    """æ¨¡å‹é¢„æµ‹æ§åˆ¶å™¨ï¼ˆå¤„ç†çº¦æŸï¼‰"""
    
    def __init__(self, A, B, C, Q, R, N, dt,
                 x_min=None, x_max=None, 
                 u_min=None, u_max=None,
                 du_max=None):
        """
        Args:
            A, B, C: ç¦»æ•£çŠ¶æ€ç©ºé—´çŸ©é˜µ
            Q: çŠ¶æ€æƒé‡çŸ©é˜µ (nÃ—n)
            R: æ§åˆ¶æƒé‡çŸ©é˜µ (mÃ—m)
            N: é¢„æµ‹æ—¶åŸŸ
            dt: é‡‡æ ·æ—¶é—´
            x_min, x_max: çŠ¶æ€çº¦æŸ (nÃ—1æ•°ç»„)
            u_min, u_max: æ§åˆ¶è¾“å…¥çº¦æŸ (mÃ—1æ•°ç»„)
            du_max: æ§åˆ¶å¢é‡çº¦æŸ (mÃ—1æ•°ç»„)
        """
        self.A = A
        self.B = B
        self.C = C
        self.Q = Q
        self.R = R
        self.N = N  # é¢„æµ‹æ—¶åŸŸ
        self.dt = dt
        
        self.n = A.shape[0]  # çŠ¶æ€ç»´æ•°
        self.m = B.shape[1]  # æ§åˆ¶ç»´æ•°
        
        # çº¦æŸ
        self.x_min = x_min if x_min is not None else np.full(self.n, -np.inf)
        self.x_max = x_max if x_max is not None else np.full(self.n, np.inf)
        self.u_min = u_min if u_min is not None else np.full(self.m, -np.inf)
        self.u_max = u_max if u_max is not None else np.full(self.m, np.inf)
        self.du_max = du_max if du_max is not None else np.full(self.m, np.inf)
        
        # ä¸Šä¸€æ—¶åˆ»çš„æ§åˆ¶è¾“å…¥ï¼ˆç”¨äºè®¡ç®—æ§åˆ¶å¢é‡ï¼‰
        self.u_prev = np.zeros(self.m)
        
        # é¢„æ„å»ºä¼˜åŒ–é—®é¢˜ï¼ˆåŠ é€Ÿåœ¨çº¿æ±‚è§£ï¼‰
        self.x_var, self.u_var, self.x0_param, self.xref_param, self.problem = \
            self._build_optimization_problem()
    
    def _build_optimization_problem(self):
        """æ„å»ºCVXPYä¼˜åŒ–é—®é¢˜ï¼ˆç¦»çº¿æ„å»ºï¼Œåœ¨çº¿æ±‚è§£ï¼‰"""
        
        # å†³ç­–å˜é‡
        x = cp.Variable((self.n, self.N + 1))  # çŠ¶æ€åºåˆ— x[0], x[1], ..., x[N]
        u = cp.Variable((self.m, self.N))      # æ§åˆ¶åºåˆ— u[0], u[1], ..., u[N-1]
        
        # å‚æ•°ï¼ˆåœ¨çº¿æ›´æ–°ï¼‰
        x0 = cp.Parameter(self.n)              # å½“å‰çŠ¶æ€
        x_ref = cp.Parameter(self.n)           # å‚è€ƒçŠ¶æ€
        
        # ä»£ä»·å‡½æ•°
        cost = 0
        
        for k in range(self.N):
            # çŠ¶æ€ä»£ä»·: (x[k] - x_ref)' Q (x[k] - x_ref)
            cost += cp.quad_form(x[:, k] - x_ref, self.Q)
            
            # æ§åˆ¶ä»£ä»·: u[k]' R u[k]
            cost += cp.quad_form(u[:, k], self.R)
        
        # ç»ˆç«¯ä»£ä»·
        cost += cp.quad_form(x[:, self.N] - x_ref, self.Q)
        
        # çº¦æŸ
        constraints = []
        
        # åˆå§‹çŠ¶æ€çº¦æŸ
        constraints.append(x[:, 0] == x0)
        
        for k in range(self.N):
            # ç³»ç»ŸåŠ¨æ€çº¦æŸ: x[k+1] = A x[k] + B u[k]
            constraints.append(x[:, k+1] == self.A @ x[:, k] + self.B @ u[:, k])
            
            # çŠ¶æ€çº¦æŸ: x_min <= x[k] <= x_max
            constraints.append(x[:, k] >= self.x_min)
            constraints.append(x[:, k] <= self.x_max)
            
            # æ§åˆ¶çº¦æŸ: u_min <= u[k] <= u_max
            constraints.append(u[:, k] >= self.u_min)
            constraints.append(u[:, k] <= self.u_max)
            
            # æ§åˆ¶å¢é‡çº¦æŸ: |u[k] - u[k-1]| <= du_max
            if k > 0:
                constraints.append(cp.abs(u[:, k] - u[:, k-1]) <= self.du_max)
        
        # ç»ˆç«¯çŠ¶æ€çº¦æŸ
        constraints.append(x[:, self.N] >= self.x_min)
        constraints.append(x[:, self.N] <= self.x_max)
        
        # æ„å»ºä¼˜åŒ–é—®é¢˜
        problem = cp.Problem(cp.Minimize(cost), constraints)
        
        return x, u, x0, x_ref, problem
    
    def compute(self, x_current, x_reference=None):
        """
        è®¡ç®—MPCæ§åˆ¶è¾“å…¥
        
        Args:
            x_current: å½“å‰çŠ¶æ€ (nÃ—1)
            x_reference: å‚è€ƒçŠ¶æ€ (nÃ—1)ï¼Œå¦‚æœä¸ºNoneåˆ™ä¸ºé›¶
        
        Returns:
            u_optimal: æœ€ä¼˜æ§åˆ¶è¾“å…¥ï¼ˆåº”ç”¨ç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰
            u_sequence: å®Œæ•´çš„æœ€ä¼˜æ§åˆ¶åºåˆ—ï¼ˆç”¨äºå¯è§†åŒ–ï¼‰
            solve_time: æ±‚è§£æ—¶é—´
        """
        import time
        
        if x_reference is None:
            x_reference = np.zeros(self.n)
        
        # æ›´æ–°å‚æ•°
        self.x0_param.value = x_current
        self.xref_param.value = x_reference
        
        # æ±‚è§£ä¼˜åŒ–é—®é¢˜
        start_time = time.time()
        
        try:
            self.problem.solve(solver=cp.OSQP, warm_start=True, verbose=False)
            solve_time = time.time() - start_time
            
            if self.problem.status not in ["optimal", "optimal_inaccurate"]:
                print(f"[WARNING] MPC solve status: {self.problem.status}")
                # è¿”å›å®‰å…¨çš„é»˜è®¤æ§åˆ¶
                return np.zeros(self.m), None, solve_time
            
            # æå–æœ€ä¼˜è§£ï¼ˆMPCç­–ç•¥ï¼šåªåº”ç”¨ç¬¬ä¸€ä¸ªæ§åˆ¶ï¼‰
            u_optimal = self.u_var[:, 0].value
            u_sequence = self.u_var.value
            
            # æ›´æ–°u_prevç”¨äºä¸‹ä¸€æ¬¡çš„å¢é‡çº¦æŸ
            self.u_prev = u_optimal
            
            return u_optimal, u_sequence, solve_time
            
        except Exception as e:
            print(f"[ERROR] MPC solve failed: {e}")
            return np.zeros(self.m), None, 0.0
    
    def visualize_prediction(self, x_current, x_reference):
        """å¯è§†åŒ–é¢„æµ‹è½¨è¿¹"""
        u_opt, u_seq, _ = self.compute(x_current, x_reference)
        
        if u_seq is None:
            return
        
        # é¢„æµ‹çŠ¶æ€è½¨è¿¹
        x_pred = self.x_var.value
        
        t_pred = np.arange(self.N + 1) * self.dt
        
        plt.figure(figsize=(12, 8))
        
        # å­å›¾1ï¼šçŠ¶æ€é¢„æµ‹
        plt.subplot(2, 1, 1)
        for i in range(self.n):
            plt.plot(t_pred, x_pred[i, :], 'o-', label=f'x{i+1} prediction')
            plt.axhline(x_reference[i], color='k', linestyle='--', alpha=0.3)
            
            # ç»˜åˆ¶çº¦æŸ
            if np.isfinite(self.x_min[i]):
                plt.axhline(self.x_min[i], color='r', linestyle=':', label=f'x{i+1} min' if i==0 else '')
            if np.isfinite(self.x_max[i]):
                plt.axhline(self.x_max[i], color='r', linestyle=':', label=f'x{i+1} max' if i==0 else '')
        
        plt.ylabel('State')
        plt.legend()
        plt.grid()
        plt.title('MPC State Prediction over Horizon')
        
        # å­å›¾2ï¼šæ§åˆ¶åºåˆ—
        plt.subplot(2, 1, 2)
        t_ctrl = np.arange(self.N) * self.dt
        
        for i in range(self.m):
            plt.step(t_ctrl, u_seq[i, :], where='post', label=f'u{i+1}')
            
            # ç»˜åˆ¶çº¦æŸ
            if np.isfinite(self.u_min[i]):
                plt.axhline(self.u_min[i], color='r', linestyle=':', label=f'u{i+1} min' if i==0 else '')
            if np.isfinite(self.u_max[i]):
                plt.axhline(self.u_max[i], color='r', linestyle=':', label=f'u{i+1} max' if i==0 else '')
        
        plt.xlabel('Time (s)')
        plt.ylabel('Control Input')
        plt.legend()
        plt.grid()
        plt.title('Optimal Control Sequence')
        
        plt.tight_layout()
        plt.show()


def mpc_constraint_handling_demo():
    """MPCçº¦æŸå¤„ç†æ¼”ç¤º"""
    
    # 1. ç³»ç»Ÿï¼ˆå•æ°´ç®±ç¦»æ•£åŒ–ï¼‰
    A_c = np.array([[-0.5]])  # è¿ç»­æ—¶é—´
    B_c = np.array([[1.0]])
    C_c = np.array([[1.0]])
    
    dt = 0.1
    A_d = np.eye(1) + A_c * dt
    B_d = B_c * dt
    
    # 2. çº¦æŸ
    x_min = np.array([1.5])  # æœ€ä½æ°´ä½1.5m
    x_max = np.array([3.5])  # æœ€é«˜æ°´ä½3.5m
    u_min = np.array([0])    # æ³µä¸èƒ½åè½¬
    u_max = np.array([10])   # æ³µæœ€å¤§æµé‡10 mÂ³/h
    du_max = np.array([2])   # æµé‡å˜åŒ–ç‡é™åˆ¶ï¼ˆé¿å…æ°´å‡»ï¼‰
    
    # 3. MPCæ§åˆ¶å™¨
    Q = np.array([[10]])
    R = np.array([[0.1]])
    N = 20  # é¢„æµ‹æ—¶åŸŸ20æ­¥
    
    mpc = MPCController(A_d, B_d, C_c, Q, R, N, dt,
                        x_min, x_max, u_min, u_max, du_max)
    
    # 4. ä»¿çœŸï¼ˆå¤§å¹…åº¦è®¾å®šå€¼å˜åŒ– + æ‰°åŠ¨ï¼‰
    t_sim = np.arange(0, 100, dt)
    x = np.array([2.0])  # åˆå§‹æ°´ä½2m
    x_ref = np.array([3.0])  # ç›®æ ‡æ°´ä½3m
    
    x_history = [x.copy()]
    u_history = []
    solve_times = []
    
    for i, t in enumerate(t_sim[:-1]):
        # è®¾å®šå€¼å˜åŒ–
        if t > 40:
            x_ref = np.array([2.0])  # åœ¨40sæ—¶é™ä½ç›®æ ‡
        
        # æ·»åŠ æ‰°åŠ¨ï¼ˆåœ¨t=60sæ—¶ï¼Œçªç„¶çš„å¤–éƒ¨æµå…¥ï¼‰
        disturbance = 3.0 if 60 < t < 65 else 0
        
        # MPCæ§åˆ¶
        u, _, solve_time = mpc.compute(x, x_ref)
        
        # ç³»ç»Ÿæ¼”åŒ–ï¼ˆå«æ‰°åŠ¨ï¼‰
        x = A_d @ x + B_d @ u + disturbance * dt
        
        # çº¦æŸæ£€éªŒï¼ˆåéªŒï¼‰
        if x < x_min or x > x_max:
            print(f"[WARNING] Constraint violated at t={t:.1f}: x={x[0]:.2f}")
        
        x_history.append(x.copy())
        u_history.append(u.copy())
        solve_times.append(solve_time)
    
    x_history = np.array(x_history).squeeze()
    u_history = np.array(u_history).squeeze()
    
    # 5. ç»“æœå¯è§†åŒ–
    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
    
    # æ°´ä½
    axes[0].plot(t_sim, x_history, linewidth=2, label='Water Level')
    axes[0].axhline(x_min[0], color='r', linestyle='--', label='Min Constraint')
    axes[0].axhline(x_max[0], color='r', linestyle='--', label='Max Constraint')
    axes[0].fill_between(t_sim, x_min[0], x_max[0], alpha=0.2, color='green', label='Safe Region')
    axes[0].set_ylabel('Water Level (m)')
    axes[0].legend()
    axes[0].grid()
    axes[0].set_title('MPC with Constraints - State Response')
    
    # æ§åˆ¶è¾“å…¥
    axes[1].step(t_sim[:-1], u_history, where='post', linewidth=2, label='Control Input')
    axes[1].axhline(u_min[0], color='r', linestyle='--', label='Min')
    axes[1].axhline(u_max[0], color='r', linestyle='--', label='Max')
    axes[1].fill_between(t_sim[:-1], u_min[0], u_max[0], alpha=0.2, color='green')
    axes[1].set_ylabel('Flow Rate (mÂ³/h)')
    axes[1].legend()
    axes[1].grid()
    axes[1].set_title('Control Input (respecting constraints)')
    
    # æ±‚è§£æ—¶é—´
    axes[2].plot(t_sim[:-1], solve_times, linewidth=1, label='Solve Time')
    axes[2].axhline(dt, color='r', linestyle='--', label='Sampling Time')
    axes[2].set_xlabel('Time (s)')
    axes[2].set_ylabel('Solve Time (s)')
    axes[2].set_yscale('log')
    axes[2].legend()
    axes[2].grid()
    axes[2].set_title('Computational Performance (must be < sampling time)')
    
    plt.tight_layout()
    plt.show()
    
    print(f"\n=== MPC Performance ===")
    print(f"Average solve time: {np.mean(solve_times)*1000:.2f} ms")
    print(f"Max solve time: {np.max(solve_times)*1000:.2f} ms")
    print(f"Constraint violations: {np.sum((x_history < x_min) | (x_history > x_max))}")
```

---

### ã€æ¡ˆä¾‹10ã€‘æ°´ç®±ç³»ç»Ÿçš„åœ¨ç¯æµ‹è¯•ï¼ˆHIL/SILï¼‰ â­â­â­â­
**éš¾åº¦ç­‰çº§ï¼š** é«˜çº§  
**å·¥ç¨‹èƒŒæ™¯ï¼š** åœ¨éƒ¨ç½²åˆ°çœŸå®ç³»ç»Ÿå‰ï¼Œé€šè¿‡åœ¨ç¯æµ‹è¯•éªŒè¯æ§åˆ¶ç®—æ³•

#### é—®é¢˜æè¿°
å¼€å‘äº†ä¸€ä¸ªå¤æ‚çš„MPCæ§åˆ¶å™¨ï¼Œéœ€è¦åœ¨éƒ¨ç½²åˆ°PLCå‰è¿›è¡Œå……åˆ†æµ‹è¯•ï¼ŒåŒ…æ‹¬è¾¹ç•Œæ¡ä»¶ã€æ•…éšœåœºæ™¯ã€å®æ—¶æ€§èƒ½ã€‚

#### æ¶‰åŠç†è®º
- **åœ¨ç¯æµ‹è¯•**ï¼šMILã€SILã€PILã€HILçš„æ¦‚å¿µå’Œæµç¨‹
- **å®æ—¶ç³»ç»Ÿ**ï¼šå®æ—¶è°ƒåº¦ã€æœ€åæ‰§è¡Œæ—¶é—´ï¼ˆWCETï¼‰
- **ç¡¬ä»¶æ¥å£**ï¼šDAQã€I/Oã€é€šä¿¡åè®®ï¼ˆModbusã€CANï¼‰
- **æ•…éšœæ³¨å…¥**ï¼šä¼ æ„Ÿå™¨æ•…éšœã€æ‰§è¡Œå™¨æ•…éšœã€é€šä¿¡æ•…éšœ

#### å­¦ä¹ ç›®æ ‡
1. ç†è§£åœ¨ç¯æµ‹è¯•åœ¨Væ¨¡å‹ä¸­çš„ä½ç½®
2. æŒæ¡SILæµ‹è¯•ç¯å¢ƒæ­å»º
3. å­¦ä¹ HILå¹³å°çš„ç»„æˆå’Œä½¿ç”¨
4. ç†è§£å®æ—¶æ€§éªŒè¯çš„é‡è¦æ€§

#### å®éªŒå†…å®¹
- **å®éªŒ10.1**ï¼šMILæµ‹è¯•ï¼ˆçº¯Python/MATLABä»¿çœŸï¼‰
- **å®éªŒ10.2**ï¼šSILæµ‹è¯•ï¼ˆCä»£ç ç”Ÿæˆ+è”åˆä»¿çœŸï¼‰
- **å®éªŒ10.3**ï¼šPILæµ‹è¯•ï¼ˆç›®æ ‡MCUä»¿çœŸï¼‰
- **å®éªŒ10.4**ï¼šHILæµ‹è¯•ï¼ˆArduino/dSPACEï¼‰
- **å®éªŒ10.5**ï¼šæ•…éšœæ³¨å…¥æµ‹è¯•ï¼ˆä¼ æ„Ÿå™¨æ¼‚ç§»ã€é¥±å’Œã€æ–­çº¿ï¼‰
- **å®éªŒ10.6**ï¼šå®æ—¶æ€§èƒ½åˆ†æï¼ˆæ‰§è¡Œæ—¶é—´åˆ†å¸ƒï¼‰

#### SILæµ‹è¯•æ¡†æ¶

```python
class SILTestFramework:
    """è½¯ä»¶åœ¨ç¯(SIL)æµ‹è¯•æ¡†æ¶"""
    
    def __init__(self, controller_code, plant_model):
        """
        Args:
            controller_code: æ§åˆ¶å™¨ä»£ç ï¼ˆPythonå‡½æ•°æˆ–Cå…±äº«åº“ï¼‰
            plant_model: è¢«æ§å¯¹è±¡æ¨¡å‹
        """
        self.controller = controller_code
        self.plant = plant_model
        
        # æµ‹è¯•è®°å½•
        self.test_cases = []
        self.test_results = []
    
    def add_test_case(self, name, scenario, expected_behavior, pass_criteria):
        """æ·»åŠ æµ‹è¯•ç”¨ä¾‹"""
        self.test_cases.append({
            'name': name,
            'scenario': scenario,
            'expected': expected_behavior,
            'criteria': pass_criteria
        })
    
    def run_all_tests(self):
        """è¿è¡Œæ‰€æœ‰æµ‹è¯•ç”¨ä¾‹"""
        print("=== SIL Test Suite ===")
        
        for i, test in enumerate(self.test_cases):
            print(f"\n[Test {i+1}/{len(self.test_cases)}] {test['name']}")
            
            result = self._run_single_test(test)
            self.test_results.append(result)
            
            status = "PASS" if result['passed'] else "FAIL"
            print(f"Result: {status}")
            
            if not result['passed']:
                print(f"  Reason: {result['reason']}")
        
        # æ±‡æ€»
        n_pass = sum(r['passed'] for r in self.test_results)
        n_total = len(self.test_results)
        print(f"\n=== Test Summary ===")
        print(f"Passed: {n_pass}/{n_total} ({n_pass/n_total*100:.1f}%)")
    
    def _run_single_test(self, test):
        """è¿è¡Œå•ä¸ªæµ‹è¯•"""
        try:
            # æ‰§è¡Œåœºæ™¯
            t, x, u = test['scenario'](self.controller, self.plant)
            
            # æ£€æŸ¥é€šè¿‡å‡†åˆ™
            passed, reason = test['criteria'](t, x, u)
            
            return {
                'passed': passed,
                'reason': reason,
                'data': {'t': t, 'x': x, 'u': u}
            }
        except Exception as e:
            return {
                'passed': False,
                'reason': f"Exception: {str(e)}",
                'data': None
            }


# ç¤ºä¾‹ï¼šå®šä¹‰æµ‹è¯•åœºæ™¯å’Œé€šè¿‡å‡†åˆ™
def test_scenario_nominal(controller, plant):
    """åä¹‰å·¥å†µæµ‹è¯•"""
    t = np.arange(0, 100, 0.1)
    x = np.zeros(len(t))
    u = np.zeros(len(t))
    
    x[0] = 1.0  # åˆå§‹æ°´ä½
    setpoint = 3.0
    
    for i in range(1, len(t)):
        u[i-1] = controller(x[i-1], setpoint)
        x[i] = plant.step(x[i-1], u[i-1], 0.1)
    
    return t, x, u


def pass_criteria_steady_state(t, x, u):
    """ç¨³æ€è¯¯å·®å‡†åˆ™"""
    setpoint = 3.0
    steady_state_error = abs(x[-1] - setpoint)
    
    if steady_state_error < 0.1:
        return True, ""
    else:
        return False, f"Steady-state error {steady_state_error:.3f} > 0.1"


# ä½¿ç”¨ç¤ºä¾‹
sil_test = SILTestFramework(pid_controller, single_tank_model)
sil_test.add_test_case(
    name="Nominal Operation",
    scenario=test_scenario_nominal,
    expected_behavior="Converge to setpoint within 50s",
    pass_criteria=pass_criteria_steady_state
)
# ... æ·»åŠ æ›´å¤šæµ‹è¯•ç”¨ä¾‹ ...
sil_test.run_all_tests()
```

#### HILæµ‹è¯•å¹³å°ï¼ˆArduinoç¤ºä¾‹ï¼‰

```python
# Pythonç«¯ï¼ˆè¿è¡Œåœ¨PCï¼Œå®æ—¶ä»¿çœŸè¢«æ§å¯¹è±¡ï¼‰
import serial
import time
import struct

class HILSimulator:
    """ç¡¬ä»¶åœ¨ç¯ä»¿çœŸå™¨"""
    
    def __init__(self, port, baudrate=115200):
        self.serial = serial.Serial(port, baudrate, timeout=0.01)
        time.sleep(2)  # ç­‰å¾…Arduinoå¤ä½
        
        self.plant = SingleTank(A=0.5, R=2.0, K=1.0)
        self.x = 2.0  # åˆå§‹æ°´ä½
        
    def run(self, duration=100, dt=0.1):
        """è¿è¡ŒHILä»¿çœŸ"""
        t_start = time.time()
        t_sim = 0
        
        data_log = {'t': [], 'x': [], 'u': [], 'latency': []}
        
        while t_sim < duration:
            loop_start = time.time()
            
            # 1. å‘é€ä¼ æ„Ÿå™¨å€¼åˆ°æ§åˆ¶å™¨ï¼ˆArduinoï¼‰
            self._send_sensor_data(self.x)
            
            # 2. æ¥æ”¶æ§åˆ¶å™¨è¾“å‡º
            u = self._receive_control_input()
            
            if u is not None:
                # 3. æ›´æ–°è¢«æ§å¯¹è±¡
                Q_in = self.plant.K * u
                Q_out = self.x / self.plant.R if self.x > 0 else 0
                dx = (Q_in - Q_out) / self.plant.A
                self.x = self.x + dx * dt
                
                # 4. è®°å½•æ•°æ®
                latency = time.time() - loop_start
                data_log['t'].append(t_sim)
                data_log['x'].append(self.x)
                data_log['u'].append(u)
                data_log['latency'].append(latency)
                
                # 5. å®æ—¶åŒæ­¥ï¼ˆä¿æŒå›ºå®šé‡‡æ ·å‘¨æœŸï¼‰
                elapsed = time.time() - loop_start
                if elapsed < dt:
                    time.sleep(dt - elapsed)
            
            t_sim += dt
        
        return data_log
    
    def _send_sensor_data(self, water_level):
        """å‘é€ä¼ æ„Ÿå™¨æ•°æ®ï¼ˆfloatï¼Œ4å­—èŠ‚ï¼‰"""
        data = struct.pack('f', water_level)
        self.serial.write(b'S' + data)  # 'S'æ ‡è¯†sensor data
    
    def _receive_control_input(self):
        """æ¥æ”¶æ§åˆ¶è¾“å…¥"""
        if self.serial.in_waiting >= 5:  # 'C' + 4 bytes float
            header = self.serial.read(1)
            if header == b'C':
                data = self.serial.read(4)
                u = struct.unpack('f', data)[0]
                return u
        return None
```

```cpp
// Arduinoç«¯ï¼ˆæ§åˆ¶å™¨ï¼Œè¿è¡Œåœ¨MCUï¼‰
// arduino_hil_controller.ino

float setpoint = 3.0;
float Kp = 2.0, Ki = 0.5, Kd = 0.1;
float integral = 0, prev_error = 0;
float dt = 0.1;

void setup() {
  Serial.begin(115200);
}

void loop() {
  // 1. æ¥æ”¶ä¼ æ„Ÿå™¨æ•°æ®
  if (Serial.available() >= 5) {
    char header = Serial.read();
    
    if (header == 'S') {
      float water_level;
      Serial.readBytes((char*)&water_level, 4);
      
      // 2. è®¡ç®—æ§åˆ¶è¾“å‡ºï¼ˆPIDï¼‰
      float error = setpoint - water_level;
      
      float P = Kp * error;
      integral += error * dt;
      float I = Ki * integral;
      float derivative = (error - prev_error) / dt;
      float D = Kd * derivative;
      
      float u = P + I + D;
      u = constrain(u, 0, 100);  // é™å¹…
      
      prev_error = error;
      
      // 3. å‘é€æ§åˆ¶è¾“å‡º
      Serial.write('C');
      Serial.write((byte*)&u, 4);
      
      // æ€§èƒ½ç›‘æ§ï¼ˆå¯é€‰ï¼‰
      unsigned long exec_time = micros();
      // ... è®°å½•æ‰§è¡Œæ—¶é—´ ...
    }
  }
}
```

---

### ã€æ¡ˆä¾‹11ã€‘å¤šæ°´ç®±ç½‘ç»œçš„åˆ†å¸ƒå¼ååŒæ§åˆ¶ â­â­â­â­â­
**éš¾åº¦ç­‰çº§ï¼š** é«˜çº§  
**å·¥ç¨‹èƒŒæ™¯ï¼š** åŸå¸‚ä¾›æ°´ç½‘ç»œä¸­å¤šä¸ªæ°´ç®±éœ€è¦ååŒæ§åˆ¶

#### é—®é¢˜æè¿°
åŸå¸‚æœ‰5ä¸ªåˆ†å¸ƒå¼æ°´ç®±ï¼Œé€šè¿‡ç®¡ç½‘è¿æ¥ï¼Œå„æ°´ç®±æœ‰ä¸åŒçš„ä¾›æ°´ä»»åŠ¡ï¼Œéœ€è¦è®¾è®¡åˆ†å¸ƒå¼æ§åˆ¶ç­–ç•¥ï¼Œåœ¨æ»¡è¶³å„è‡ªæ°´ä½è¦æ±‚çš„åŒæ—¶ï¼Œä¼˜åŒ–å…¨å±€èƒ½è€—å’Œä¾›æ°´å…¬å¹³æ€§ã€‚

#### æ¶‰åŠç†è®º
- **åˆ†å¸ƒå¼æ§åˆ¶**ï¼šå¤šæ™ºèƒ½ä½“ç³»ç»Ÿã€ä¸€è‡´æ€§åè®®
- **ç½‘ç»œæ‹“æ‰‘**ï¼šå›¾è®ºåŸºç¡€ã€é€šä¿¡æ‹“æ‰‘å¯¹æ§åˆ¶æ€§èƒ½çš„å½±å“
- **ååŒä¼˜åŒ–**ï¼šADMMï¼ˆAlternating Direction Method of Multipliersï¼‰
- **é²æ£’æ€§**ï¼šé€šä¿¡å»¶è¿Ÿã€ä¸¢åŒ…çš„å½±å“

#### å­¦ä¹ ç›®æ ‡
1. ç†è§£é›†ä¸­å¼æ§åˆ¶ä¸åˆ†å¸ƒå¼æ§åˆ¶çš„åŒºåˆ«
2. æŒæ¡ä¸€è‡´æ€§åè®®çš„è®¾è®¡
3. å­¦ä¹ åˆ†å¸ƒå¼ä¼˜åŒ–ç®—æ³•ï¼ˆADMMï¼‰
4. ç†è§£é€šä¿¡ç½‘ç»œå¯¹æ§åˆ¶æ€§èƒ½çš„å½±å“

#### å®éªŒå†…å®¹
- **ä»¿çœŸå®éªŒ11.1**ï¼š5æ°´ç®±ç½‘ç»œå»ºæ¨¡
- **ä»¿çœŸå®éªŒ11.2**ï¼šé›†ä¸­å¼MPC vs åˆ†å¸ƒå¼MPCå¯¹æ¯”
- **ä»¿çœŸå®éªŒ11.3**ï¼šä¸€è‡´æ€§åè®®ä¸‹çš„æ°´ä½åŒæ­¥
- **ä»¿çœŸå®éªŒ11.4**ï¼šé€šä¿¡å»¶è¿Ÿå’Œä¸¢åŒ…çš„å½±å“
- **ä»¿çœŸå®éªŒ11.5**ï¼šæ•…éšœæƒ…å†µä¸‹çš„è‡ªé€‚åº”é‡æ„

#### åˆ†å¸ƒå¼æ§åˆ¶å®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰

```python
class DistributedWaterTankNetwork:
    """åˆ†å¸ƒå¼æ°´ç®±ç½‘ç»œæ§åˆ¶ç³»ç»Ÿ"""
    
    def __init__(self, n_tanks, adjacency_matrix, tank_params):
        """
        Args:
            n_tanks: æ°´ç®±æ•°é‡
            adjacency_matrix: é€šä¿¡æ‹“æ‰‘çŸ©é˜µï¼ˆnÃ—nï¼‰
            tank_params: å„æ°´ç®±å‚æ•°åˆ—è¡¨
        """
        self.n = n_tanks
        self.A_comm = adjacency_matrix  # é€šä¿¡æ‹“æ‰‘
        self.tanks = [SingleTank(**params) for params in tank_params]
        
        # å„æ°´ç®±çš„æœ¬åœ°æ§åˆ¶å™¨
        self.local_controllers = [None] * n_tanks
        
        # ä¸€è‡´æ€§åè®®å‚æ•°
        self.consensus_gain = 0.1
        
    def design_local_controllers(self, Q, R, N):
        """ä¸ºæ¯ä¸ªæ°´ç®±è®¾è®¡æœ¬åœ°MPCæ§åˆ¶å™¨"""
        for i in range(self.n):
            A, B, C, D = self.tanks[i].get_state_space()
            self.local_controllers[i] = MPCController(A, B, C, Q, R, N, dt=0.1)
    
    def consensus_step(self, states, setpoints):
        """ä¸€è‡´æ€§åè®®æ›´æ–°ï¼ˆä¿¡æ¯äº¤æ¢ï¼‰
        
        ç›®æ ‡ï¼šç›¸é‚»æ°´ç®±çš„æ°´ä½å·®è·é€æ¸å‡å°
        """
        new_setpoints = setpoints.copy()
        
        for i in range(self.n):
            # ä»é‚»å±…æ”¶é›†ä¿¡æ¯
            neighbors = np.where(self.A_comm[i, :] > 0)[0]
            
            if len(neighbors) > 0:
                # ä¸€è‡´æ€§æ›´æ–°ï¼šå‘é‚»å±…å¹³å‡å€¼é æ‹¢
                neighbor_avg = np.mean([states[j] for j in neighbors])
                consensus_term = self.consensus_gain * (neighbor_avg - states[i])
                
                # ä¿®æ­£æœ¬åœ°è®¾å®šå€¼
                new_setpoints[i] += consensus_term
        
        return new_setpoints
    
    def distributed_control_loop(self, duration, dt, global_objective='fairness'):
        """åˆ†å¸ƒå¼æ§åˆ¶ä¸»å¾ªç¯"""
        t = np.arange(0, duration, dt)
        n_steps = len(t)
        
        # çŠ¶æ€è®°å½•
        states = np.zeros((n_steps, self.n))
        controls = np.zeros((n_steps, self.n))
        setpoints_history = np.zeros((n_steps, self.n))
        
        # åˆå§‹æ¡ä»¶
        states[0, :] = [2.0, 2.5, 1.8, 3.0, 2.2]  # å„æ°´ç®±åˆå§‹æ°´ä½
        setpoints = np.array([3.0] * self.n)  # åˆå§‹ç›®æ ‡
        
        for k in range(1, n_steps):
            # 1. ä¸€è‡´æ€§åè®®æ›´æ–°ï¼ˆå…¨å±€ç›®æ ‡ï¼šå…¬å¹³æ€§ï¼‰
            if global_objective == 'fairness':
                setpoints = self.consensus_step(states[k-1, :], setpoints)
            
            # 2. å„æ°´ç®±æœ¬åœ°æ§åˆ¶ï¼ˆå¹¶è¡Œæ‰§è¡Œï¼‰
            for i in range(self.n):
                x_current = states[k-1, i]
                x_ref = setpoints[i]
                
                # æœ¬åœ°MPC
                u, _, _ = self.local_controllers[i].compute(
                    np.array([x_current]),
                    np.array([x_ref])
                )
                controls[k-1, i] = u[0] if isinstance(u, np.ndarray) else u
            
            # 3. ç³»ç»Ÿæ¼”åŒ–
            for i in range(self.n):
                # æœ¬æ°´ç®±åŠ¨æ€
                Q_in = self.tanks[i].K * controls[k-1, i]
                Q_out = states[k-1, i] / self.tanks[i].R if states[k-1, i] > 0 else 0
                
                # ä¸é‚»å±…çš„æ°´æµäº¤æ¢ï¼ˆç®€åŒ–æ¨¡å‹ï¼‰
                neighbors = np.where(self.A_comm[i, :] > 0)[0]
                for j in neighbors:
                    flow_ij = 0.1 * (states[k-1, i] - states[k-1, j])  # å‹å·®é©±åŠ¨
                    Q_out += flow_ij
                
                dx = (Q_in - Q_out) / self.tanks[i].A
                states[k, i] = states[k-1, i] + dx * dt
            
            setpoints_history[k, :] = setpoints
        
        return t, states, controls, setpoints_history
    
    def visualize_network_dynamics(self, t, states, setpoints):
        """å¯è§†åŒ–ç½‘ç»œåŠ¨æ€"""
        fig, axes = plt.subplots(2, 1, figsize=(14, 10))
        
        # å­å›¾1ï¼šå„æ°´ç®±æ°´ä½
        for i in range(self.n):
            axes[0].plot(t, states[:, i], label=f'Tank {i+1}', linewidth=2)
            axes[0].plot(t, setpoints[:, i], '--', alpha=0.5)
        
        axes[0].set_ylabel('Water Level (m)')
        axes[0].legend(ncol=5)
        axes[0].grid()
        axes[0].set_title('Distributed Control - All Tanks')
        
        # å­å›¾2ï¼šæ°´ä½æ–¹å·®ï¼ˆè¡¡é‡å…¬å¹³æ€§ï¼‰
        variance = np.var(states, axis=1)
        axes[1].plot(t, variance, linewidth=2, color='red')
        axes[1].set_xlabel('Time (s)')
        axes[1].set_ylabel('Water Level Variance')
        axes[1].grid()
        axes[1].set_title('Fairness Metric (lower is better)')
        
        plt.tight_layout()
        plt.show()
```

---

### ã€æ¡ˆä¾‹12ã€‘å·¥ä¸šåº”ç”¨ç»¼åˆæ¡ˆä¾‹ï¼šæ™ºèƒ½æ°´å‚æ•°å­—å­ªç”Ÿç³»ç»Ÿ â­â­â­â­â­
**éš¾åº¦ç­‰çº§ï¼š** ç»¼åˆï¼ˆé›†å¤§æˆï¼‰  
**å·¥ç¨‹èƒŒæ™¯ï¼š** çœŸå®æ°´å¤„ç†å‚çš„å®Œæ•´æ•°å­—å­ªç”Ÿç³»ç»Ÿå¼€å‘

#### é—®é¢˜æè¿°
ä¸ºæŸå¸‚æ°´å¤„ç†å‚å¼€å‘å®Œæ•´çš„æ•°å­—å­ªç”Ÿç³»ç»Ÿï¼ŒåŒ…å«ï¼š
- 5ä¸ªå¤„ç†æ± ï¼ˆåŸæ°´æ± ã€æ··å‡æ± ã€æ²‰æ·€æ± Ã—2ã€æ¸…æ°´æ± ï¼‰
- å¤šä¸ªæ³µç«™å’Œé˜€é—¨
- å…¨è‡ªåŠ¨æ§åˆ¶ï¼ˆå¤šçº§PID + MPCï¼‰
- å®æ—¶ç›‘æ§å’Œæ•…éšœé¢„è­¦
- èƒ½è€—ä¼˜åŒ–
- æ°´è´¨é¢„æµ‹

#### æ¶‰åŠç†è®ºï¼ˆç»¼åˆåº”ç”¨ï¼‰
- **å»ºæ¨¡**ï¼šå¤šæ± è€¦åˆçš„å¤æ‚ç³»ç»Ÿå»ºæ¨¡
- **è¾¨è¯†**ï¼šåœ¨çº¿å‚æ•°è‡ªé€‚åº”
- **æ§åˆ¶**ï¼šåˆ†å±‚æ§åˆ¶æ¶æ„ï¼ˆä¸Šå±‚MPC + ä¸‹å±‚PIDï¼‰
- **å­ªç”Ÿ**ï¼šå®æ—¶åŒæ­¥ã€é¢„æµ‹æ€§ç»´æŠ¤
- **ä¼˜åŒ–**ï¼šèƒ½è€—ä¼˜åŒ–ã€è°ƒåº¦ä¼˜åŒ–
- **å¯è§†åŒ–**ï¼š3Då¯è§†åŒ–ã€å®æ—¶ä»ªè¡¨ç›˜

#### ç³»ç»Ÿæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              æ•°å­—å­ªç”Ÿç³»ç»Ÿæ€»ä½“æ¶æ„                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚  â”‚ ç‰©ç†æ°´å‚      â”‚â—„â”€â”€â”€â”€â–ºâ”‚  æ•°æ®é‡‡é›†å±‚   â”‚                â”‚
â”‚  â”‚ (ä¼ æ„Ÿå™¨/æ‰§è¡Œå™¨)â”‚      â”‚ (SCADA/PLC)  â”‚                â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                             â”‚                           â”‚
â”‚                             â–¼                           â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚                    â”‚ é€šä¿¡æ¥å£å±‚    â”‚                    â”‚
â”‚                    â”‚ (MQTT/OPC-UA)â”‚                    â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                             â”‚                           â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚         â–¼                   â–¼                   â–¼      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ æ•°å­—å­ªç”Ÿå¼•æ“â”‚   â”‚ æ§åˆ¶ç®—æ³•å±‚  â”‚   â”‚  æ•°æ®åˆ†æå±‚  â”‚  â”‚
â”‚  â”‚ (å®æ—¶ä»¿çœŸ)  â”‚   â”‚(MPC/PID)    â”‚   â”‚(æœºå™¨å­¦ä¹ )    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                   â”‚                   â”‚      â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                             â–¼                           â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚                    â”‚  åº”ç”¨æœåŠ¡å±‚   â”‚                    â”‚
â”‚                    â”‚ (é¢„è­¦/ä¼˜åŒ–)  â”‚                    â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                             â”‚                           â”‚
â”‚                             â–¼                           â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚                    â”‚ å¯è§†åŒ–å±•ç¤ºå±‚  â”‚                    â”‚
â”‚                    â”‚ (Web Dashboard)â”‚                  â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å…³é”®æ¨¡å—å®ç°ï¼ˆæ¡†æ¶ï¼‰

```python
class SmartWaterPlantDigitalTwin:
    """æ™ºèƒ½æ°´å‚æ•°å­—å­ªç”Ÿç³»ç»Ÿï¼ˆç»¼åˆæ¡ˆä¾‹ï¼‰"""
    
    def __init__(self, config_file):
        self.config = self.load_config(config_file)
        
        # 1. ç‰©ç†æ¨¡å‹
        self.plant_model = self._build_plant_model()
        
        # 2. æ§åˆ¶ç³»ç»Ÿ
        self.hierarchical_controller = self._build_controller()
        
        # 3. æ•°å­—å­ªç”Ÿå¼•æ“
        self.twin_engine = WaterTankDigitalTwin(
            physical_system=None,  # è¿æ¥çœŸå®ç³»ç»Ÿ
            model_params=self.config['model_params']
        )
        
        # 4. æ•°æ®åˆ†æ
        self.ml_predictor = WaterQualityPredictor()
        
        # 5. ä¼˜åŒ–è°ƒåº¦
        self.optimizer = EnergyOptimizer()
        
        # 6. å¯è§†åŒ–
        self.dashboard = WebDashboard(port=8050)
    
    def _build_plant_model(self):
        """æ„å»º5æ± è€¦åˆæ¨¡å‹"""
        # å®šä¹‰å„æ± å‚æ•°
        pools = {
            'raw_water': {'A': 10.0, 'R': 5.0},
            'coagulation': {'A': 5.0, 'R': 3.0},
            'sedimentation_1': {'A': 8.0, 'R': 4.0},
            'sedimentation_2': {'A': 8.0, 'R': 4.0},
            'clear_water': {'A': 12.0, 'R': 6.0}
        }
        
        # æ„å»ºçŠ¶æ€ç©ºé—´æ¨¡å‹ï¼ˆ5çŠ¶æ€ï¼Œ3è¾“å…¥ï¼‰
        # ... è¯¦ç»†å®ç° ...
        pass
    
    def _build_controller(self):
        """æ„å»ºåˆ†å±‚æ§åˆ¶å™¨"""
        return {
            'upper_layer': MPCController(...),  # å…¨å±€ä¼˜åŒ–
            'lower_layer': {
                'pool_1': PIDController(...),
                'pool_2': PIDController(...),
                # ...
            }
        }
    
    def run_realtime_simulation(self):
        """å®æ—¶è¿è¡Œæ•°å­—å­ªç”Ÿ"""
        while True:
            # 1. ä»SCADAé‡‡é›†æ•°æ®
            sensor_data = self.acquire_sensor_data()
            
            # 2. æ•°å­—å­ªç”ŸåŒæ­¥
            twin_state = self.twin_engine.sync_step(...)
            
            # 3. æ§åˆ¶å†³ç­–
            control_output = self.hierarchical_controller.compute(...)
            
            # 4. å‘é€æ§åˆ¶æŒ‡ä»¤
            self.send_control_commands(control_output)
            
            # 5. é¢„æµ‹åˆ†æ
            predictions = self.ml_predictor.predict(...)
            
            # 6. æ•…éšœæ£€æµ‹
            faults = self.twin_engine._detect_fault()
            
            # 7. æ›´æ–°å¯è§†åŒ–
            self.dashboard.update(sensor_data, twin_state, predictions, faults)
            
            time.sleep(0.1)  # 100msé‡‡æ ·å‘¨æœŸ
    
    def optimize_energy_consumption(self, horizon=24):
        """èƒ½è€—ä¼˜åŒ–ï¼ˆ24å°æ—¶è°ƒåº¦ï¼‰"""
        # è€ƒè™‘åˆ†æ—¶ç”µä»·ã€éœ€æ±‚é¢„æµ‹ã€è®¾å¤‡çº¦æŸ
        schedule = self.optimizer.solve(
            demand_forecast=...,
            electricity_price=...,
            constraints=...
        )
        return schedule
```

#### å­¦ç”Ÿç»¼åˆè®¾è®¡é¡¹ç›®è¦æ±‚

**é¡¹ç›®äº¤ä»˜ç‰©ï¼š**
1. **ç³»ç»Ÿå»ºæ¨¡æŠ¥å‘Š**ï¼ˆ20é¡µï¼‰
   - ç‰©ç†è¿‡ç¨‹æè¿°
   - æ•°å­¦æ¨¡å‹æ¨å¯¼
   - å‚æ•°è¾¨è¯†ç»“æœ

2. **æ§åˆ¶ç³»ç»Ÿè®¾è®¡æ–‡æ¡£**ï¼ˆ30é¡µï¼‰
   - æ§åˆ¶ç­–ç•¥é€‰å‹
   - å‚æ•°æ•´å®šè¿‡ç¨‹
   - æ€§èƒ½ä»¿çœŸç»“æœ

3. **å®Œæ•´ä»£ç ä»“åº“**ï¼ˆGitHubï¼‰
   - æ¨¡å‹ä»£ç 
   - æ§åˆ¶ç®—æ³•
   - å¯è§†åŒ–ç•Œé¢
   - å•å…ƒæµ‹è¯•

4. **æ¼”ç¤ºè§†é¢‘**ï¼ˆ10åˆ†é’Ÿï¼‰
   - ç³»ç»ŸåŠŸèƒ½æ¼”ç¤º
   - å…³é”®æŠ€æœ¯è®²è§£
   - åˆ›æ–°ç‚¹å±•ç¤º

5. **ç­”è¾©PPT**ï¼ˆ15-20é¡µï¼‰

**è¯„åˆ†æ ‡å‡†ï¼š**
- å»ºæ¨¡å‡†ç¡®æ€§ï¼ˆ20åˆ†ï¼‰
- æ§åˆ¶æ€§èƒ½ï¼ˆ25åˆ†ï¼‰
- æ•°å­—å­ªç”ŸåŠŸèƒ½ï¼ˆ20åˆ†ï¼‰
- ä»£ç è´¨é‡ï¼ˆ15åˆ†ï¼‰
- æ–‡æ¡£å®Œæ•´æ€§ï¼ˆ10åˆ†ï¼‰
- åˆ›æ–°ä¸å±•ç¤ºï¼ˆ10åˆ†ï¼‰

---

## ğŸ“Š æ¡ˆä¾‹ä½“ç³»æ€»è§ˆè¡¨

| æ¡ˆä¾‹ç¼–å· | æ¡ˆä¾‹åç§° | éš¾åº¦ | æ ¸å¿ƒç†è®º | å®éªŒç±»å‹ | å­¦æ—¶ |
|---------|---------|------|---------|---------|------|
| æ¡ˆä¾‹1 | å®¶åº­æ°´å¡”è‡ªåŠ¨ä¾›æ°´ | â­ | ä¸€é˜¶ç³»ç»Ÿã€å¼€å…³æ§åˆ¶ | ä»¿çœŸ+ç¡¬ä»¶ | 4 |
| æ¡ˆä¾‹2 | å·¥ä¸šå†·å´å¡”ç²¾ç¡®æ§åˆ¶ | â­â­ | æ¯”ä¾‹æ§åˆ¶ã€æ€§èƒ½æŒ‡æ ‡ | ä»¿çœŸ+ç¡¬ä»¶ | 4 |
| æ¡ˆä¾‹3 | ä¾›æ°´æ³µç«™æ— é™å·®æ§åˆ¶ | â­â­ | PIæ§åˆ¶ã€æŠ—é¥±å’Œ | ä»¿çœŸ+ç¡¬ä»¶ | 4 |
| æ¡ˆä¾‹4 | åŒæ°´ç®±ä¸²è”ç³»ç»Ÿ | â­â­â­ | äºŒé˜¶ç³»ç»Ÿã€PIDæ•´å®š | ä»¿çœŸ+ç¡¬ä»¶ | 6 |
| æ¡ˆä¾‹5 | å¤šæ°´ç®±ç½‘ç»œå»ºæ¨¡ | â­â­â­ | çŠ¶æ€ç©ºé—´ã€å¯æ§å¯è§‚ | ä»¿çœŸ | 6 |
| æ¡ˆä¾‹6 | ç³»ç»Ÿå‚æ•°è¾¨è¯† | â­â­â­ | æœ€å°äºŒä¹˜ã€æ¨¡å‹éªŒè¯ | ä»¿çœŸ+ç¡¬ä»¶ | 6 |
| æ¡ˆä¾‹7 | æ•°å­—å­ªç”Ÿå¹³å° | â­â­â­â­ | å¡å°”æ›¼æ»¤æ³¢ã€æ•…éšœæ£€æµ‹ | ä»¿çœŸ+ç¡¬ä»¶ | 8 |
| æ¡ˆä¾‹8 | çŠ¶æ€åé¦ˆä¸LQR | â­â­â­â­ | æœ€ä¼˜æ§åˆ¶ã€è§‚æµ‹å™¨ | ä»¿çœŸ | 6 |
| æ¡ˆä¾‹9 | çº¦æŸMPCæ§åˆ¶ | â­â­â­â­â­ | æ¨¡å‹é¢„æµ‹æ§åˆ¶ | ä»¿çœŸ+ç¡¬ä»¶ | 8 |
| æ¡ˆä¾‹10 | åœ¨ç¯æµ‹è¯• | â­â­â­â­ | SIL/HILã€å®æ—¶æ€§ | ç¡¬ä»¶ä¸ºä¸» | 6 |
| æ¡ˆä¾‹11 | åˆ†å¸ƒå¼ååŒæ§åˆ¶ | â­â­â­â­â­ | å¤šæ™ºèƒ½ä½“ã€ä¸€è‡´æ€§ | ä»¿çœŸ | 8 |
| æ¡ˆä¾‹12 | æ™ºèƒ½æ°´å‚ç»¼åˆæ¡ˆä¾‹ | â­â­â­â­â­ | ç»¼åˆåº”ç”¨ | ç»¼åˆé¡¹ç›® | 12 |
| **æ€»è®¡** | | | | | **78å­¦æ—¶** |

---

## ğŸ“ æ•™å­¦å®æ–½å»ºè®®

### æ•™å­¦æ¨¡å¼ï¼šç¿»è½¬è¯¾å ‚ + é¡¹ç›®é©±åŠ¨

#### è¯¾å‰ï¼ˆè‡ªä¸»å­¦ä¹ ï¼‰
- è§‚çœ‹æ¡ˆä¾‹èƒŒæ™¯è§†é¢‘ï¼ˆ5-10åˆ†é’Ÿï¼‰
- é˜…è¯»ç†è®ºææ–™ï¼ˆæ•™æç« èŠ‚ï¼‰
- è¿è¡ŒåŸºç¡€Jupyter Notebookï¼ˆé¢„ä¹ æ€§å®éªŒï¼‰

#### è¯¾ä¸­ï¼ˆè¯¾å ‚æ´»åŠ¨ï¼Œ2å­¦æ—¶/æ¡ˆä¾‹ï¼‰
- **ç¬¬1å­¦æ—¶**ï¼š
  - æ¡ˆä¾‹é—®é¢˜è®¨è®ºï¼ˆ15åˆ†é’Ÿï¼‰
  - æ•™å¸ˆè®²è§£æ ¸å¿ƒç†è®ºï¼ˆ30åˆ†é’Ÿï¼‰
  - å»ºæ¨¡æ¼”ç¤ºä¸ä»£ç è®²è§£ï¼ˆ20åˆ†é’Ÿï¼‰
- **ç¬¬2å­¦æ—¶**ï¼š
  - å­¦ç”Ÿåˆ†ç»„å®éªŒï¼ˆ40åˆ†é’Ÿï¼‰
  - ç»“æœå±•ç¤ºä¸è®¨è®ºï¼ˆ20åˆ†é’Ÿï¼‰
  - æ€»ç»“ä¸ä½œä¸šå¸ƒç½®ï¼ˆ5åˆ†é’Ÿï¼‰

#### è¯¾åï¼ˆå·©å›ºæå‡ï¼‰
- å®ŒæˆJupyter Notebookçš„æ‰©å±•ç»ƒä¹ 
- æ’°å†™å®éªŒæŠ¥å‘Š
- ç¡¬ä»¶å®éªŒï¼ˆé¢„çº¦å®éªŒå®¤æ—¶é—´ï¼‰

### è¯„åˆ†æƒé‡

| è¯„åˆ†é¡¹ | å æ¯” | è¯´æ˜ |
|--------|------|------|
| æ¡ˆä¾‹å®éªŒæŠ¥å‘Š | 30% | 12ä¸ªæ¡ˆä¾‹ï¼Œæ¯ä¸ª2.5åˆ† |
| æœŸä¸­è€ƒè¯• | 20% | æ¡ˆä¾‹1-6ç†è®º+ç¼–ç¨‹ |
| ç»¼åˆè®¾è®¡é¡¹ç›® | 35% | æ¡ˆä¾‹12ï¼Œåˆ†ç»„å®Œæˆ |
| è¯¾å ‚è¡¨ç° | 10% | è®¨è®ºã€æé—®ã€æ¼”ç¤º |
| åˆ›æ–°åŠ åˆ† | 5% | æ”¹è¿›ç®—æ³•ã€æ–°åŠŸèƒ½å¼€å‘ |

---

## ğŸ’» é…å¥—èµ„æºå¼€å‘æ¸…å•

### ä»£ç åº“ç»“æ„

```
water_tank_control_cases/
â”œâ”€â”€ case_01_home_water_tower/
â”‚   â”œâ”€â”€ models.py
â”‚   â”œâ”€â”€ controllers.py
â”‚   â”œâ”€â”€ simulation.py
â”‚   â”œâ”€â”€ notebook.ipynb
â”‚   â”œâ”€â”€ hardware/
â”‚   â”‚   â””â”€â”€ arduino_code.ino
â”‚   â””â”€â”€ README.md
â”œâ”€â”€ case_02_industrial_cooling/
â”‚   â”œâ”€â”€ ...
â”œâ”€â”€ ...
â”œâ”€â”€ case_12_smart_water_plant/
â”‚   â”œâ”€â”€ ...
â”œâ”€â”€ shared/
â”‚   â”œâ”€â”€ visualization.py
â”‚   â”œâ”€â”€ performance_metrics.py
â”‚   â”œâ”€â”€ hardware_interface.py
â”‚   â””â”€â”€ utils.py
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ test_case_01.py
â”‚   â”œâ”€â”€ ...
â”œâ”€â”€ requirements.txt
â”œâ”€â”€ environment.yml
â””â”€â”€ README.md
```

### Jupyter Notebookè®¾è®¡

æ¯ä¸ªæ¡ˆä¾‹é…å¥—1ä¸ªä¸»Notebook + 3-5ä¸ªè¡¥å……Notebookï¼š

**ä¸»Notebookç»“æ„**ï¼ˆçº¦100-150ä¸ªcellï¼‰ï¼š
1. **æ¡ˆä¾‹èƒŒæ™¯**ï¼ˆMarkdownï¼‰ï¼šå·¥ç¨‹æƒ…å¢ƒã€é—®é¢˜æè¿°
2. **ç†è®ºå›é¡¾**ï¼ˆMarkdown + LaTeXï¼‰ï¼šæ ¸å¿ƒå…¬å¼ï¼ˆ5-10ä¸ªé‡è¦å…¬å¼ï¼‰
3. **å»ºæ¨¡æ¨å¯¼**ï¼ˆCode + Markdownï¼‰ï¼šä¸€æ­¥æ­¥æ¨å¯¼
4. **ä»¿çœŸå®éªŒ**ï¼ˆCodeï¼‰ï¼šäº¤äº’å¼å‚æ•°è°ƒæ•´
5. **ç»“æœåˆ†æ**ï¼ˆCode + Markdownï¼‰ï¼šå¯è§†åŒ–+è®¨è®º
6. **ç»ƒä¹ é¢˜**ï¼ˆMarkdownï¼‰ï¼š3-5é“å¼•å¯¼å¼é—®é¢˜
7. **æ‰©å±•é˜…è¯»**ï¼ˆMarkdownï¼‰ï¼šè®ºæ–‡é“¾æ¥ã€å·¥ç¨‹æ¡ˆä¾‹

**è¡¥å……Notebook**ï¼š
- `case_XX_theory_deep_dive.ipynb`ï¼šç†è®ºæ·±å…¥è®²è§£
- `case_XX_parameter_tuning.ipynb`ï¼šå‚æ•°å½±å“åˆ†æ
- `case_XX_comparison.ipynb`ï¼šæ–¹æ³•å¯¹æ¯”å®éªŒ
- `case_XX_hardware_guide.ipynb`ï¼šç¡¬ä»¶å®éªŒæŒ‡å¯¼
- `case_XX_challenge.ipynb`ï¼šæŒ‘æˆ˜æ€§æ‹“å±•ä»»åŠ¡

---

## ğŸš€ å¼€å‘æ—¶é—´çº¿ï¼ˆ12ä¸ªæœˆï¼‰

| æœˆä»½ | ä¸»è¦ä»»åŠ¡ | äº¤ä»˜ç‰© |
|------|---------|--------|
| M1 | æ¡ˆä¾‹1-3å¼€å‘ | ä»£ç +3ä¸ªNotebooks |
| M2 | æ¡ˆä¾‹4-6å¼€å‘ | ä»£ç +3ä¸ªNotebooks |
| M3 | æ¡ˆä¾‹7-9å¼€å‘ | ä»£ç +3ä¸ªNotebooks |
| M4 | æ¡ˆä¾‹10-12å¼€å‘ | ä»£ç +3ä¸ªNotebooks |
| M5 | ç¡¬ä»¶å¹³å°è®¾è®¡ä¸æµ‹è¯• | ç‰©æ–™æ¸…å•+PCB+Arduinoä»£ç  |
| M6 | Webè™šæ‹Ÿå®éªŒå¹³å°å¼€å‘ | å‰ç«¯+åç«¯åŸå‹ |
| M7 | æ•™æç¼–å†™ï¼ˆç¬¬1-6ç« ï¼‰ | LaTeXè‰ç¨¿ |
| M8 | æ•™æç¼–å†™ï¼ˆç¬¬7-12ç« ï¼‰ | LaTeXè‰ç¨¿ |
| M9 | è¯¾å ‚PPTåˆ¶ä½œ | 12å¥—PPT |
| M10 | è¯•ç‚¹æ•™å­¦ä¸åé¦ˆæ”¶é›† | å­¦ç”Ÿåé¦ˆæŠ¥å‘Š |
| M11 | å†…å®¹ä¼˜åŒ–ä¸å®Œå–„ | ä¿®è®¢ç‰ˆæ‰€æœ‰èµ„æº |
| M12 | æœ€ç»ˆå®¡æ ¡ä¸å‘å¸ƒ | æ­£å¼å‡ºç‰ˆæ•™æ+å¼€æºä»£ç  |

---

## ğŸ“š é¢„æœŸæˆæœ

### 1. æ•™æå‡ºç‰ˆ
- **ä¸»æ•™æ**ï¼šã€Šæ°´ç³»ç»Ÿæ§åˆ¶è®ºï¼š12ä¸ªç»å…¸æ¡ˆä¾‹ã€‹ï¼ˆä¸­æ–‡ï¼Œ400-500é¡µï¼‰
- **é…å¥—æ•™å¸ˆæ‰‹å†Œ**ï¼šå«ç­”æ¡ˆå’Œæ•™å­¦å»ºè®®ï¼ˆ100é¡µï¼‰
- **å®éªŒæŒ‡å¯¼ä¹¦**ï¼šç¡¬ä»¶å®éªŒè¯¦ç»†æ­¥éª¤ï¼ˆ80é¡µï¼‰

### 2. å¼€æºèµ„æº
- **GitHubä»“åº“**ï¼šå®Œæ•´ä»£ç ï¼ˆ10000+ linesï¼‰
- **Jupyter Book**ï¼šåœ¨çº¿äº¤äº’å¼æ•™æ
- **YouTube/Bç«™**ï¼šæ¡ˆä¾‹è®²è§£è§†é¢‘ï¼ˆ12é›†ï¼Œæ¯é›†30-40åˆ†é’Ÿï¼‰

### 3. æ•™å­¦å¹³å°
- **Webè™šæ‹Ÿå®éªŒå¹³å°**ï¼šæ”¯æŒ500+å¹¶å‘ç”¨æˆ·
- **è‡ªåŠ¨è¯„åˆ†ç³»ç»Ÿ**ï¼šå³æ—¶åé¦ˆå­¦ç”Ÿä½œä¸š

### 4. å­¦æœ¯äº§å‡º
- æ•™å­¦ç ”ç©¶è®ºæ–‡2-3ç¯‡
- æ•™æ”¹é¡¹ç›®ç”³æŠ¥
- ç²¾å“è¯¾ç¨‹/è™šæ‹Ÿä»¿çœŸé¡¹ç›®ç”³æŠ¥

---

## âœ… æ€»ç»“

æœ¬æ–¹æ¡ˆé‡‡ç”¨**æ¡ˆä¾‹é©±åŠ¨æ•™å­¦æ³•**ï¼Œä»¥12ä¸ªç²¾å¿ƒè®¾è®¡çš„æ°´ç®±æ¡ˆä¾‹ä¸ºä¸»çº¿ï¼Œæ¶µç›–ä»å…¥é—¨åˆ°é«˜çº§çš„å®Œæ•´çŸ¥è¯†ä½“ç³»ã€‚æ¯ä¸ªæ¡ˆä¾‹éƒ½æ˜¯ä¸€ä¸ªå®Œæ•´çš„å·¥ç¨‹æ•…äº‹ï¼Œå­¦ç”Ÿåœ¨è§£å†³å®é™…é—®é¢˜ä¸­è‡ªç„¶åœ°å­¦ä¹ æ§åˆ¶ç†è®ºï¼ŒçœŸæ­£å®ç°"åšä¸­å­¦"ã€‚

### æ ¸å¿ƒä¼˜åŠ¿
1. **æ¸è¿›å¼éš¾åº¦**ï¼šä»ç®€å•åˆ°å¤æ‚ï¼Œç¬¦åˆè®¤çŸ¥è§„å¾‹
2. **å®Œæ•´çŸ¥è¯†é“¾**ï¼šå»ºæ¨¡â†’ä»¿çœŸâ†’è¾¨è¯†â†’æ§åˆ¶â†’å­ªç”Ÿâ†’æµ‹è¯•
3. **ç†å®ä¸€ä½“**ï¼šæ¯ä¸ªæ¡ˆä¾‹éƒ½æœ‰ä»¿çœŸå’Œç¡¬ä»¶å®éªŒ
4. **å¼€æºå…±äº«**ï¼šæƒ åŠæ›´å¤šå­¦ä¹ è€…
5. **å·¥ä¸šç›¸å…³**ï¼šæ¡ˆä¾‹æºè‡ªçœŸå®å·¥ç¨‹é—®é¢˜

### åˆ›æ–°ç‚¹
- å›½å†…é¦–ä¸ªä»¥å•ä¸€å¯¹è±¡ï¼ˆæ°´ç®±ï¼‰è´¯ç©¿å…¨æ•™ç¨‹çš„æ§åˆ¶è®ºæ•™æ
- èåˆæ•°å­—å­ªç”Ÿã€åœ¨ç¯æµ‹è¯•ç­‰å‰æ²¿æŠ€æœ¯
- æä¾›å®Œæ•´çš„å¼€æºä»£ç å’Œè™šæ‹Ÿå®éªŒå¹³å°
- é‡‡ç”¨Jupyter Notebookäº¤äº’å¼æ•™å­¦

**è®©æˆ‘ä»¬ä¸€èµ·å¼€å¯æ°´ç³»ç»Ÿæ§åˆ¶è®ºçš„ç²¾å½©ä¹‹æ—…ï¼** ğŸš€ğŸ’§
