# 立即开始指南 - 水系统控制论教材开发

**适用人员：** 准备开发零基础友好教材的团队  
**预计时间：** 第一周的具体操作步骤  
**目标：** 完成环境准备，开始第一个案例

---

## 📋 完成情况总结

### ✅ 已完成的工作

1. **方案文档**（共3个文档，100KB+内容）
   - ✅ `/workspace/docs/zh/水系统控制论教材开发方案.md` - 传统12章理论体系
   - ✅ `/workspace/docs/zh/水箱案例驱动教学体系.md` - 12个递进式案例（**推荐**）
   - ✅ `/workspace/docs/zh/零基础教材开发详细方案.md` - 面向高中基础学生的详细指南
   - ✅ `/workspace/docs/zh/教材开发方案总结.md` - 方案对比与选择建议
   - ✅ `/workspace/docs/zh/立即开始指南.md` - 本文档

2. **代码清理准备**
   - ✅ 创建了清理脚本 `/workspace/scripts/cleanup_complex_models.py`
   - ✅ 分析了现有水力学模型
   - ✅ 标识了需要保留和删除的部分

3. **案例编写模板**
   - ✅ 7部分标准结构（背景、问题、原理、方法、建模、结果、讨论）
   - ✅ 每部分的详细要求和示例
   - ✅ 代码规范和绘图规范

---

## 🎯 本周任务（第1周）

### Day 1-2：代码清理与备份

#### 任务1.1：运行清理分析
```bash
cd /workspace
python3 scripts/cleanup_complex_models.py
```

**预期输出：**
- 备份目录：`/workspace/backup/hydraulic_models_YYYYMMDD_HHMMSS/`
- 清理报告：`CLEANUP_REPORT.md`
- 弃用说明：`DEPRECATION_NOTICE.md`

#### 任务1.2：手动清理（谨慎操作）

**保留的文件：**
```python
# src/simulation/hydraulic_models.py
# 只保留 HydraulicModel 基类和 LevelPoolModel

class HydraulicModel:
    """保留"""
    pass

class LevelPoolModel(HydraulicModel):
    """保留 - 这是简单的水平池模型"""
    pass

class DynamicWaveModel(HydraulicModel):
    """删除或注释掉"""
    pass
```

**删除或归档的文件：**
- `src/simulation/fvm_hydraulic_models.py` - 过于复杂，移至 `backup/`

**操作步骤：**
```bash
# 1. 再次确认备份已完成
ls -lh /workspace/backup/

# 2. 注释掉复杂模型（保守方案）
# 在 hydraulic_models.py 中的 DynamicWaveModel 前加上：
# """
# ⚠️ DEPRECATED - 此模型过于复杂，不推荐使用
# 请使用 LevelPoolModel 或教学专用的 SingleTankModel
# """

# 3. 移动 FVM 文件到归档目录
mkdir -p /workspace/archive
mv /workspace/src/simulation/fvm_hydraulic_models.py /workspace/archive/

# 4. 更新 __init__.py，移除复杂模型的导入
# 编辑 src/simulation/__init__.py
```

#### 任务1.3：运行现有测试
```bash
cd /workspace
python3 -m pytest tests/ -v --tb=short
```

**如果测试失败：**
1. 查看失败的测试
2. 更新测试，移除对复杂模型的依赖
3. 记录需要修复的功能

---

### Day 3：创建教学模型基础设施

#### 任务3.1：创建目录结构
```bash
cd /workspace

# 创建教学模型目录
mkdir -p src/models/water_tank
touch src/models/water_tank/__init__.py

# 创建案例代码目录
mkdir -p examples/textbook_cases/case_01_home_water_tower
mkdir -p examples/textbook_cases/shared

# 创建Jupyter Notebook目录
mkdir -p notebooks/textbook/case_01

# 创建测试目录
mkdir -p tests/standard_cases
mkdir -p tests/models/water_tank

# 创建硬件实验目录
mkdir -p hardware/arduino/case_01
```

#### 任务3.2：创建第一个教学模型

**文件：** `src/models/water_tank/single_tank.py`

```python
"""
单水箱模型 - 教学专用

这是专门为教学设计的简化模型，特点：
1. 极简实现，容易理解
2. 详细注释，每行都解释
3. 适合高中物理基础的学生
4. 可直接用于仿真和控制实验
"""

import numpy as np


class SingleTank:
    """
    单水箱模型
    
    基于物理原理：
    - 质量守恒：dV/dt = Q_in - Q_out
    - 几何关系：V = A × h
    - 流出规律：Q_out = h / R（线性近似）
    
    适用场景：
    - 家庭水塔
    - 工业储罐
    - 水位控制系统教学
    """
    
    def __init__(self, A=2.0, R=2.0, K=1.0):
        """
        初始化水箱
        
        参数：
            A (float): 横截面积（单位：平方米 m²）
                - 默认 2.0 m² （相当于边长约1.4米的正方形）
                - 越大，水位变化越慢
            
            R (float): 出口阻力系数（单位：分钟/平方米 min/m²）
                - 默认 2.0 min/m²
                - 越大，出水越慢
                - 物理意义：Q_out = h / R
            
            K (float): 泵增益（单位：立方米每分钟 m³/min）
                - 默认 1.0
                - 表示泵的抽水能力
                - 实际流量 = K × 控制信号(0-1)
        
        示例：
            >>> tank = SingleTank(A=2.0, R=2.0, K=1.0)
            >>> print(tank)
            单水箱: A=2.00m², R=2.00min/m², K=1.00m³/min
        """
        # 参数检查
        if A <= 0:
            raise ValueError(f"横截面积必须大于0，当前值：{A}")
        if R <= 0:
            raise ValueError(f"阻力系数必须大于0，当前值：{R}")
        if K < 0:
            raise ValueError(f"泵增益不能为负，当前值：{K}")
        
        self.A = A  # 横截面积
        self.R = R  # 阻力系数
        self.K = K  # 泵增益
        
        # 计算特性参数（用于分析）
        self.tau = A * R  # 时间常数（秒）
        self.steady_state_gain = K * R  # 稳态增益
        
        # 初始状态
        self.h = 2.0  # 初始水位 2米
        self.t = 0.0  # 仿真时间
    
    def compute_flow_out(self, h):
        """
        计算出水流量
        
        物理模型：Q_out = h / R
        - 水位越高，压力越大，出水越快
        - 线性化近似（实际可能是平方根关系）
        
        参数：
            h (float): 当前水位（米）
        
        返回：
            float: 出水流量（m³/min）
        """
        if h <= 0:
            return 0.0  # 没水了，不能再流出
        
        Q_out = h / self.R
        return Q_out
    
    def compute_level_change_rate(self, h, Q_in):
        """
        计算水位变化速度 dh/dt
        
        推导过程：
        1. 质量守恒：dV/dt = Q_in - Q_out
        2. 几何关系：V = A × h，所以 dV/dt = A × dh/dt
        3. 代入得：A × dh/dt = Q_in - Q_out
        4. 两边除以A：dh/dt = (Q_in - Q_out) / A
        
        参数：
            h (float): 当前水位（米）
            Q_in (float): 入水流量（m³/min）
        
        返回：
            float: 水位变化速度（m/min）
        """
        Q_out = self.compute_flow_out(h)
        dh_dt = (Q_in - Q_out) / self.A
        return dh_dt
    
    def step(self, u, dt=0.1):
        """
        推进一个时间步长（欧拉法）
        
        数值方法：显式欧拉法
        - h_new = h_old + dh/dt × dt
        - 简单但要求dt足够小
        
        参数：
            u (float): 控制输入（0-1之间，0=关泵，1=全速）
            dt (float): 时间步长（分钟），默认0.1分钟=6秒
        
        返回：
            float: 更新后的水位（米）
        
        示例：
            >>> tank = SingleTank()
            >>> tank.h = 2.0  # 初始水位2米
            >>> new_h = tank.step(u=0.5, dt=0.1)  # 50%功率抽水
            >>> print(f"新水位: {new_h:.3f}米")
        """
        # 限制控制输入在合理范围内
        u = np.clip(u, 0.0, 1.0)
        
        # 计算实际流入量
        Q_in = self.K * u
        
        # 计算水位变化速度
        dh_dt = self.compute_level_change_rate(self.h, Q_in)
        
        # 更新水位（欧拉法）
        self.h = self.h + dh_dt * dt
        
        # 水位不能为负
        self.h = max(0.0, self.h)
        
        # 更新时间
        self.t += dt
        
        return self.h
    
    def reset(self, h0=2.0):
        """
        重置水箱状态
        
        参数：
            h0 (float): 初始水位（米），默认2.0米
        """
        self.h = h0
        self.t = 0.0
    
    def get_state_space_matrices(self):
        """
        返回状态空间表示
        
        状态方程：dh/dt = -h/(A×R) + (K/A)×u
        输出方程：y = h
        
        矩阵形式：
        - A = -1/(A×R) = -1/τ
        - B = K/A
        - C = 1
        - D = 0
        
        返回：
            tuple: (A, B, C, D) 状态空间矩阵
        
        用途：
        - 控制系统设计（LQR、极点配置等）
        - 可控性、可观性分析
        - 传递函数计算
        """
        A_matrix = np.array([[-1.0 / self.tau]])
        B_matrix = np.array([[self.K / self.A]])
        C_matrix = np.array([[1.0]])
        D_matrix = np.array([[0.0]])
        
        return A_matrix, B_matrix, C_matrix, D_matrix
    
    def get_transfer_function(self):
        """
        返回传递函数参数
        
        传递函数：G(s) = K_dc / (τ×s + 1)
        - K_dc = K × R （直流增益）
        - τ = A × R （时间常数）
        
        返回：
            dict: {'gain': K_dc, 'tau': τ}
        
        用途：
        - 频域分析
        - PID参数整定
        - 系统辨识验证
        """
        return {
            'gain': self.steady_state_gain,
            'tau': self.tau,
            'description': f'G(s) = {self.steady_state_gain:.2f} / ({self.tau:.2f}×s + 1)'
        }
    
    def __repr__(self):
        """字符串表示"""
        return (f"SingleTank(A={self.A:.2f}m², R={self.R:.2f}min/m², "
                f"K={self.K:.2f}m³/min, h={self.h:.2f}m)")
    
    def __str__(self):
        """用户友好的字符串"""
        return (f"单水箱: 横截面积{self.A:.2f}m², 阻力系数{self.R:.2f}min/m², "
                f"泵增益{self.K:.2f}m³/min, 当前水位{self.h:.2f}m")


# ============================================================================
# 以下是辅助函数，用于教学演示
# ============================================================================

def simulate_open_loop(tank, u_sequence, dt=0.1):
    """
    开环仿真（固定输入）
    
    参数：
        tank (SingleTank): 水箱对象
        u_sequence (array): 控制输入序列
        dt (float): 时间步长
    
    返回：
        tuple: (t, h, Q_in, Q_out) 时间、水位、入水、出水序列
    """
    n_steps = len(u_sequence)
    t = np.arange(n_steps) * dt
    h = np.zeros(n_steps)
    Q_in = np.zeros(n_steps)
    Q_out = np.zeros(n_steps)
    
    for i, u in enumerate(u_sequence):
        h[i] = tank.h
        Q_in[i] = tank.K * u
        Q_out[i] = tank.compute_flow_out(tank.h)
        tank.step(u, dt)
    
    return t, h, Q_in, Q_out


def simulate_closed_loop(tank, controller, duration=60, dt=0.1):
    """
    闭环仿真（带反馈控制）
    
    参数：
        tank (SingleTank): 水箱对象
        controller: 控制器对象（需要有control(h)方法）
        duration (float): 仿真时长（分钟）
        dt (float): 时间步长
    
    返回：
        tuple: (t, h, u, error) 时间、水位、控制输入、误差序列
    """
    n_steps = int(duration / dt)
    t = np.zeros(n_steps)
    h = np.zeros(n_steps)
    u = np.zeros(n_steps)
    error = np.zeros(n_steps)
    
    for i in range(n_steps):
        t[i] = tank.t
        h[i] = tank.h
        
        # 控制器计算
        u[i] = controller.control(tank.h)
        error[i] = controller.setpoint - tank.h
        
        # 水箱更新
        tank.step(u[i], dt)
    
    return t, h, u, error


if __name__ == "__main__":
    """测试代码"""
    print("=" * 60)
    print("单水箱模型测试")
    print("=" * 60)
    
    # 创建水箱
    tank = SingleTank(A=2.0, R=2.0, K=1.0)
    print(f"\n{tank}")
    print(f"时间常数: {tank.tau:.2f} 分钟")
    print(f"稳态增益: {tank.steady_state_gain:.2f}")
    
    # 测试阶跃响应
    print("\n[测试] 阶跃输入 u=1.0 (全速抽水)")
    tank.reset(h0=2.0)
    
    for i in range(5):
        h_new = tank.step(u=1.0, dt=1.0)  # 每步1分钟
        print(f"  t={tank.t:.1f}分钟, 水位={h_new:.3f}米")
    
    # 获取状态空间
    A, B, C, D = tank.get_state_space_matrices()
    print(f"\n状态空间矩阵:")
    print(f"  A = {A[0,0]:.4f}")
    print(f"  B = {B[0,0]:.4f}")
    print(f"  C = {C[0,0]:.4f}")
    print(f"  D = {D[0,0]:.4f}")
    
    # 获取传递函数
    tf = tank.get_transfer_function()
    print(f"\n传递函数: {tf['description']}")
    
    print("\n✅ 所有测试通过!")
```

保存并测试：
```bash
cd /workspace
python3 src/models/water_tank/single_tank.py
```

---

### Day 4-5：创建标准测试案例

#### 任务4.1：编写第一个标准测试

**文件：** `tests/standard_cases/test_first_order_system.py`

```python
"""
标准测试案例 TC-01: 一阶系统阶跃响应

参考：Ogata "Modern Control Engineering" Example 5-1
"""

import pytest
import numpy as np
import sys
import os

# 添加src到路径
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..'))

from src.models.water_tank.single_tank import SingleTank


class TestTC01_FirstOrderStepResponse:
    """一阶系统阶跃响应标准案例"""
    
    def test_time_constant(self):
        """
        测试时间常数
        
        理论：当 t = τ 时，输出达到最终值的 63.2%
        """
        # 创建系统: τ = A×R = 2×2 = 4分钟
        tank = SingleTank(A=2.0, R=2.0, K=1.0)
        tank.reset(h0=0.0)  # 从0开始
        
        # 单位阶跃输入
        dt = 0.01  # 小步长确保精度
        final_value = tank.steady_state_gain  # 理论最终值
        
        # 仿真到 t = τ
        target_time = tank.tau
        n_steps = int(target_time / dt)
        
        for _ in range(n_steps):
            tank.step(u=1.0, dt=dt)
        
        # 验证
        expected = 0.632 * final_value  # 63.2%
        actual = tank.h
        error = abs(actual - expected) / expected
        
        print(f"\n[TC-01] 时间常数测试:")
        print(f"  τ = {tank.tau:.2f} 分钟")
        print(f"  最终值 = {final_value:.3f} 米")
        print(f"  t=τ时期望 = {expected:.3f} 米 (63.2%)")
        print(f"  t=τ时实际 = {actual:.3f} 米")
        print(f"  相对误差 = {error*100:.2f}%")
        
        assert error < 0.02, f"时间常数测试失败：误差{error*100:.1f}%超过2%"
    
    def test_steady_state_value(self):
        """
        测试稳态值
        
        理论：t→∞ 时，输出 = K×R×u = 1.0×2.0×1.0 = 2.0
        """
        tank = SingleTank(A=2.0, R=2.0, K=1.0)
        tank.reset(h0=0.0)
        
        # 仿真足够长时间（5倍时间常数）
        dt = 0.1
        duration = 5 * tank.tau
        n_steps = int(duration / dt)
        
        for _ in range(n_steps):
            tank.step(u=1.0, dt=dt)
        
        expected = tank.steady_state_gain
        actual = tank.h
        error = abs(actual - expected)
        
        print(f"\n[TC-01] 稳态值测试:")
        print(f"  仿真时长 = {duration:.1f} 分钟 (5τ)")
        print(f"  理论稳态值 = {expected:.3f} 米")
        print(f"  实际稳态值 = {actual:.3f} 米")
        print(f"  绝对误差 = {error:.4f} 米")
        
        assert error < 0.01, f"稳态值测试失败：误差{error:.3f}米超过0.01米"
    
    def test_linearity(self):
        """
        测试线性性
        
        理论：如果输入放大2倍，输出也应放大2倍
        """
        tank1 = SingleTank(A=2.0, R=2.0, K=1.0)
        tank2 = SingleTank(A=2.0, R=2.0, K=1.0)
        
        tank1.reset(h0=0.0)
        tank2.reset(h0=0.0)
        
        # tank1: 输入 u=0.5
        # tank2: 输入 u=1.0
        dt = 0.1
        n_steps = int(5 * tank1.tau / dt)
        
        for _ in range(n_steps):
            tank1.step(u=0.5, dt=dt)
            tank2.step(u=1.0, dt=dt)
        
        # tank2的输出应该是tank1的2倍
        ratio = tank2.h / tank1.h if tank1.h > 0 else 0
        
        print(f"\n[TC-01] 线性性测试:")
        print(f"  输入u1=0.5 → 输出h1={tank1.h:.3f}米")
        print(f"  输入u2=1.0 → 输出h2={tank2.h:.3f}米")
        print(f"  比值 h2/h1 = {ratio:.3f} (期望2.0)")
        
        assert abs(ratio - 2.0) < 0.01, f"线性性测试失败：比值{ratio:.3f}不等于2.0"


if __name__ == "__main__":
    """直接运行测试"""
    pytest.main([__file__, "-v", "-s"])
```

运行测试：
```bash
cd /workspace
python3 -m pytest tests/standard_cases/test_first_order_system.py -v -s
```

---

## 📚 下周计划（第2周）

### Day 6-7：开始编写案例1

按照 `/workspace/docs/zh/零基础教材开发详细方案.md` 中的7部分模板，编写：

1. 生活场景引入
2. 问题提炼与分析
3. 物理原理（高中物理+简单推导）
4. 控制方法（开关控制、比例控制）
5. 建模与仿真（完整Python代码）
6. 结果分析与讨论
7. 总结与展望

### Day 8-9：创建Jupyter Notebook

将案例1转换为交互式Notebook，包含：
- 可运行的代码单元
- ipywidgets交互控件
- 内嵌的练习题

### Day 10：学生试用与反馈

找2-3名学生试用案例1，收集反馈：
- 哪些地方难以理解？
- 哪些图表需要改进？
- 代码注释是否足够？
- 练习题难度如何？

---

## 📞 获取帮助

如果在实施过程中遇到问题：

1. **技术问题**：查看已创建的文档
   - 模型设计：`零基础教材开发详细方案.md`
   - 案例结构：7部分模板
   - 代码规范：`single_tank.py` 示例

2. **教学问题**：参考原则
   - 假设学生只有高中基础
   - 先物理后数学
   - 大量图示和例子
   - 避免跳步

3. **进度问题**：
   - 每完成一个案例就是里程碑
   - 边开发边测试边改进
   - 不求完美，求快速迭代

---

## ✅ 本周末检查清单

在第1周结束时，您应该完成：

- [ ] 代码备份和清理分析报告
- [ ] SingleTankModel 类实现并通过测试
- [ ] TC-01 标准测试案例通过
- [ ] 案例1的大纲和部分内容
- [ ] 学生试用安排

**如果全部完成，恭喜您！您已经成功开始了这个项目。** 🎉

**继续加油，第2周我们将完成第一个完整案例！** 💪
