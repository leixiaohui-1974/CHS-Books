# 明渠非恒定流数值算法详解

**版本：** v1.0
**更新日期：** 2025-10-29
**目标读者：** 研究生、工程师、算法开发者

---

## 📐 数学基础

### 圣维南方程组（Saint-Venant Equations）

**守恒形式：**

$$
\frac{\partial \mathbf{U}}{\partial t} + \frac{\partial \mathbf{F}}{\partial x} = \mathbf{S}
$$

其中：

$$
\mathbf{U} = \begin{bmatrix} A \\ Q \end{bmatrix}, \quad
\mathbf{F} = \begin{bmatrix} Q \\ \frac{Q^2}{A} + gI_1 \end{bmatrix}, \quad
\mathbf{S} = \begin{bmatrix} 0 \\ gA(i - J) \end{bmatrix}
$$

**说明：**
- $A$：过流断面积
- $Q$：流量
- $g$：重力加速度
- $I_1 = \int_0^h (h-\eta)B(\eta)d\eta$：压力积分
- $i$：底坡
- $J$：摩阻坡度

**非守恒形式：**

连续性方程：
$$
\frac{\partial A}{\partial t} + \frac{\partial Q}{\partial x} = 0
$$

动量方程：
$$
\frac{\partial Q}{\partial t} + \frac{\partial}{\partial x}\left(\frac{Q^2}{A}\right) + gA\frac{\partial h}{\partial x} = gA(i - J)
$$

---

## 🔢 数值方法分类

### 1. 有限差分法（Finite Difference Method, FDM）

**原理：** 用差商近似微商

**分类：**
- **显式格式**：当前时刻由上一时刻显式计算
- **隐式格式**：当前时刻需要解方程组

**优点：** 编程简单，易于理解
**缺点：** 难以处理复杂边界

### 2. 特征线法（Method of Characteristics, MOC）

**原理：** 沿特征线方程变为常微分方程

**特征方程：**
$$
\frac{dx}{dt} = v \pm c
$$

其中 $c = \sqrt{gA/B}$ 为波速

**优点：** 物理意义清晰，精度高
**缺点：** 网格不规则，插值复杂

### 3. 有限体积法（Finite Volume Method, FVM）

**原理：** 守恒律积分形式

**优点：** 严格守恒，适合激波
**缺点：** 编程复杂

### 4. 有限元法（Finite Element Method, FEM）

**原理：** 变分原理

**优点：** 适合复杂几何
**缺点：** 计算量大

---

## 📊 算法详解

## 一、显式有限差分法

### 1.1 Lax格式（一阶精度）

**离散格式：**

$$
U_i^{n+1} = \frac{1}{2}(U_{i-1}^n + U_{i+1}^n) - \frac{\Delta t}{2\Delta x}(F_{i+1}^n - F_{i-1}^n) + \Delta t \cdot S_i^n
$$

**稳定性条件（CFL）：**
$$
CFL = \frac{(|v| + c)\Delta t}{\Delta x} \leq 1
$$

**优点：** 简单，稳定
**缺点：** 精度低，耗散大

**Python伪代码：**
```python
def lax_scheme(U, F, S, dt, dx):
    """Lax格式求解一步"""
    U_new = np.zeros_like(U)
    for i in range(1, len(U)-1):
        U_new[i] = 0.5 * (U[i-1] + U[i+1]) \
                   - 0.5 * dt/dx * (F[i+1] - F[i-1]) \
                   + dt * S[i]
    return U_new
```

### 1.2 MacCormack格式（二阶精度）

**预测步（Predictor）：**
$$
\bar{U}_i^{n+1} = U_i^n - \frac{\Delta t}{\Delta x}(F_{i+1}^n - F_i^n) + \Delta t \cdot S_i^n
$$

**校正步（Corrector）：**
$$
U_i^{n+1} = \frac{1}{2}\left(U_i^n + \bar{U}_i^{n+1} - \frac{\Delta t}{\Delta x}(\bar{F}_i^{n+1} - \bar{F}_{i-1}^{n+1}) + \Delta t \cdot \bar{S}_i^{n+1}\right)
$$

**优点：** 二阶精度，易于实现
**缺点：** 仍需满足CFL条件

**Python伪代码：**
```python
def maccormack_scheme(U, dt, dx):
    """MacCormack格式"""
    # 预测步
    F = compute_flux(U)
    S = compute_source(U)
    U_bar = np.zeros_like(U)
    for i in range(len(U)-1):
        U_bar[i] = U[i] - dt/dx * (F[i+1] - F[i]) + dt * S[i]

    # 校正步
    F_bar = compute_flux(U_bar)
    S_bar = compute_source(U_bar)
    U_new = np.zeros_like(U)
    for i in range(1, len(U)):
        U_new[i] = 0.5 * (U[i] + U_bar[i]
                          - dt/dx * (F_bar[i] - F_bar[i-1])
                          + dt * S_bar[i])

    return U_new
```

### 1.3 Leap-Frog格式（二阶精度）

**离散格式：**
$$
U_i^{n+1} = U_i^{n-1} - \frac{2\Delta t}{\Delta x}(F_{i+1}^n - F_{i-1}^n) + 2\Delta t \cdot S_i^n
$$

**特点：** 需要两个时间层，中心差分

---

## 二、隐式有限差分法

### 2.1 向后差分格式（Backward Euler）

**离散格式：**
$$
\frac{U_i^{n+1} - U_i^n}{\Delta t} + \frac{F_{i+1}^{n+1} - F_{i-1}^{n+1}}{2\Delta x} = S_i^{n+1}
$$

**特点：**
- 无条件稳定
- 需要迭代求解非线性方程组

**线性化（Newton-Raphson）：**
$$
\mathbf{J} \Delta \mathbf{U} = -\mathbf{R}
$$

其中 $\mathbf{J}$ 是Jacobian矩阵，$\mathbf{R}$ 是残差

### 2.2 Preissmann四点隐格式

**权重参数：**
- 时间权重：$\theta \in [0.5, 1]$
- 空间权重：$\psi = 0.5$（中心差分）

**离散格式：**

时间离散：
$$
\phi^{n+\theta} = \theta \phi^{n+1} + (1-\theta)\phi^n
$$

空间离散：
$$
\phi_i^{n+\psi} = \psi \phi_{i+1}^n + (1-\psi)\phi_i^n
$$

**优点：**
- 无条件稳定（$\theta \geq 0.5$）
- 可以使用大时间步长
- 适合长时间模拟

**方程组求解：**
- 追赶法（Thomas Algorithm）：三对角矩阵
- 迭代法（Gauss-Seidel, SOR）：大型系统

**Python伪代码：**
```python
def preissmann_scheme(U, dt, dx, theta=0.6):
    """Preissmann隐格式"""
    n = len(U)

    # 构造线性方程组 A * U_new = b
    A = construct_jacobian(U, dt, dx, theta)
    b = compute_rhs(U, dt, dx, theta)

    # 求解（追赶法或迭代法）
    U_new = solve_tridiagonal(A, b)

    return U_new

def solve_tridiagonal(A, b):
    """追赶法求解三对角方程组"""
    # Thomas algorithm
    n = len(b)
    c_star = np.zeros(n-1)
    d_star = np.zeros(n)
    x = np.zeros(n)

    # 前向消元
    c_star[0] = A[0,1] / A[0,0]
    d_star[0] = b[0] / A[0,0]
    for i in range(1, n-1):
        denom = A[i,i] - A[i,i-1] * c_star[i-1]
        c_star[i] = A[i,i+1] / denom
        d_star[i] = (b[i] - A[i,i-1] * d_star[i-1]) / denom

    d_star[n-1] = (b[n-1] - A[n-1,n-2] * d_star[n-2]) / \
                  (A[n-1,n-1] - A[n-1,n-2] * c_star[n-2])

    # 回代
    x[n-1] = d_star[n-1]
    for i in range(n-2, -1, -1):
        x[i] = d_star[i] - c_star[i] * x[i+1]

    return x
```

---

## 三、特征线法（MOC）

### 3.1 特征理论

**特征方程：**

$$
C^+: \frac{dx}{dt} = v + c \quad \text{(正特征线)}
$$
$$
C^-: \frac{dx}{dt} = v - c \quad \text{(负特征线)}
$$

**相容方程（沿特征线）：**

$$
C^+: dv + \frac{g}{c}dh + \frac{gJ}{c}dx = 0
$$
$$
C^-: dv - \frac{g}{c}dh + \frac{gJ}{c}dx = 0
$$

### 3.2 数值实现

**特征网格：**

```
时间 t^{n+1}  ●─────────P─────────●
               ╱           ╲
              ╱             ╲
             ╱               ╲
时间 t^n    ●─────────L─────●─────R───●
           x_{i-1}   x_i   x_{i+1}
```

**计算步骤：**

1. 从点L和R出发，绘制特征线
2. 特征线交于点P
3. 沿特征线积分相容方程
4. 求解P点的流速和水深

**积分形式：**

沿 $C^+$ 从 L 到 P：
$$
v_P + \frac{g}{c}h_P = v_L + \frac{g}{c}h_L - \int_L^P \frac{gJ}{c}dx
$$

沿 $C^-$ 从 R 到 P：
$$
v_P - \frac{g}{c}h_P = v_R - \frac{g}{c}h_R - \int_R^P \frac{gJ}{c}dx
$$

**求解：**
$$
v_P = \frac{1}{2}(C^+ + C^-)
$$
$$
h_P = \frac{c}{2g}(C^+ - C^-)
$$

**插值：**
- L和R点不在网格点上，需要插值
- 线性插值：$\phi_L = \phi_i + \alpha(\phi_{i-1} - \phi_i)$
- 二次插值：更高精度

**Python伪代码：**
```python
def method_of_characteristics(h, v, dx, dt):
    """特征线法"""
    n = len(h)
    h_new = np.zeros(n)
    v_new = np.zeros(n)

    for i in range(1, n-1):
        # 计算波速
        c = np.sqrt(9.81 * h[i])

        # 找到特征线的起点（插值）
        x_L = i * dx - (v[i] + c) * dt
        x_R = i * dx - (v[i] - c) * dt

        # 插值得到L和R点的值
        h_L, v_L = interpolate(h, v, x_L, dx)
        h_R, v_R = interpolate(h, v, x_R, dx)

        # 计算摩阻项积分
        J_L = friction_slope(h_L, v_L)
        J_R = friction_slope(h_R, v_R)

        # 相容方程
        C_plus = v_L + (9.81/c) * h_L - 9.81 * J_L * dt
        C_minus = v_R - (9.81/c) * h_R - 9.81 * J_R * dt

        # 求解P点
        v_new[i] = 0.5 * (C_plus + C_minus)
        h_new[i] = (c / (2*9.81)) * (C_plus - C_minus)

    return h_new, v_new
```

---

## 四、有限体积法（FVM）

### 4.1 守恒律积分形式

$$
\frac{d}{dt}\int_{x_i}^{x_{i+1}} \mathbf{U} dx + \mathbf{F}_{i+1/2} - \mathbf{F}_{i-1/2} = \int_{x_i}^{x_{i+1}} \mathbf{S} dx
$$

**半离散形式：**
$$
\frac{d\bar{\mathbf{U}}_i}{dt} + \frac{1}{\Delta x}(\mathbf{F}_{i+1/2} - \mathbf{F}_{i-1/2}) = \bar{\mathbf{S}}_i
$$

其中 $\bar{\mathbf{U}}_i = \frac{1}{\Delta x}\int_{x_i}^{x_{i+1}} \mathbf{U} dx$ 是单元平均值

### 4.2 Riemann问题

**定义：** 初始条件为分段常数的间断问题

$$
\mathbf{U}(x, 0) = \begin{cases}
\mathbf{U}_L & x < 0 \\
\mathbf{U}_R & x > 0
\end{cases}
$$

**解的结构：**
- 左行波（负特征）
- 接触间断
- 右行波（正特征）

### 4.3 HLL求解器（Harten-Lax-van Leer）

**数值通量：**

$$
\mathbf{F}_{HLL} = \begin{cases}
\mathbf{F}_L & 0 \leq S_L \\
\frac{S_R \mathbf{F}_L - S_L \mathbf{F}_R + S_L S_R (\mathbf{U}_R - \mathbf{U}_L)}{S_R - S_L} & S_L < 0 < S_R \\
\mathbf{F}_R & S_R \leq 0
\end{cases}
$$

**波速估计：**
$$
S_L = \min(v_L - c_L, v_R - c_R)
$$
$$
S_R = \max(v_L + c_L, v_R + c_R)
$$

**Python代码：**
```python
def hll_flux(U_L, U_R):
    """HLL Riemann求解器"""
    # 提取左右状态
    A_L, Q_L = U_L
    A_R, Q_R = U_R

    h_L = A_L / B  # 假设矩形断面
    h_R = A_R / B
    v_L = Q_L / A_L
    v_R = Q_R / A_R

    # 波速
    c_L = np.sqrt(9.81 * h_L)
    c_R = np.sqrt(9.81 * h_R)
    S_L = min(v_L - c_L, v_R - c_R)
    S_R = max(v_L + c_L, v_R + c_R)

    # 计算通量
    F_L = compute_flux(U_L)
    F_R = compute_flux(U_R)

    if 0 <= S_L:
        return F_L
    elif S_R <= 0:
        return F_R
    else:
        return (S_R * F_L - S_L * F_R + S_L * S_R * (U_R - U_L)) / (S_R - S_L)
```

### 4.4 MUSCL重构（高阶精度）

**思想：** 在单元内重构高阶多项式

**线性重构：**
$$
\mathbf{U}(x) = \bar{\mathbf{U}}_i + \sigma_i (x - x_i)
$$

**斜率计算：**
$$
\sigma_i = \frac{\bar{\mathbf{U}}_{i+1} - \bar{\mathbf{U}}_{i-1}}{2\Delta x}
$$

**边界值：**
$$
\mathbf{U}_{i}^- = \bar{\mathbf{U}}_i - \frac{\Delta x}{2}\sigma_i
$$
$$
\mathbf{U}_{i}^+ = \bar{\mathbf{U}}_i + \frac{\Delta x}{2}\sigma_i
$$

**限制器（避免振荡）：**

MinMod限制器：
$$
\sigma_i = \text{minmod}\left(\frac{\bar{\mathbf{U}}_{i+1} - \bar{\mathbf{U}}_i}{\Delta x}, \frac{\bar{\mathbf{U}}_i - \bar{\mathbf{U}}_{i-1}}{\Delta x}\right)
$$

其中：
$$
\text{minmod}(a, b) = \begin{cases}
\text{sign}(a) \cdot \min(|a|, |b|) & ab > 0 \\
0 & ab \leq 0
\end{cases}
$$

**Python代码：**
```python
def minmod(a, b):
    """MinMod限制器"""
    if a * b > 0:
        return np.sign(a) * min(abs(a), abs(b))
    else:
        return 0.0

def muscl_reconstruction(U):
    """MUSCL重构"""
    n = len(U)
    U_L = np.zeros(n)  # 左边界值
    U_R = np.zeros(n)  # 右边界值

    for i in range(1, n-1):
        # 计算斜率
        slope = minmod((U[i+1] - U[i]) / dx, (U[i] - U[i-1]) / dx)

        # 重构
        U_L[i] = U[i] - 0.5 * dx * slope
        U_R[i] = U[i] + 0.5 * dx * slope

    return U_L, U_R

def fvm_with_muscl(U, dt, dx):
    """FVM + MUSCL高阶格式"""
    # MUSCL重构
    U_L, U_R = muscl_reconstruction(U)

    # 计算数值通量
    F = np.zeros(len(U)+1)
    for i in range(len(U)+1):
        F[i] = hll_flux(U_R[i-1], U_L[i])

    # 更新
    U_new = U - dt/dx * (F[1:] - F[:-1])

    return U_new
```

---

## 五、算法对比

### 5.1 精度对比

| 方法 | 时间精度 | 空间精度 | 总精度 |
|------|----------|----------|--------|
| Lax | 1阶 | 1阶 | 1阶 |
| Leap-Frog | 2阶 | 2阶 | 2阶 |
| MacCormack | 2阶 | 2阶 | 2阶 |
| Preissmann | 1-2阶 | 2阶 | 1-2阶 |
| MOC | 取决于插值 | 取决于插值 | 高 |
| FVM（一阶） | 1阶 | 1阶 | 1阶 |
| FVM+MUSCL | 2阶 | 2阶 | 2阶 |

### 5.2 稳定性对比

| 方法 | 稳定性条件 | 备注 |
|------|------------|------|
| 显式差分 | CFL < 1 | 条件稳定 |
| 隐式差分 | 无条件稳定 | θ ≥ 0.5 |
| MOC | CFL ≈ 1 | 沿特征线 |
| FVM | CFL < 1 | 条件稳定 |

### 5.3 计算效率

**时间步长：**
- 显式：Δt ≈ 0.1s（CFL限制）
- 隐式：Δt ≈ 10-100s（稳定性好）

**计算时间（单步）：**
- 显式：快（无方程组求解）
- 隐式：慢（需解方程组）
- MOC：中等（插值耗时）
- FVM：慢（Riemann求解器）

**总计算时间：**
取决于模拟时长和所需时间步数

---

## 六、实际应用建议

### 6.1 方法选择

**常规问题（洪水演进、闸门操作）：**
- 推荐：Preissmann隐格式
- 理由：稳定、可用大时间步、精度够用

**激波问题（溃坝波）：**
- 推荐：FVM + HLL/HLLC
- 理由：守恒、激波捕捉

**高精度要求：**
- 推荐：FVM + MUSCL + TVD
- 理由：高阶精度、单调性

**快速原型：**
- 推荐：MacCormack显格式
- 理由：编程简单、精度尚可

### 6.2 参数设置

**空间步长Δx：**
- 一般：Δx = 10-100 m
- 建筑物附近：Δx = 1-10 m

**时间步长Δt：**
- 显式：满足CFL条件
- 隐式：Δt = 10-600 s（根据需要）

**CFL数：**
- 显式：CFL = 0.5-0.9
- 隐式：可以 > 1

### 6.3 收敛性检验

**网格无关性：**
1. 使用Δx运行
2. 使用Δx/2运行
3. 比较结果，若差异<1%，则网格足够细

**时间步长检验：**
类似网格检验

---

## 📚 推荐阅读

### 书籍
1. **Toro, E.F.** - "Riemann Solvers and Numerical Methods for Fluid Dynamics"
2. **LeVeque, R.J.** - "Finite Volume Methods for Hyperbolic Problems"
3. **Chaudhry, M.H.** - "Open-Channel Flow"

### 论文
1. Preissmann, A. (1961) - 隐格式的原始论文
2. Harten, A. et al. (1983) - HLL求解器
3. van Leer, B. (1979) - MUSCL格式

### 开源代码
1. **HEC-RAS** - 美国陆军工程兵团
2. **SWMM** - EPA雨洪模型
3. **Basilisk** - 开源CFD求解器

---

**文档版本：** v1.0
**最后更新：** 2025-10-29
**作者：** CHS-Books 教材开发组
