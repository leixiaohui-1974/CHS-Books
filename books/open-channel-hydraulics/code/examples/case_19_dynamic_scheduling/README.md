# 案例19：多闸门渠系动态调度优化

## 案例背景

某现代化灌区建有智能渠系，包含1条主渠道和5个串联节制闸。各闸门下游有不同的支渠取水，用水需求随时间变化。需要实时优化调整各闸门开度，满足下游用水需求的同时，最小化水位波动和操作能耗。

工程参数：
- 渠道总长度 L = 10000 m（分为5段，每段2000m）
- 渠道宽度 b = 8.0 m
- 河床坡度 S₀ = 0.0003
- 糙率系数 n = 0.022
- 闸门数量 = 5个（位于x=2000, 4000, 6000, 8000, 10000 m）
- 调度周期 = 6小时

用水场景：
- 支渠1-3：白天高峰用水（8:00-18:00）
- 支渠4-5：夜间灌溉（20:00-次日6:00）
- 总流量范围：15-50 m³/s

计算要求：
1. 建立多闸门-渠道耦合动力学模型
2. 制定优化目标函数和约束条件
3. 实现遗传算法和粒子群算法求解
4. 对比不同调度策略的性能
5. 分析算法收敛性和鲁棒性

## 学习目标

1. 理解多闸门渠系的动力学特性
2. 掌握优化问题的建模方法
3. 学会遗传算法和粒子群算法的原理
4. 了解实时调度和滚动优化
5. 为《明渠控制》课程打下基础

## 核心理论

### 1. 多闸门渠系动力学

**系统描述：**
```json
上游
 ↓
[渠段1] → 闸门1 → [渠段2] → 闸门2 → [渠段3] → 闸门3 → [渠段4] → 闸门4 → [渠段5] → 闸门5
           ↓取水1      ↓取水2      ↓取水3      ↓取水4      ↓取水5
```

**状态变量：**
```python
各断面水深：h(x,t)
各断面流量：Q(x,t)
各闸门开度：a₁(t), a₂(t), ..., a₅(t)
```

**控制变量：**
```python
闸门开度序列：u(t) = [a₁(t), a₂(t), a₃(t), a₄(t), a₅(t)]ᵀ
```

**状态方程：**
```python
每个渠段满足圣维南方程：
∂A/∂t + ∂Q/∂x = -q_lateral
∂Q/∂t + ∂(Q²/A)/∂x + gA·∂h/∂x = gA(S₀ - Sf)

其中：
  q_lateral = 侧向取水流量（在取水口处）
```

**闸门流量方程：**
```python
自由出流：
Q = Cd · b · a · √(2g·h₁)

淹没出流：
Q = Cd · b · a · √(2g·(h₁ - h₂))

其中：
  Cd = 流量系数（约0.6-0.7）
  a = 闸门开度（m）
  h₁, h₂ = 上下游水深（m）
```

**耦合边界条件：**
```python
在第i个闸门位置（x = x_gate,i）：

上游侧（渠段i末端）：
  流量连续：Q_upstream = Q_gate

下游侧（渠段i+1起点）：
  流量连续：Q_gate - q_offtake,i = Q_downstream

其中：
  q_offtake,i = 第i个支渠取水量
```

### 2. 优化问题建模

**2.1 优化目标**

**目标1 - 最小化水位偏差（跟踪性能）：**
```python
J₁ = ∫₀ᵀ ∑ᵢ₌₁⁵ w_h,i · (h_i(t) - h_target,i(t))² dt

其中：
  h_i(t) = 第i个控制点的实际水深
  h_target,i(t) = 目标水深
  w_h,i = 权重系数
```

**目标2 - 最小化流量偏差（供水精度）：**
```python
J₂ = ∫₀ᵀ ∑ᵢ₌₁⁵ w_Q,i · (Q_offtake,i(t) - Q_demand,i(t))² dt

其中：
  Q_offtake,i(t) = 实际取水流量
  Q_demand,i(t) = 用水需求
```

**目标3 - 最小化操作频率（减少磨损）：**
```python
J₃ = ∫₀ᵀ ∑ᵢ₌₁⁵ w_a,i · (da_i/dt)² dt

惩罚频繁调节
```

**目标4 - 最小化能耗（节能）：**
```python
J₄ = ∫₀ᵀ ∑ᵢ₌₁⁵ E_i(t) dt

其中：
  E_i(t) = 闸门i的瞬时能耗
  E_i ∝ |da_i/dt| · (h₁ - h₂) · Q
```

**多目标加权：**
```python
J_total = α₁·J₁ + α₂·J₂ + α₃·J₃ + α₄·J₄

其中：
  α₁, α₂, α₃, α₄ = 权重系数
  通常满足：α₁ + α₂ + α₃ + α₄ = 1
```

**2.2 约束条件**

**闸门约束：**
```python
1. 开度范围：
   a_min ≤ a_i(t) ≤ a_max
   通常：0.2 m ≤ a_i ≤ 3.0 m

2. 调节速率限制：
   |da_i/dt| ≤ v_max
   通常：v_max = 0.05 m/s（机械限制）

3. 最小调节间隔：
   Δt_adjust ≥ Δt_min
   通常：Δt_min = 5 min（避免频繁操作）
```

**水力约束：**
```python
1. 水位范围：
   h_min ≤ h(x,t) ≤ h_max

   h_min：保证供水（不低于渠底+0.5m）
   h_max：防止漫堤（不超过设计水深）

2. 流速限制：
   v(x,t) ≤ v_max

   防止冲刷：v_max ≈ 2.0 m/s（土渠）
              v_max ≈ 3.5 m/s（混凝土渠）

3. 弗劳德数限制：
   Fr = v/√(gh) < 0.9

   保持缓流状态，避免跃变
```

**供水约束：**
```python
1. 流量满足：
   Q_offtake,i(t) ≥ Q_demand,i(t)  （不能欠供）

2. 水量平衡：
   ∑ᵢ Q_offtake,i ≤ Q_upstream（总量守恒）

3. 优先级：
   高优先级用户优先满足
```

**2.3 优化问题的数学表述**

```python
标准形式：

min J(u) = ∫₀ᵀ L(x(t), u(t), t) dt
u(t)

subject to:
  ẋ = f(x, u, t)        (状态方程，圣维南方程)
  g(x, u, t) ≤ 0        (不等式约束)
  h(x, u, t) = 0        (等式约束)
  x(0) = x₀             (初始条件)

其中：
  u(t) = [a₁(t), ..., a₅(t)]ᵀ  (控制变量)
  x(t) = [h(x,t), Q(x,t)]      (状态变量)
  L(·) = 阶段成本函数
```

**离散化：**
```python
对于数值求解，将时间离散化：

T = N·Δt  （N个时间步）

u = [u₀, u₁, u₂, ..., u_N]

优化变量维度 = 5闸门 × N时间步 = 5N
```

### 3. 遗传算法（Genetic Algorithm, GA）

**3.1 基本原理**

遗传算法模拟生物进化过程，通过选择、交叉、变异操作寻找最优解。

**3.2 编码方式**

**实数编码（适合闸门开度）：**
```python
染色体（个体）：
chromosome = [a₁(t₀), a₂(t₀), ..., a₅(t₀),
              a₁(t₁), a₂(t₁), ..., a₅(t₁),
              ...
              a₁(t_N), a₂(t_N), ..., a₅(t_N)]

长度 = 5 × N
```

**二进制编码：**
```python
将每个a_i编码为k位二进制数
例如：a = 1.5 m → 01011010（8位）

优点：通用
缺点：精度受限，解码计算量大
```

**3.3 遗传算子**

**适应度函数：**
```python
fitness(chromosome) = 1 / (1 + J(chromosome))

或：
fitness = exp(-J/σ)

目标：fitness越大越好（而J越小越好）
```

**选择（Selection）：**
```python
方法1 - 轮盘赌选择（Roulette Wheel）：
  P_i = fitness_i / ∑_j fitness_j

方法2 - 锦标赛选择（Tournament）：
  随机选k个个体，选fitness最大的

方法3 - 精英保留（Elitism）：
  最优个体直接进入下一代
```

**交叉（Crossover）：**
```python
单点交叉：
parent1: [a₁, a₂, a₃ | a₄, a₅]
parent2: [b₁, b₂, b₃ | b₄, b₅]
                ↓
child1:  [a₁, a₂, a₃ | b₄, b₅]
child2:  [b₁, b₂, b₃ | a₄, a₅]

多点交叉：
多个交叉点

均匀交叉：
每个基因随机选择父母

算术交叉（实数编码）：
child = α·parent1 + (1-α)·parent2
其中：0 ≤ α ≤ 1
```

**变异（Mutation）：**
```python
均匀变异：
a_new = a + δ·(a_max - a_min)
其中：δ ∈ [-0.1, 0.1] 随机数

高斯变异：
a_new = a + σ·N(0,1)
其中：N(0,1) 为标准正态分布

自适应变异：
变异幅度随代数衰减
σ(gen) = σ₀ · exp(-k·gen)
```

**3.4 GA流程**

```python
1. 初始化种群：
   随机生成M个个体（染色体）
   M = 种群大小，通常50-200

2. For gen = 1 to max_generations:

   a. 评估适应度：
      For each individual:
        运行渠道动力学仿真
        计算目标函数J
        计算fitness

   b. 选择：
      根据fitness选择父代

   c. 交叉：
      以概率P_c进行交叉（通常0.6-0.9）

   d. 变异：
      以概率P_m进行变异（通常0.01-0.1）

   e. 精英保留：
      保留最优个体

   f. 更新种群

   g. 记录最优解

3. 输出最优解
```

**3.5 GA参数**

```python
种群大小 M：50-200（太小易早熟，太大计算量大）
交叉概率 P_c：0.6-0.9
变异概率 P_m：0.01-0.1
最大代数 max_gen：100-500
精英个数 n_elite：1-5
```

### 4. 粒子群优化（Particle Swarm Optimization, PSO）

**4.1 基本原理**

PSO模拟鸟群觅食行为，每个粒子根据自身经验和群体经验调整搜索方向。

**4.2 粒子表示**

```python
粒子i：
  位置：x_i = [a₁, a₂, ..., a₅N]ᵀ  (闸门开度序列)
  速度：v_i = [v₁, v₂, ..., v₅N]ᵀ

  个体最优位置：p_i
  全局最优位置：g
```

**4.3 更新方程**

**速度更新：**
```python
v_i(t+1) = w·v_i(t) + c₁·r₁·(p_i - x_i(t)) + c₂·r₂·(g - x_i(t))

其中：
  w = 惯性权重（0.4-0.9）
  c₁ = 个体学习因子（通常2.0）
  c₂ = 社会学习因子（通常2.0）
  r₁, r₂ = [0,1]均匀分布随机数

第一项：惯性（保持原来的速度）
第二项：认知（向个体最优位置靠近）
第三项：社会（向全局最优位置靠近）
```

**位置更新：**
```python
x_i(t+1) = x_i(t) + v_i(t+1)

边界处理：
if x_i < x_min:
  x_i = x_min, v_i = 0
if x_i > x_max:
  x_i = x_max, v_i = 0
```

**4.4 PSO流程**

```python
1. 初始化：
   For i = 1 to N_particles:
     随机初始化位置 x_i 和速度 v_i
     p_i = x_i

   计算所有粒子的适应度
   g = 最优粒子位置

2. For iter = 1 to max_iterations:

   For each particle i:
     a. 评估适应度 f(x_i)

     b. 更新个体最优：
        if f(x_i) < f(p_i):
          p_i = x_i

     c. 更新全局最优：
        if f(x_i) < f(g):
          g = x_i

     d. 更新速度和位置：
        v_i = w·v_i + c₁·r₁·(p_i - x_i) + c₂·r₂·(g - x_i)
        x_i = x_i + v_i

     e. 边界处理

3. 输出全局最优解 g
```

**4.5 惯性权重策略**

**线性递减：**
```python
w(iter) = w_max - (w_max - w_min) · iter / max_iter

通常：w_max = 0.9, w_min = 0.4
```

**自适应调整：**
```python
根据粒子分布动态调整w
群体聚集时增大w（增强探索）
群体分散时减小w（增强开发）
```

**4.6 PSO参数**

```python
粒子数量 N：20-50
惯性权重 w：0.4-0.9（线性递减）
学习因子 c₁, c₂：通常都是2.0
最大速度 v_max：(x_max - x_min) / 10
最大迭代数：100-300
```

### 5. 约束处理方法

**5.1 罚函数法**

```python
修改目标函数：
J_penalty(u) = J(u) + ∑ᵢ r_i · max(0, g_i(u))²

其中：
  g_i(u) = 约束违反量
  r_i = 罚因子（很大，如10⁶）

优点：简单
缺点：罚因子难以选择
```

**5.2 修复法**

```python
当个体违反约束时，强制修复：

if a_i < a_min:
  a_i = a_min
if a_i > a_max:
  a_i = a_max

if |da/dt| > v_max:
  限制变化速率

优点：保证可行性
缺点：可能破坏算法性能
```

**5.3 可行性保持法**

```python
变异/交叉时检查约束：
只接受可行解

优点：解始终可行
缺点：可能难以跨越不可行域
```

### 6. 滚动优化策略

**6.1 模型预测控制（MPC）框架**

```python
在每个时刻 t：

1. 测量当前状态 x(t)

2. 求解有限时域优化问题：
   min J(u[t:t+T_horizon])

   预测时域：T_horizon（如1小时）

3. 只执行第一步控制 u(t)

4. 在下一时刻 t+Δt 重复

优点：
- 可处理约束
- 考虑未来影响
- 抗干扰能力强
```

**6.2 预测时域选择**

```python
T_horizon 的选择：

太短：优化效果差（短视）
太长：计算量大，预测不准

经验：
T_horizon = 2-3 × 系统主导时间常数

对于渠道：
T_horizon ≈ 2 × L/(v+c)
```

### 7. 性能评价指标

**7.1 跟踪误差（Tracking Error）**

```python
RMSE_h = √(1/T ∫₀ᵀ (h(t) - h_target(t))² dt)

MAE_h = 1/T ∫₀ᵀ |h(t) - h_target(t)| dt
```

**7.2 供水精度**

```python
供水误差：
ε_Q = (Q_actual - Q_demand) / Q_demand

满足率：
R = (满足需求的时间) / 总时间
```

**7.3 操作成本**

```python
操作次数：N_op = ∑ (闸门调节次数)

总调节量：V_total = ∑ᵢ ∫ |da_i/dt| dt
```

**7.4 算法性能**

```python
收敛速度：
达到95%最优解的迭代次数

计算时间：
单次优化的CPU时间

鲁棒性：
不同初始值的成功率
```

### 8. 实际工程考虑

**8.1 实时性要求**

```python
调度周期：Δt_schedule（如5分钟）

要求：
  优化计算时间 < Δt_schedule

策略：
- 减少种群/粒子数
- 限制最大迭代数
- 简化动力学模型
- 并行计算
```

**8.2 测量与通信**

```matlab
测量误差：
- 水位计精度：±1 cm
- 流量计精度：±2%
- 闸门位置传感器：±0.5 cm

通信延迟：
- 数据采集：1-2秒
- 控制指令下发：1-2秒
- 总延迟：3-5秒

需考虑延迟补偿
```

**8.3 安全机制**

```python
1. 水位报警：
   if h > h_alarm:
     紧急开闸泄水
   if h < h_min:
     报警并减少取水

2. 流速监控：
   if v > v_max:
     减小闸门开度

3. 异常检测：
   传感器故障检测
   执行器故障检测

4. 人工干预：
   允许人工覆盖优化指令
```

### 9. 与传统方法对比

**9.1 传统方法**

**方法1 - 经验调度：**
```python
根据历史经验设定固定规则
优点：简单可靠
缺点：不能适应变化，次优
```

**方法2 - PID控制：**
```python
每个闸门独立PID控制
优点：成熟稳定
缺点：各闸门独立，缺乏协调
```

**方法3 - LQR控制：**
```python
线性二次型调节器
优点：理论完善
缺点：需要线性化，约束处理困难
```

**9.2 优化调度的优势**

```python
✓ 多目标权衡：同时考虑多个指标
✓ 全局优化：所有闸门协同
✓ 约束满足：严格满足约束
✓ 预测功能：考虑未来影响
✓ 适应性强：可处理各种场景
```

### 10. 进阶主题

**10.1 不确定性处理**

```python
随机优化：
- 需求预测不准
- 降雨不确定
- 模型误差

鲁棒优化：
min max J(u, ξ)
 u   ξ∈Ξ

其中：ξ = 不确定参数
```

**10.2 多目标优化**

```python
Pareto前沿：
无法同时改善所有目标

方法：
- 加权和法（本案例采用）
- ε约束法
- NSGA-II（非支配排序遗传算法）
```

**10.3 分布式优化**

```python
将大渠系分解为多个子系统
各子系统协调优化

优点：
- 计算并行化
- 可扩展性好
- 局部自治

方法：
- ADMM（交替方向乘子法）
- 分解协调法
```

## 计算任务

### 任务1：基准调度

不使用优化，采用简单经验规则，作为对比基准。

### 任务2：遗传算法优化

使用遗传算法求解多闸门调度问题。

### 任务3：粒子群算法优化

使用粒子群算法求解同样问题。

### 任务4：算法对比

对比GA、PSO和基准方法的性能。

### 任务5：鲁棒性测试

测试优化策略对需求扰动和初始条件的鲁棒性。

## 使用方法

```python
# 运行主程序（演示基准+优化）
python main.py

# 运行实验（详细对比）
python experiments.py
```

## 预期结果

**基准方法（经验调度）：**
- 水位RMSE：约0.3-0.5 m
- 操作次数：15-20次/6h
- 供水满足率：85-90%

**遗传算法优化：**
- 水位RMSE：约0.15-0.20 m（改善50%）
- 操作次数：10-12次/6h
- 供水满足率：95-98%
- 收敛代数：50-100代

**粒子群算法优化：**
- 水位RMSE：约0.12-0.18 m
- 操作次数：8-10次/6h
- 供水满足率：96-99%
- 收敛迭代数：30-60次
- 计算速度比GA快约30%

## 工程意义

本案例展示了：
1. 复杂渠系的优化调度理论
2. 智能算法在水利工程中的应用
3. 多目标优化与约束处理
4. 实时调度策略设计
5. 为智能灌溉系统提供核心技术

## 设计要点

1. **优化建模**：
   - 目标函数设计
   - 权重系数选择
   - 约束条件完整性
   - 离散化精度

2. **算法选择**：
   - GA适合全局搜索
   - PSO收敛快
   - 参数调优重要
   - 混合算法

3. **工程实施**：
   - 实时性保证
   - 安全机制
   - 人机交互
   - 故障处理

4. **性能评价**：
   - 多指标综合评价
   - 与基准对比
   - 长期运行测试
   - 经济效益分析

## 注意事项

1. **优化难度**：
   - 高维优化问题（5闸门×N时间步）
   - 非线性约束
   - 计算时间长
   - 局部最优陷阱

2. **动力学仿真**：
   - 每次适应度评估需要完整仿真
   - 仿真精度与速度权衡
   - 数值稳定性

3. **约束处理**：
   - 硬约束必须满足
   - 罚函数参数敏感
   - 修复策略影响收敛

4. **实际应用**：
   - 模型误差
   - 预测误差
   - 执行误差
   - 需要在线校正

## 进阶主题

1. **深度强化学习**：
   - DQN、A3C等方法
   - 策略网络
   - 价值网络
   - 离线训练在线应用

2. **模型预测控制**：
   - 滚动优化
   - 反馈校正
   - 不确定性处理
   - 自适应MPC

3. **混合整数优化**：
   - 考虑开关动作
   - MINLP求解
   - 分支定界法
   - 逻辑约束

4. **大规模渠系**：
   - 分布式优化
   - 分层控制
   - 区域协调
   - 云平台架构
