# Day 6：管网水力计算

**学习时间**: 6小时  
**考试频率**: ⭐⭐⭐⭐⭐  
**难度**: ⭐⭐⭐⭐⭐

---

## 一、管网基础概念

### 1.1 管网类型

**树状管网（开式）**：
- 无环路
- 水流方向单一
- 计算简单
- 可靠性差

**环状管网（闭式）**：
- 有环路
- 水流方向可变
- 计算复杂
- 可靠性高

### 1.2 基本假设

1. 水流恒定
2. 管道沿程损失用Darcy-Weisbach公式
3. 节点水量平衡
4. 环路能量守恒

---

## 二、串联管道

### 2.1 基本公式

**特点**：$Q_1 = Q_2 = Q_3 = \cdots$（流量相等）

**总水头损失**：
$$h_f = h_{f1} + h_{f2} + h_{f3} + \cdots$$

**管道阻力**：
$$S = \frac{h_f}{Q^2} = \frac{8\lambda L}{\pi^2 gd^5}$$

**串联管道总阻力**：
$$S_{总} = S_1 + S_2 + S_3 + \cdots$$

---

## 三、并联管道

### 3.1 基本公式

**特点**：
- $h_{f1} = h_{f2} = h_{f3} = \cdots$（水头损失相等）
- $Q = Q_1 + Q_2 + Q_3 + \cdots$（流量相加）

**流量分配**：
$$Q_i = \sqrt{\frac{h_f}{S_i}}$$

**等效管长**：
$$\frac{1}{\sqrt{S_{等}}} = \frac{1}{\sqrt{S_1}} + \frac{1}{\sqrt{S_2}} + \cdots$$

---

## 四、三管问题

### 4.1 三水池连通

**已知**：三水池水位$H_1, H_2, H_3$，管道参数$L_i, d_i, \lambda_i$

**求**：各管道流量$Q_1, Q_2, Q_3$及节点水头$H_J$

**方程组**：

**水量平衡**：
$$Q_1 + Q_2 + Q_3 = 0$$

**能量方程**：
$$H_1 - H_J = S_1 Q_1 |Q_1|$$
$$H_2 - H_J = S_2 Q_2 |Q_2|$$
$$H_3 - H_J = S_3 Q_3 |Q_3|$$

**求解步骤**：
1. 假设$H_J$
2. 计算各管$Q_i$（注意流向）
3. 检验$\sum Q_i = 0$
4. 调整$H_J$，迭代至收敛

---

## 五、Hardy-Cross法（环路平差法）

### 5.1 基本原理

**适用**：复杂环状管网

**两大方程**：
1. **节点方程**：$\sum Q = 0$（流量连续）
2. **环路方程**：$\sum h_f = 0$（能量守恒）

### 5.2 计算步骤

**(1) 假设流量分配**：
- 满足节点平衡：$\sum Q = 0$
- 假设各环路流量，确定管段流量

**(2) 计算环路不平衡量**：

$$\Delta h = \sum h_f = \sum S_i Q_i |Q_i|$$

**(3) 计算流量修正值**：

$$\Delta Q = -\frac{\sum S_i Q_i |Q_i|}{2\sum S_i Q_i^2}$$

简化（$h_f = S Q^2$）：

$$\Delta Q = -\frac{\sum h_f}{2\sum \frac{h_f}{Q}}$$

**(4) 修正流量**：
- 环路内管段：$Q' = Q + \Delta Q$
- 公共管段：考虑两个环路修正

**(5) 迭代**：直至$|\Delta Q| < \varepsilon$

### 5.3 符号约定

- 顺时针为正，逆时针为负
- 公共管：正负修正量代数相加

---

## 六、管网优化设计

### 6.1 经济管径

**年费用**：
$$C = C_1 + C_2$$

**投资费用年摊**：
$$C_1 = a K_0 d^m$$

**能量费用**：
$$C_2 = b \frac{Q^3}{d^5}$$

**最优管径**：
$$\frac{dC}{dd} = 0 \Rightarrow d_{opt} = \left(\frac{5bQ^3}{amK_0}\right)^{\frac{1}{m+5}}$$

---

## 七、Python实现

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import fsolve, minimize

class PipeNetwork:
    """管网水力计算"""
    
    def __init__(self, g=9.81):
        self.g = g
    
    def pipe_resistance(self, L, d, lambda_val):
        """
        管道阻力系数
        
        S = 8λL / (π²gd⁵)
        """
        S = 8 * lambda_val * L / (np.pi**2 * self.g * d**5)
        return S
    
    def head_loss(self, Q, S):
        """
        水头损失
        
        h_f = S·Q²（简化）
        或 h_f = S·Q·|Q|（考虑流向）
        """
        return S * Q * abs(Q)
    
    def series_pipes(self, pipes):
        """
        串联管道
        
        参数:
            pipes: [(L1, d1, λ1), (L2, d2, λ2), ...]
        
        返回:
            S_total: 总阻力
        """
        S_total = 0
        for L, d, lam in pipes:
            S = self.pipe_resistance(L, d, lam)
            S_total += S
        
        return S_total
    
    def parallel_pipes(self, pipes, h_f):
        """
        并联管道流量分配
        
        参数:
            pipes: [(L1, d1, λ1), (L2, d2, λ2), ...]
            h_f: 总水头损失
        
        返回:
            Q_list: 各管流量
            Q_total: 总流量
        """
        Q_list = []
        
        for L, d, lam in pipes:
            S = self.pipe_resistance(L, d, lam)
            Q = np.sqrt(h_f / S)
            Q_list.append(Q)
        
        Q_total = sum(Q_list)
        
        return Q_list, Q_total
    
    def three_reservoirs(self, H, pipes):
        """
        三水池问题
        
        参数:
            H: [H1, H2, H3] 水位
            pipes: [(L1, d1, λ1), (L2, d2, λ2), (L3, d3, λ3)]
        
        返回:
            H_J: 节点水头
            Q: [Q1, Q2, Q3] 流量
        """
        H1, H2, H3 = H
        
        # 计算阻力
        S = [self.pipe_resistance(L, d, lam) for L, d, lam in pipes]
        
        def equations(H_J):
            """节点方程：ΣQ = 0"""
            Q1 = np.sqrt(abs(H1 - H_J) / S[0]) * np.sign(H1 - H_J)
            Q2 = np.sqrt(abs(H2 - H_J) / S[1]) * np.sign(H2 - H_J)
            Q3 = np.sqrt(abs(H3 - H_J) / S[2]) * np.sign(H3 - H_J)
            
            return Q1 + Q2 + Q3
        
        # 初始猜测：水位平均值
        H_J_init = np.mean(H)
        
        H_J = fsolve(equations, H_J_init)[0]
        
        # 计算流量
        Q1 = np.sqrt(abs(H1 - H_J) / S[0]) * np.sign(H1 - H_J)
        Q2 = np.sqrt(abs(H2 - H_J) / S[1]) * np.sign(H2 - H_J)
        Q3 = np.sqrt(abs(H3 - H_J) / S[2]) * np.sign(H3 - H_J)
        
        return H_J, [Q1, Q2, Q3]
    
    def hardy_cross_single_loop(self, pipes, Q_init, tol=1e-6, max_iter=100):
        """
        Hardy-Cross法（单环）
        
        参数:
            pipes: [(L1, d1, λ1, direction), ...] direction: 1顺时针, -1逆时针
            Q_init: 初始流量分配
            tol: 容许误差
            max_iter: 最大迭代次数
        
        返回:
            Q_final: 最终流量
            iterations: 迭代次数
        """
        Q = np.array(Q_init, dtype=float)
        
        # 计算阻力
        S = np.array([self.pipe_resistance(L, d, lam) for L, d, lam, _ in pipes])
        directions = np.array([direction for _, _, _, direction in pipes])
        
        for iter_count in range(max_iter):
            # 考虑流向的流量
            Q_signed = Q * directions
            
            # 环路不平衡量
            h_f = S * Q_signed * np.abs(Q_signed)
            delta_h = np.sum(h_f)
            
            # 流量修正值
            delta_Q = -delta_h / (2 * np.sum(S * Q_signed**2))
            
            # 修正流量
            Q += delta_Q
            
            # 检验收敛
            if abs(delta_Q) < tol:
                return Q, iter_count + 1
        
        print(f"警告：达到最大迭代次数{max_iter}")
        return Q, max_iter
    
    def economic_diameter(self, Q, a, K0, m, b):
        """
        经济管径
        
        参数:
            Q: 流量 (m³/s)
            a: 折旧系数
            K0: 单位造价
            m: 管径指数
            b: 能量费用系数
        
        返回:
            d_opt: 最优管径 (m)
        """
        d_opt = (5 * b * Q**3 / (a * m * K0))**(1 / (m + 5))
        return d_opt
    
    def plot_pipe_network_analysis(self):
        """绘制管网分析图"""
        fig, axes = plt.subplots(2, 2, figsize=(16, 12))
        
        # 1. 串联vs并联对比
        ax1 = axes[0, 0]
        
        # 两根管道：L=1000m, d1=0.3m, d2=0.4m, λ=0.03
        L = 1000
        lam = 0.03
        d1, d2 = 0.3, 0.4
        
        S1 = self.pipe_resistance(L, d1, lam)
        S2 = self.pipe_resistance(L, d2, lam)
        
        Q_range = np.linspace(0.01, 0.5, 100)
        
        # 串联
        S_series = S1 + S2
        h_series = S_series * Q_range**2
        
        # 并联
        S_parallel = 1 / (1/np.sqrt(S1) + 1/np.sqrt(S2))**2
        h_parallel = S_parallel * Q_range**2
        
        # 单管
        h_single1 = S1 * Q_range**2
        h_single2 = S2 * Q_range**2
        
        ax1.plot(Q_range, h_single1, 'b--', linewidth=2, label=f'管1单独（d={d1}m）')
        ax1.plot(Q_range, h_single2, 'g--', linewidth=2, label=f'管2单独（d={d2}m）')
        ax1.plot(Q_range, h_series, 'r-', linewidth=2.5, label='串联')
        ax1.plot(Q_range, h_parallel, 'm-', linewidth=2.5, label='并联')
        
        ax1.set_xlabel('流量 Q (m³/s)', fontsize=11)
        ax1.set_ylabel('水头损失 h_f (m)', fontsize=11)
        ax1.set_title('串联vs并联管道特性对比', fontsize=13, fontweight='bold')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # 2. 三水池问题
        ax2 = axes[0, 1]
        
        H = [50, 45, 40]  # 水位
        pipes_3res = [(1000, 0.3, 0.03), (1200, 0.35, 0.03), (800, 0.25, 0.03)]
        
        H_J, Q_3res = self.three_reservoirs(H, pipes_3res)
        
        reservoirs = ['水池1', '水池2', '水池3']
        water_levels = H
        flows = Q_3res
        
        x_pos = np.arange(len(reservoirs))
        
        # 水位柱状图
        bars1 = ax2.bar(x_pos - 0.2, water_levels, 0.35, label='水位(m)', 
                       color='skyblue', edgecolor='black')
        
        # 流量柱状图（缩放以便显示）
        ax2_twin = ax2.twinx()
        bars2 = ax2_twin.bar(x_pos + 0.2, flows, 0.35, label='流量(m³/s)', 
                            color='coral', edgecolor='black')
        
        # 节点水头标注
        ax2.axhline(H_J, color='green', linestyle='--', linewidth=2, 
                   label=f'节点水头={H_J:.2f}m')
        
        ax2.set_xlabel('水池', fontsize=11)
        ax2.set_ylabel('水位 (m)', fontsize=11, color='skyblue')
        ax2_twin.set_ylabel('流量 (m³/s)', fontsize=11, color='coral')
        ax2.set_title(f'三水池连通问题\n节点水头H_J={H_J:.2f}m', 
                     fontsize=13, fontweight='bold')
        ax2.set_xticks(x_pos)
        ax2.set_xticklabels(reservoirs)
        ax2.legend(loc='upper left')
        ax2_twin.legend(loc='upper right')
        ax2.grid(True, alpha=0.3, axis='y')
        
        # 标注流量数值
        for i, (bar, flow) in enumerate(zip(bars2, flows)):
            direction = '流入' if flow > 0 else '流出'
            ax2_twin.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.005,
                         f'{abs(flow):.3f}\n{direction}', ha='center', fontsize=9)
        
        # 3. Hardy-Cross迭代收敛
        ax3 = axes[1, 0]
        
        # 简单环路：4根管道
        pipes_loop = [
            (1000, 0.3, 0.03, 1),
            (1200, 0.35, 0.03, 1),
            (800, 0.25, 0.03, -1),
            (1000, 0.3, 0.03, -1)
        ]
        
        Q_init_loop = [0.1, 0.1, 0.1, 0.1]
        
        # 记录迭代过程
        Q_history = [Q_init_loop.copy()]
        Q_current = np.array(Q_init_loop, dtype=float)
        S_loop = np.array([self.pipe_resistance(L, d, lam) for L, d, lam, _ in pipes_loop])
        directions_loop = np.array([direction for _, _, _, direction in pipes_loop])
        
        for _ in range(10):
            Q_signed = Q_current * directions_loop
            h_f = S_loop * Q_signed * np.abs(Q_signed)
            delta_h = np.sum(h_f)
            delta_Q = -delta_h / (2 * np.sum(S_loop * Q_signed**2))
            Q_current += delta_Q
            Q_history.append(Q_current.copy())
            
            if abs(delta_Q) < 1e-6:
                break
        
        iterations = range(len(Q_history))
        Q_history_array = np.array(Q_history)
        
        for i in range(len(pipes_loop)):
            ax3.plot(iterations, Q_history_array[:, i], 'o-', linewidth=2, 
                    markersize=6, label=f'管段{i+1}')
        
        ax3.set_xlabel('迭代次数', fontsize=11)
        ax3.set_ylabel('流量 Q (m³/s)', fontsize=11)
        ax3.set_title('Hardy-Cross法迭代收敛过程', fontsize=13, fontweight='bold')
        ax3.legend()
        ax3.grid(True, alpha=0.3)
        
        # 4. 经济管径
        ax4 = axes[1, 1]
        
        Q_econ_range = np.linspace(0.05, 0.5, 100)
        
        # 参数（示例）
        a = 0.1  # 折旧系数
        K0 = 10000  # 单位造价
        m = 2  # 管径指数
        b = 1000  # 能量费用系数
        
        d_opt_values = [self.economic_diameter(Q, a, K0, m, b) for Q in Q_econ_range]
        
        ax4.plot(Q_econ_range, np.array(d_opt_values)*1000, 'b-', linewidth=2.5)
        
        # 标注典型点
        Q_typical = [0.1, 0.2, 0.3, 0.4]
        for Q_t in Q_typical:
            d_t = self.economic_diameter(Q_t, a, K0, m, b)
            ax4.scatter([Q_t], [d_t*1000], s=100, color='red', zorder=5)
            ax4.text(Q_t, d_t*1000 + 10, f'Q={Q_t}\nd={d_t*1000:.0f}mm',
                    ha='center', fontsize=9, bbox=dict(boxstyle='round', 
                    facecolor='wheat', alpha=0.5))
        
        ax4.set_xlabel('流量 Q (m³/s)', fontsize=11)
        ax4.set_ylabel('最优管径 d (mm)', fontsize=11)
        ax4.set_title('经济管径计算', fontsize=13, fontweight='bold')
        ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('pipe_network_analysis.png', dpi=300)
        plt.show()

# 示例1：串联管道
print("="*60)
print("示例1：串联管道计算")
print("="*60)

pn = PipeNetwork()

pipes_series = [
    (1000, 0.3, 0.03),  # L, d, λ
    (1500, 0.35, 0.03),
    (800, 0.25, 0.03)
]

S_total = pn.series_pipes(pipes_series)

Q_test = 0.2  # m³/s
h_f_total = S_total * Q_test**2

print(f"串联管道参数:")
for i, (L, d, lam) in enumerate(pipes_series, 1):
    S = pn.pipe_resistance(L, d, lam)
    h_f = S * Q_test**2
    print(f"  管段{i}: L={L}m, d={d}m, λ={lam}")
    print(f"          S={S:.2e}, h_f={h_f:.2f}m")

print(f"\n总阻力 S_总 = {S_total:.2e}")
print(f"流量 Q = {Q_test} m³/s 时")
print(f"总水头损失 h_f = {h_f_total:.2f} m")

# 示例2：并联管道
print("\n" + "="*60)
print("示例2：并联管道流量分配")
print("="*60)

pipes_parallel = [
    (1000, 0.3, 0.03),
    (1000, 0.4, 0.03),
    (1000, 0.35, 0.03)
]

h_f_given = 10  # m

Q_list, Q_total = pn.parallel_pipes(pipes_parallel, h_f_given)

print(f"并联管道参数:")
for i, (L, d, lam) in enumerate(pipes_parallel, 1):
    print(f"  管{i}: L={L}m, d={d}m, λ={lam}")

print(f"\n水头损失 h_f = {h_f_given} m")
print(f"\n流量分配:")
for i, Q in enumerate(Q_list, 1):
    print(f"  管{i}: Q = {Q:.4f} m³/s ({Q/Q_total*100:.1f}%)")

print(f"\n总流量 Q = {Q_total:.4f} m³/s")

# 示例3：三水池问题
print("\n" + "="*60)
print("示例3：三水池连通问题")
print("="*60)

H = [50, 45, 40]
pipes_3 = [
    (1000, 0.3, 0.03),
    (1200, 0.35, 0.03),
    (800, 0.25, 0.03)
]

H_J, Q_3 = pn.three_reservoirs(H, pipes_3)

print(f"水池水位:")
for i, h in enumerate(H, 1):
    print(f"  水池{i}: H = {h} m")

print(f"\n节点水头 H_J = {H_J:.3f} m")

print(f"\n流量（正值为流入节点，负值为流出节点）:")
for i, Q in enumerate(Q_3, 1):
    direction = "流入" if Q > 0 else "流出"
    print(f"  管{i}: Q = {Q:+.4f} m³/s ({direction})")

print(f"\n验证：ΣQ = {sum(Q_3):.2e} ≈ 0 ✓")

# 示例4：Hardy-Cross法
print("\n" + "="*60)
print("示例4：Hardy-Cross环路平差法")
print("="*60)

pipes_hc = [
    (1000, 0.3, 0.03, 1),
    (1200, 0.35, 0.03, 1),
    (800, 0.25, 0.03, -1),
    (1000, 0.3, 0.03, -1)
]

Q_init = [0.15, 0.15, 0.15, 0.15]

print(f"环路管道（+顺时针，-逆时针）:")
for i, (L, d, lam, direction) in enumerate(pipes_hc, 1):
    sign = '+' if direction > 0 else '-'
    print(f"  管{i}: L={L}m, d={d}m, λ={lam}, 方向={sign}")

print(f"\n初始流量分配:")
for i, Q in enumerate(Q_init, 1):
    print(f"  管{i}: Q = {Q} m³/s")

Q_final, iterations = pn.hardy_cross_single_loop(pipes_hc, Q_init)

print(f"\nHardy-Cross迭代:")
print(f"  迭代次数: {iterations}")

print(f"\n最终流量:")
for i, Q in enumerate(Q_final, 1):
    print(f"  管{i}: Q = {Q:.6f} m³/s")

# 验证环路平衡
S_hc = np.array([pn.pipe_resistance(L, d, lam) for L, d, lam, _ in pipes_hc])
directions_hc = np.array([direction for _, _, _, direction in pipes_hc])
Q_signed = Q_final * directions_hc
h_f_sum = np.sum(S_hc * Q_signed * np.abs(Q_signed))

print(f"\n验证：Σh_f = {h_f_sum:.2e} ≈ 0 ✓")

# 绘制管网分析图
print("\n绘制管网分析图...")
pn.plot_pipe_network_analysis()
```

---

## 八、典型考题

### 【例题1】串联管道（12分）

**题目**：两管串联，$L_1=1000$m，$d_1=0.3$m，$\lambda_1=0.03$；$L_2=1500$m，$d_2=0.4$m，$\lambda_2=0.03$。通过流量$Q=0.15$m³/s，求总水头损失。

**【解答】**

$$S_1 = \frac{8 \times 0.03 \times 1000}{\pi^2 \times 9.81 \times 0.3^5} = 1026.8$$

$$S_2 = \frac{8 \times 0.03 \times 1500}{\pi^2 \times 9.81 \times 0.4^5} = 361.3$$

$$S_{总} = 1026.8 + 361.3 = 1388.1$$

$$h_f = S_{总} Q^2 = 1388.1 \times 0.15^2 = 31.2 \text{ m}$$

---

### 【例题2】三水池问题（15分）

**题目**：三水池水位$H_1=50$m，$H_2=45$m，$H_3=40$m。管道均为$L=1000$m，$d=0.3$m，$\lambda=0.03$。求节点水头和各管流量。

**【解答】**（数值求解，步骤略）

---

**本章重点**：
- 串联、并联管道计算
- 三水池问题
- Hardy-Cross法
- 经济管径

**下一章**：明渠均匀流
