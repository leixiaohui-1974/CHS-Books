# 项目5：水文统计分析系统

**项目时长**: 1周  
**难度**: ⭐⭐⭐⭐  
**技术栈**: NumPy, SciPy, Pandas, Matplotlib, Statsmodels

---

## 一、项目目标

开发完整的水文统计分析系统，包括：
1. 频率分析（Pearson III型）
2. 相关分析与回归
3. 趋势检验（Mann-Kendall）
4. 时间序列分析
5. 可视化与报告生成

---

## 二、核心类库实现

### 2.1 频率分析基类

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
from scipy.optimize import fsolve
import pandas as pd

class FrequencyAnalysis:
    """
    水文频率分析基类
    """
    
    def __init__(self, data):
        """
        参数:
            data: 水文序列（数组）
        """
        self.data = np.array(data)
        self.n = len(data)
        
        # 统计特征值
        self.mean = np.mean(data)
        self.std = np.std(data, ddof=1)
        self.cv = self.std / self.mean  # 变差系数
        self.cs = self._skewness()      # 偏态系数
    
    def _skewness(self):
        """
        计算偏态系数Cs
        
        Cs = n·Σ(xi - x̄)³ / [(n-1)(n-2)·σ³]
        """
        deviations = self.data - self.mean
        numerator = self.n * np.sum(deviations**3)
        denominator = (self.n - 1) * (self.n - 2) * (self.std**3)
        cs = numerator / denominator
        return cs
    
    def empirical_frequency(self, method='weibull'):
        """
        经验频率计算
        
        参数:
            method: 'weibull', 'hazen', 'cunnane'
        """
        # 排序（降序）
        sorted_data = np.sort(self.data)[::-1]
        m = np.arange(1, self.n + 1)  # 序号
        
        if method == 'weibull':
            P = m / (self.n + 1)
        elif method == 'hazen':
            P = (m - 0.5) / self.n
        elif method == 'cunnane':
            P = (m - 0.4) / (self.n + 0.2)
        else:
            raise ValueError(f"未知方法: {method}")
        
        return sorted_data, P
    
    def pearson3_fit(self, Cs_ratio=2.0):
        """
        Pearson III型分布拟合
        
        参数:
            Cs_ratio: Cs/Cv比值（默认2.0）
        
        返回:
            拟合参数字典
        """
        # 调整偏态系数
        Cs = Cs_ratio * self.cv
        
        params = {
            'mean': self.mean,
            'cv': self.cv,
            'cs': Cs,
            'std': self.std
        }
        
        return params
    
    def design_value(self, P, params):
        """
        设计值计算
        
        X_P = X̄(1 + Cv·Φ_P)
        
        参数:
            P: 频率
            params: 拟合参数
        """
        Cv = params['cv']
        Cs = params['cs']
        mean = params['mean']
        
        # 查Φ_P值（Pearson III型）
        # 使用三阶矩近似
        if Cs != 0:
            # 威尔逊-希尔菲蒂公式
            z = stats.norm.ppf(1 - P)  # 标准正态分位数
            
            # Pearson III型近似
            phi = z + (z**2 - 1) * Cs / 6 + \
                  (z**3 - 6*z) * (Cs**2) / 72 - \
                  (z**2 - 1) * (Cs**3) / 36
        else:
            # 退化为正态分布
            phi = stats.norm.ppf(1 - P)
        
        X_P = mean * (1 + Cv * phi)
        
        return X_P
    
    def plot_frequency_curve(self, params, confidence=0.95):
        """
        绘制频率曲线
        """
        # 经验频率
        sorted_data, P_emp = self.empirical_frequency()
        
        # 理论曲线
        P_theory = np.logspace(-3, -0.01, 100)  # 0.1% ~ 98%
        X_theory = [self.design_value(p, params) for p in P_theory]
        
        # 常用频率点
        P_common = np.array([0.01, 0.02, 0.05, 0.10, 0.20, 0.50])
        X_common = [self.design_value(p, params) for p in P_common]
        
        # 绘图
        fig, ax = plt.subplots(figsize=(12, 7))
        
        # 经验点
        ax.plot(P_emp * 100, sorted_data, 'bo', markersize=8,
                label='实测点', zorder=3)
        
        # 理论曲线
        ax.plot(P_theory * 100, X_theory, 'r-', linewidth=2,
                label='Pearson III型曲线')
        
        # 常用频率点
        ax.plot(P_common * 100, X_common, 'gs', markersize=10,
                label='设计频率点', zorder=4)
        
        # 标注设计值
        for p, x in zip(P_common, X_common):
            ax.annotate(f'P={p*100:.0f}%\n{x:.1f}',
                       xy=(p*100, x), xytext=(10, 10),
                       textcoords='offset points',
                       fontsize=9, color='green',
                       bbox=dict(boxstyle='round,pad=0.3',
                                facecolor='yellow', alpha=0.7))
        
        ax.set_xlabel('频率 P (%)', fontsize=12)
        ax.set_ylabel('水文变量值', fontsize=12)
        ax.set_title('水文频率分析曲线', fontsize=14)
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        # 对数坐标
        ax.set_xscale('log')
        ax.set_xlim([0.1, 99])
        
        plt.tight_layout()
        plt.savefig('frequency_curve.png', dpi=300, bbox_inches='tight')
        plt.show()


# 使用示例
print("="*60)
print("水文频率分析示例")
print("="*60)

# 年最大流量序列（m³/s）
annual_max_Q = np.array([
    3500, 4200, 3800, 5100, 4600, 3900, 4800, 5500,
    4100, 3700, 4400, 5200, 4700, 3600, 4300, 4900,
    5300, 4000, 4500, 5600, 3800, 4200, 4600, 5000,
    4400, 3900, 4100, 4700, 5100, 4300
])

# 创建分析对象
freq_analysis = FrequencyAnalysis(annual_max_Q)

print(f"样本数量: {freq_analysis.n}")
print(f"均值: {freq_analysis.mean:.1f} m³/s")
print(f"标准差: {freq_analysis.std:.1f} m³/s")
print(f"变差系数 Cv: {freq_analysis.cv:.3f}")
print(f"偏态系数 Cs: {freq_analysis.cs:.3f}")

# Pearson III拟合
params = freq_analysis.pearson3_fit(Cs_ratio=2.0)
print(f"\nPearson III型参数:")
print(f"  均值: {params['mean']:.1f}")
print(f"  Cv: {params['cv']:.3f}")
print(f"  Cs: {params['cs']:.3f}")

# 设计值
print(f"\n设计值:")
for P in [0.01, 0.02, 0.05, 0.10, 0.20]:
    Q_P = freq_analysis.design_value(P, params)
    T = 1 / P  # 重现期
    print(f"  P={P*100:.0f}% (T={T:.0f}年): {Q_P:.1f} m³/s")

# 绘图
freq_analysis.plot_frequency_curve(params)
```

### 2.2 相关分析类

```python
class CorrelationAnalysis:
    """
    相关分析与回归
    """
    
    @staticmethod
    def pearson_correlation(x, y):
        """
        Pearson相关系数
        
        r = Σ(xi - x̄)(yi - ȳ) / √[Σ(xi - x̄)²·Σ(yi - ȳ)²]
        """
        x = np.array(x)
        y = np.array(y)
        
        x_mean = np.mean(x)
        y_mean = np.mean(y)
        
        numerator = np.sum((x - x_mean) * (y - y_mean))
        denominator = np.sqrt(np.sum((x - x_mean)**2) * 
                             np.sum((y - y_mean)**2))
        
        r = numerator / denominator
        
        # 显著性检验（t检验）
        n = len(x)
        t = r * np.sqrt(n - 2) / np.sqrt(1 - r**2)
        p_value = 2 * (1 - stats.t.cdf(abs(t), n - 2))
        
        return r, p_value
    
    @staticmethod
    def linear_regression(x, y):
        """
        一元线性回归
        
        y = a + bx
        """
        x = np.array(x)
        y = np.array(y)
        n = len(x)
        
        # 最小二乘法
        x_mean = np.mean(x)
        y_mean = np.mean(y)
        
        b = np.sum((x - x_mean) * (y - y_mean)) / np.sum((x - x_mean)**2)
        a = y_mean - b * x_mean
        
        # 预测值
        y_pred = a + b * x
        
        # 残差
        residuals = y - y_pred
        
        # R²决定系数
        SS_tot = np.sum((y - y_mean)**2)
        SS_res = np.sum(residuals**2)
        R2 = 1 - (SS_res / SS_tot)
        
        # 标准误差
        se = np.sqrt(SS_res / (n - 2))
        
        return {
            'a': a,
            'b': b,
            'R2': R2,
            'se': se,
            'y_pred': y_pred,
            'residuals': residuals
        }


# 相关分析示例
print("\n" + "="*60)
print("相关分析示例")
print("="*60)

# 流域面积与年径流
area = np.array([100, 150, 200, 250, 300, 350, 400, 450, 500])
runoff = np.array([50, 68, 88, 102, 118, 135, 148, 165, 180])

r, p_value = CorrelationAnalysis.pearson_correlation(area, runoff)
print(f"Pearson相关系数: r = {r:.4f}")
print(f"显著性: p = {p_value:.4e}")

if p_value < 0.05:
    print("相关显著 (p < 0.05)")
else:
    print("相关不显著")

# 线性回归
result = CorrelationAnalysis.linear_regression(area, runoff)
print(f"\n线性回归:")
print(f"  y = {result['a']:.2f} + {result['b']:.4f}x")
print(f"  R² = {result['R2']:.4f}")
print(f"  标准误差 = {result['se']:.2f}")

# 绘图
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# 散点图与回归线
axes[0].scatter(area, runoff, s=80, alpha=0.6, label='实测点')
axes[0].plot(area, result['y_pred'], 'r-', linewidth=2,
            label=f'y={result["a"]:.1f}+{result["b"]:.3f}x')
axes[0].set_xlabel('流域面积 (km²)', fontsize=12)
axes[0].set_ylabel('年径流 (亿m³)', fontsize=12)
axes[0].set_title(f'线性回归 (R²={result["R2"]:.3f})', fontsize=14)
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# 残差图
axes[1].scatter(result['y_pred'], result['residuals'], s=80, alpha=0.6)
axes[1].axhline(0, color='r', linestyle='--', linewidth=2)
axes[1].set_xlabel('预测值', fontsize=12)
axes[1].set_ylabel('残差', fontsize=12)
axes[1].set_title('残差分析', fontsize=14)
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('correlation_analysis.png', dpi=300, bbox_inches='tight')
plt.show()
```

### 2.3 趋势检验类

```python
class TrendTest:
    """
    趋势检验（Mann-Kendall）
    """
    
    @staticmethod
    def mann_kendall_test(data, alpha=0.05):
        """
        Mann-Kendall趋势检验
        
        参数:
            data: 时间序列
            alpha: 显著性水平
        
        返回:
            统计量S, Z, p值, 趋势判断
        """
        n = len(data)
        
        # 计算S统计量
        S = 0
        for i in range(n - 1):
            for j in range(i + 1, n):
                S += np.sign(data[j] - data[i])
        
        # 方差
        var_S = n * (n - 1) * (2*n + 5) / 18
        
        # 修正（存在相同值）
        unique_vals, counts = np.unique(data, return_counts=True)
        ties = counts[counts > 1]
        if len(ties) > 0:
            var_S -= np.sum(ties * (ties - 1) * (2*ties + 5)) / 18
        
        # Z统计量
        if S > 0:
            Z = (S - 1) / np.sqrt(var_S)
        elif S < 0:
            Z = (S + 1) / np.sqrt(var_S)
        else:
            Z = 0
        
        # p值（双侧检验）
        p_value = 2 * (1 - stats.norm.cdf(abs(Z)))
        
        # 判断
        if p_value < alpha:
            if Z > 0:
                trend = "显著上升趋势"
            else:
                trend = "显著下降趋势"
        else:
            trend = "无显著趋势"
        
        return {
            'S': S,
            'Z': Z,
            'p_value': p_value,
            'trend': trend,
            'alpha': alpha
        }


# 趋势检验示例
print("\n" + "="*60)
print("Mann-Kendall趋势检验")
print("="*60)

# 年降雨序列（mm）
years = np.arange(1990, 2020)
rainfall_series = 800 + 5 * np.arange(30) + np.random.normal(0, 50, 30)

result = TrendTest.mann_kendall_test(rainfall_series)

print(f"S统计量: {result['S']}")
print(f"Z统计量: {result['Z']:.4f}")
print(f"p值: {result['p_value']:.4f}")
print(f"结论: {result['trend']} (α={result['alpha']})")

# 绘图
plt.figure(figsize=(10, 6))
plt.plot(years, rainfall_series, 'bo-', linewidth=2, markersize=6)

# 趋势线
z = np.polyfit(years, rainfall_series, 1)
p = np.poly1d(z)
plt.plot(years, p(years), 'r--', linewidth=2,
        label=f'趋势线: y={z[1]:.1f}+{z[0]:.2f}x')

plt.xlabel('年份', fontsize=12)
plt.ylabel('降雨量 (mm)', fontsize=12)
plt.title(f'降雨趋势分析\n{result["trend"]} (p={result["p_value"]:.4f})',
         fontsize=14)
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('trend_test.png', dpi=300, bbox_inches='tight')
plt.show()
```

---

## 三、综合应用案例

### 案例：流域水文统计报告生成

```python
class HydroStatReport:
    """
    水文统计报告生成器
    """
    
    def __init__(self, data, name="水文变量"):
        self.data = data
        self.name = name
        self.freq_analysis = FrequencyAnalysis(data)
    
    def generate_report(self):
        """
        生成完整统计报告
        """
        print("="*60)
        print(f"{self.name}统计分析报告")
        print("="*60)
        
        # 基本统计
        print("\n1. 基本统计特征")
        print(f"   样本数: {self.freq_analysis.n}")
        print(f"   均值: {self.freq_analysis.mean:.2f}")
        print(f"   标准差: {self.freq_analysis.std:.2f}")
        print(f"   Cv: {self.freq_analysis.cv:.3f}")
        print(f"   Cs: {self.freq_analysis.cs:.3f}")
        print(f"   最大值: {np.max(self.data):.2f}")
        print(f"   最小值: {np.min(self.data):.2f}")
        
        # 频率分析
        print("\n2. 设计值（Pearson III）")
        params = self.freq_analysis.pearson3_fit()
        for P in [0.01, 0.02, 0.05, 0.10, 0.20, 0.50]:
            X_P = self.freq_analysis.design_value(P, params)
            print(f"   P={P*100:4.0f}%: {X_P:8.2f}")
        
        # 趋势检验
        print("\n3. 趋势检验")
        mk_result = TrendTest.mann_kendall_test(self.data)
        print(f"   {mk_result['trend']}")
        print(f"   p值: {mk_result['p_value']:.4f}")


# 生成报告示例
report = HydroStatReport(annual_max_Q, name="年最大流量")
report.generate_report()
```

---

## 四、学习要点

1. **频率分析**：Pearson III型最常用
2. **相关分析**：线性回归与显著性检验
3. **趋势检验**：Mann-Kendall非参数检验
4. **Python技能**：SciPy统计、Matplotlib可视化

**项目成果**：完整的水文统计分析工具包

---

**下一项目**：项目6 - 水库优化调度系统
