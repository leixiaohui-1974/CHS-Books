# 项目4：水库调度优化系统

**项目难度**: ⭐⭐⭐⭐⭐  
**预计时间**: 14小时  
**知识点**: 优化算法、动态规划、线性规划、决策理论

---

## 一、项目目标

开发完整的水库调度优化系统：
1. 水库水量平衡计算
2. 兴利调节计算
3. 防洪调度优化
4. 发电调度优化
5. 多目标优化
6. 可视化决策支持

---

## 二、核心理论

### 2.1 水量平衡方程

$$V_{t+1} = V_t + (Q_{in} - Q_{out})\Delta t$$

其中：
- $V_t$：时段初蓄水量
- $Q_{in}$：入库流量
- $Q_{out}$：出库流量

### 2.2 水库特性曲线

**库容-水位关系**：$V = f(Z)$  
**面积-水位关系**：$A = f(Z)$  
**泄流能力曲线**：$Q = f(Z, 开度)$

---

## 三、完整实现

### 3.1 水库核心类

```python
"""
reservoir.py
水库调度核心模块
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize, linprog
from scipy.interpolate import interp1d

class Reservoir:
    """
    水库基类
    """
    
    def __init__(self, name, dead_level, normal_level, flood_level, 
                 capacity_curve):
        """
        参数:
            name: 水库名称
            dead_level: 死水位 (m)
            normal_level: 正常蓄水位 (m)
            flood_level: 防洪限制水位 (m)
            capacity_curve: 库容曲线 [(Z, V), ...]
        """
        self.name = name
        self.Z_dead = dead_level
        self.Z_normal = normal_level
        self.Z_flood = flood_level
        
        # 库容曲线插值
        Z_data, V_data = zip(*capacity_curve)
        self.capacity_func = interp1d(Z_data, V_data, 
                                     kind='cubic', 
                                     fill_value='extrapolate')
        self.water_level_func = interp1d(V_data, Z_data,
                                        kind='cubic',
                                        fill_value='extrapolate')
    
    def volume_to_level(self, V):
        """
        库容→水位
        """
        return float(self.water_level_func(V))
    
    def level_to_volume(self, Z):
        """
        水位→库容
        """
        return float(self.capacity_func(Z))
    
    def water_balance(self, V0, Q_in, Q_out, dt=1):
        """
        水量平衡
        
        参数:
            V0: 初始库容 (万m³)
            Q_in: 入库流量 (m³/s)
            Q_out: 出库流量 (m³/s)
            dt: 时段 (天)
        
        返回:
            末库容 (万m³)
        """
        # 单位转换：m³/s → 万m³/天
        delta_V = (Q_in - Q_out) * 86400 * dt / 1e4
        V1 = V0 + delta_V
        
        # 约束检查
        V_min = self.level_to_volume(self.Z_dead)
        V_max = self.level_to_volume(self.Z_flood)
        
        if V1 < V_min:
            print(f"警告: 库容低于死库容!")
            V1 = V_min
        elif V1 > V_max:
            print(f"警告: 超过防洪库容!")
            V1 = V_max
        
        return V1


class ConservationScheduling(Reservoir):
    """
    兴利调度（灌溉、供水）
    """
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
    
    def calculate_supply(self, V, demand, reliability=0.9):
        """
        供水能力计算
        
        参数:
            V: 当前库容 (万m³)
            demand: 需水量 (万m³)
            reliability: 保证率
        """
        # 可供水量（扣除死库容）
        V_available = V - self.level_to_volume(self.Z_dead)
        
        # 实际供水（考虑保证率）
        supply = min(demand, V_available * reliability)
        
        return supply
    
    def annual_regulation(self, inflow_series, demand_series):
        """
        年调节计算
        
        参数:
            inflow_series: 月入流序列 (m³/s)
            demand_series: 月需水序列 (万m³)
        
        返回:
            调度结果字典
        """
        n_months = len(inflow_series)
        
        # 初始化
        V = np.zeros(n_months + 1)
        Z = np.zeros(n_months + 1)
        Q_out = np.zeros(n_months)
        supply = np.zeros(n_months)
        shortage = np.zeros(n_months)
        
        # 起调水位（正常蓄水位）
        V[0] = self.level_to_volume(self.Z_normal)
        Z[0] = self.Z_normal
        
        # 逐月调节
        for i in range(n_months):
            # 计算可供水量
            supply[i] = self.calculate_supply(V[i], demand_series[i])
            shortage[i] = max(0, demand_series[i] - supply[i])
            
            # 出库流量（供水转换为m³/s）
            Q_out[i] = supply[i] * 1e4 / (30 * 86400)
            
            # 水量平衡
            V[i+1] = self.water_balance(V[i], inflow_series[i], 
                                       Q_out[i], dt=30)
            Z[i+1] = self.volume_to_level(V[i+1])
        
        # 统计
        total_shortage = np.sum(shortage)
        total_demand = np.sum(demand_series)
        supply_rate = 1 - (total_shortage / total_demand)
        
        return {
            'V': V,
            'Z': Z,
            'Q_out': Q_out,
            'supply': supply,
            'shortage': shortage,
            'supply_rate': supply_rate
        }


class FloodControl(Reservoir):
    """
    防洪调度
    """
    
    def __init__(self, *args, safe_discharge=None, **kwargs):
        """
        参数:
            safe_discharge: 下游安全泄量 (m³/s)
        """
        super().__init__(*args, **kwargs)
        self.Q_safe = safe_discharge
    
    def flood_routing(self, inflow_hydrograph, V0=None):
        """
        洪水调节计算（水量平衡法）
        
        参数:
            inflow_hydrograph: 入库流量过程 [(t, Q), ...] (h, m³/s)
            V0: 初始库容 (万m³)
        
        返回:
            调节结果
        """
        if V0 is None:
            V0 = self.level_to_volume(self.Z_flood)
        
        t_data, Q_in = zip(*inflow_hydrograph)
        n = len(t_data)
        dt = (t_data[1] - t_data[0]) if n > 1 else 1  # 时段(h)
        
        # 初始化
        V = np.zeros(n + 1)
        Z = np.zeros(n + 1)
        Q_out = np.zeros(n)
        
        V[0] = V0
        Z[0] = self.volume_to_level(V[0])
        
        # 逐时段调洪
        for i in range(n):
            # 出库流量决策
            if Z[i] < self.Z_flood:
                # 低于汛限水位，可不泄或少泄
                Q_out[i] = min(Q_in[i], self.Q_safe) if self.Q_safe else 0
            else:
                # 高于汛限水位，需要泄洪
                # 简化：出库=入库（调平洪峰）
                Q_out[i] = Q_in[i]
                
                # 考虑安全泄量约束
                if self.Q_safe and Q_out[i] > self.Q_safe * 1.5:
                    # 削减出库流量
                    Q_out[i] = self.Q_safe * 1.2
            
            # 水量平衡（小时步长）
            V[i+1] = self.water_balance(V[i], Q_in[i], Q_out[i], dt=dt/24)
            Z[i+1] = self.volume_to_level(V[i+1])
        
        # 统计
        peak_inflow = max(Q_in)
        peak_outflow = max(Q_out)
        peak_reduction = (peak_inflow - peak_outflow) / peak_inflow * 100
        max_level = max(Z)
        
        return {
            't': t_data,
            'Q_in': Q_in,
            'Q_out': Q_out,
            'V': V[:-1],
            'Z': Z[:-1],
            'peak_inflow': peak_inflow,
            'peak_outflow': peak_outflow,
            'peak_reduction': peak_reduction,
            'max_level': max_level
        }
    
    def plot_flood_routing(self, result):
        """
        绘制调洪过程
        """
        fig, axes = plt.subplots(2, 1, figsize=(12, 10))
        
        # 流量过程
        axes[0].plot(result['t'], result['Q_in'], 'b-', 
                    linewidth=2, label='入库流量', marker='o')
        axes[0].plot(result['t'], result['Q_out'], 'r-',
                    linewidth=2, label='出库流量', marker='s')
        
        if self.Q_safe:
            axes[0].axhline(self.Q_safe, color='g', linestyle='--',
                          label=f'安全泄量 {self.Q_safe}m³/s')
        
        axes[0].set_xlabel('时间 (h)', fontsize=12)
        axes[0].set_ylabel('流量 (m³/s)', fontsize=12)
        axes[0].set_title(f'洪水调节过程 - 削峰{result["peak_reduction"]:.1f}%',
                         fontsize=14)
        axes[0].legend()
        axes[0].grid(True, alpha=0.3)
        
        # 水位过程
        axes[1].plot(result['t'], result['Z'], 'b-',
                    linewidth=2, label='水位', marker='o')
        axes[1].axhline(self.Z_flood, color='r', linestyle='--',
                       label=f'汛限水位 {self.Z_flood}m')
        axes[1].axhline(self.Z_normal, color='g', linestyle='--',
                       label=f'正常水位 {self.Z_normal}m')
        
        axes[1].set_xlabel('时间 (h)', fontsize=12)
        axes[1].set_ylabel('水位 (m)', fontsize=12)
        axes[1].set_title('水位变化过程', fontsize=14)
        axes[1].legend()
        axes[1].grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('flood_routing_result.png', dpi=300, bbox_inches='tight')
        plt.show()


# ============ 使用示例 ============

def example_conservation_scheduling():
    """
    示例1：兴利调度
    """
    print("="*60)
    print("示例1：年调节计算")
    print("="*60)
    
    # 创建水库
    capacity_curve = [
        (100, 0),      # 死水位
        (110, 5000),
        (120, 15000),
        (130, 30000),  # 正常水位
        (135, 40000),  # 防洪限制水位
    ]
    
    reservoir = ConservationScheduling(
        name="示例水库",
        dead_level=100,
        normal_level=130,
        flood_level=135,
        capacity_curve=capacity_curve
    )
    
    # 月入流（枯水年）
    inflow_monthly = np.array([
        50, 40, 35, 30, 40, 60,   # 1-6月
        80, 100, 90, 70, 60, 50    # 7-12月
    ])  # m³/s
    
    # 月需水
    demand_monthly = np.array([
        8000, 9000, 10000, 12000, 15000, 18000,
        20000, 18000, 15000, 12000, 10000, 8000
    ])  # 万m³
    
    # 年调节
    result = reservoir.annual_regulation(inflow_monthly, demand_monthly)
    
    print(f"\n调节结果:")
    print(f"  供水保证率: {result['supply_rate']*100:.1f}%")
    print(f"  总缺水量: {np.sum(result['shortage']):.0f} 万m³")
    
    # 绘图
    fig, axes = plt.subplots(3, 1, figsize=(12, 10))
    
    months = np.arange(1, 13)
    
    # 水位
    axes[0].plot(months, result['Z'][:-1], 'b-o', linewidth=2)
    axes[0].axhline(reservoir.Z_normal, color='g', linestyle='--', label='正常水位')
    axes[0].axhline(reservoir.Z_dead, color='r', linestyle='--', label='死水位')
    axes[0].set_ylabel('水位 (m)')
    axes[0].set_title('水位过程')
    axes[0].legend()
    axes[0].grid(True, alpha=0.3)
    
    # 供需
    axes[1].bar(months-0.2, demand_monthly/1000, width=0.4, 
               label='需水', alpha=0.7)
    axes[1].bar(months+0.2, result['supply']/1000, width=0.4,
               label='供水', alpha=0.7)
    axes[1].set_ylabel('水量 (万m³)')
    axes[1].set_title('供需平衡')
    axes[1].legend()
    axes[1].grid(True, alpha=0.3)
    
    # 缺水
    axes[2].bar(months, result['shortage']/1000, color='red', alpha=0.7)
    axes[2].set_xlabel('月份')
    axes[2].set_ylabel('缺水量 (万m³)')
    axes[2].set_title('缺水情况')
    axes[2].grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.savefig('conservation_scheduling.png', dpi=300, bbox_inches='tight')
    plt.show()


def example_flood_control():
    """
    示例2：防洪调度
    """
    print("\n" + "="*60)
    print("示例2：洪水调节")
    print("="*60)
    
    # 创建水库（同上）
    capacity_curve = [
        (100, 0), (110, 5000), (120, 15000),
        (130, 30000), (135, 40000), (138, 50000)
    ]
    
    reservoir = FloodControl(
        name="示例水库",
        dead_level=100,
        normal_level=130,
        flood_level=135,
        capacity_curve=capacity_curve,
        safe_discharge=2000
    )
    
    # 设计洪水过程（简化三角形）
    t = np.array([0, 6, 12, 18, 24, 30, 36, 42, 48])
    Q_in = np.array([500, 1500, 3000, 4000, 3500, 2500, 1500, 800, 500])
    
    inflow_hydrograph = list(zip(t, Q_in))
    
    # 调洪计算
    result = reservoir.flood_routing(inflow_hydrograph)
    
    print(f"\n调洪结果:")
    print(f"  入库洪峰: {result['peak_inflow']:.0f} m³/s")
    print(f"  出库洪峰: {result['peak_outflow']:.0f} m³/s")
    print(f"  削峰率: {result['peak_reduction']:.1f}%")
    print(f"  最高水位: {result['max_level']:.2f} m")
    
    # 绘图
    reservoir.plot_flood_routing(result)


# 运行示例
if __name__ == "__main__":
    example_conservation_scheduling()
    example_flood_control()
```

---

## 四、优化算法

### 4.1 动态规划

```python
def dynamic_programming_optimization(stages, states, transitions):
    """
    动态规划求解最优调度
    
    参数:
        stages: 时段数
        states: 每个时段的状态空间
        transitions: 状态转移函数
    """
    pass  # 详细实现见完整代码
```

---

## 五、项目作业

### 作业1（必做）
1. 完善发电调度模块
2. 实现多目标优化（防洪+发电）
3. 添加可视化决策界面

### 作业2（选做）
设计梯级水库联合调度系统，考虑：
- 上下游水力联系
- 补偿调节
- 协同优化

---

**项目总结**：
- 水库调度完整体系
- 兴利与防洪结合
- 优化算法应用
- 决策支持系统

**下一项目**：水质模拟与污染控制
