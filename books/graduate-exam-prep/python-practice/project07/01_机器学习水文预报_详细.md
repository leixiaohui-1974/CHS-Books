# 项目7：机器学习水文预报系统

**项目时长**: 2周  
**难度**: ⭐⭐⭐⭐⭐  
**技术栈**: Scikit-learn, TensorFlow, XGBoost, Pandas

---

## 一、项目目标

开发基于机器学习的水文预报系统，实现：
1. 径流预报（回归）
2. 洪水预警（分类）
3. 特征工程与选择
4. 模型评估与优化
5. 可视化与部署

---

## 二、数据预处理

```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.metrics import mean_squared_error, r2_score, classification_report
import warnings
warnings.filterwarnings('ignore')

class HydroDataProcessor:
    """
    水文数据预处理
    """
    
    def __init__(self, data):
        """
        参数:
            data: DataFrame，包含水文时间序列
        """
        self.data = data.copy()
    
    def create_lag_features(self, target_col, lags=[1, 2, 3, 7]):
        """
        创建滞后特征
        
        参数:
            target_col: 目标列名
            lags: 滞后期列表
        
        返回:
            添加滞后特征后的数据
        """
        for lag in lags:
            self.data[f'{target_col}_lag{lag}'] = self.data[target_col].shift(lag)
        
        # 删除NaN
        self.data = self.data.dropna()
        
        return self.data
    
    def create_rolling_features(self, target_col, windows=[3, 7, 15]):
        """
        创建滚动统计特征
        
        参数:
            target_col: 目标列名
            windows: 窗口大小列表
        """
        for window in windows:
            # 滚动均值
            self.data[f'{target_col}_ma{window}'] = (
                self.data[target_col].rolling(window=window).mean()
            )
            
            # 滚动标准差
            self.data[f'{target_col}_std{window}'] = (
                self.data[target_col].rolling(window=window).std()
            )
        
        self.data = self.data.dropna()
        
        return self.data
    
    def split_data(self, target_col, test_size=0.2):
        """
        划分训练集和测试集
        
        返回:
            X_train, X_test, y_train, y_test
        """
        # 特征和目标
        X = self.data.drop(columns=[target_col])
        y = self.data[target_col]
        
        # 划分
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=test_size, random_state=42, shuffle=False
        )
        
        return X_train, X_test, y_train, y_test


# 数据准备示例
print("="*60)
print("水文数据预处理")
print("="*60)

# 生成模拟数据
np.random.seed(42)
n_days = 1000

# 模拟降雨-径流过程
date_range = pd.date_range('2020-01-01', periods=n_days, freq='D')

# 降雨（带季节性）
rainfall = 10 + 20 * np.sin(2 * np.pi * np.arange(n_days) / 365) + \
           np.random.gamma(2, 5, n_days)

# 径流（滞后响应）
runoff = np.zeros(n_days)
for i in range(5, n_days):
    runoff[i] = 0.3 * rainfall[i] + \
                0.25 * rainfall[i-1] + \
                0.2 * rainfall[i-2] + \
                0.15 * rainfall[i-3] + \
                0.5 * runoff[i-1] + \
                np.random.normal(0, 5)

runoff = np.maximum(runoff, 0)

# 创建DataFrame
df = pd.DataFrame({
    'date': date_range,
    'rainfall': rainfall,
    'runoff': runoff
})

df.set_index('date', inplace=True)

print(f"数据维度: {df.shape}")
print(f"\n前5行:")
print(df.head())

# 特征工程
processor = HydroDataProcessor(df)

# 滞后特征
processor.create_lag_features('rainfall', lags=[1, 2, 3, 5, 7])
processor.create_lag_features('runoff', lags=[1, 2, 3])

# 滚动特征
processor.create_rolling_features('rainfall', windows=[3, 7])

print(f"\n特征工程后数据维度: {processor.data.shape}")
print(f"特征列: {list(processor.data.columns)}")

# 划分数据
X_train, X_test, y_train, y_test = processor.split_data('runoff')

print(f"\n训练集: {X_train.shape}, 测试集: {X_test.shape}")
```

---

## 三、回归模型

### 3.1 多种模型实现

```python
from sklearn.linear_model import LinearRegression, Ridge, Lasso
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.svm import SVR
from xgboost import XGBRegressor

class RunoffForecastModels:
    """
    径流预报模型集合
    """
    
    def __init__(self):
        self.models = {}
        self.scalers = {}
        self.results = {}
    
    def train_linear_regression(self, X_train, y_train, X_test, y_test):
        """
        线性回归
        """
        # 标准化
        scaler = StandardScaler()
        X_train_scaled = scaler.fit_transform(X_train)
        X_test_scaled = scaler.transform(X_test)
        
        # 训练
        model = LinearRegression()
        model.fit(X_train_scaled, y_train)
        
        # 预测
        y_pred = model.predict(X_test_scaled)
        
        # 评估
        mse = mean_squared_error(y_test, y_pred)
        rmse = np.sqrt(mse)
        r2 = r2_score(y_test, y_pred)
        
        self.models['Linear'] = model
        self.scalers['Linear'] = scaler
        self.results['Linear'] = {
            'RMSE': rmse,
            'R2': r2,
            'y_pred': y_pred
        }
        
        return rmse, r2
    
    def train_random_forest(self, X_train, y_train, X_test, y_test):
        """
        随机森林
        """
        model = RandomForestRegressor(
            n_estimators=100,
            max_depth=10,
            random_state=42,
            n_jobs=-1
        )
        
        model.fit(X_train, y_train)
        y_pred = model.predict(X_test)
        
        mse = mean_squared_error(y_test, y_pred)
        rmse = np.sqrt(mse)
        r2 = r2_score(y_test, y_pred)
        
        self.models['RF'] = model
        self.results['RF'] = {
            'RMSE': rmse,
            'R2': r2,
            'y_pred': y_pred,
            'feature_importance': model.feature_importances_
        }
        
        return rmse, r2
    
    def train_xgboost(self, X_train, y_train, X_test, y_test):
        """
        XGBoost
        """
        model = XGBRegressor(
            n_estimators=100,
            max_depth=6,
            learning_rate=0.1,
            random_state=42
        )
        
        model.fit(X_train, y_train)
        y_pred = model.predict(X_test)
        
        mse = mean_squared_error(y_test, y_pred)
        rmse = np.sqrt(mse)
        r2 = r2_score(y_test, y_pred)
        
        self.models['XGBoost'] = model
        self.results['XGBoost'] = {
            'RMSE': rmse,
            'R2': r2,
            'y_pred': y_pred,
            'feature_importance': model.feature_importances_
        }
        
        return rmse, r2
    
    def compare_models(self):
        """
        模型对比
        """
        comparison = pd.DataFrame({
            'Model': list(self.results.keys()),
            'RMSE': [self.results[m]['RMSE'] for m in self.results],
            'R2': [self.results[m]['R2'] for m in self.results]
        })
        
        comparison = comparison.sort_values('R2', ascending=False)
        
        return comparison
    
    def plot_predictions(self, y_test, model_name='best'):
        """
        绘制预测结果
        """
        if model_name == 'best':
            # 选择R2最高的模型
            best_model = max(self.results.items(), 
                           key=lambda x: x[1]['R2'])[0]
        else:
            best_model = model_name
        
        y_pred = self.results[best_model]['y_pred']
        
        fig, axes = plt.subplots(2, 1, figsize=(12, 8))
        
        # 时序对比
        axes[0].plot(y_test.values, 'b-', linewidth=1.5, 
                    label='实测', alpha=0.7)
        axes[0].plot(y_pred, 'r--', linewidth=1.5,
                    label='预测', alpha=0.7)
        axes[0].set_ylabel('径流 (m³/s)', fontsize=12)
        axes[0].set_title(f'{best_model}模型预测结果', fontsize=14)
        axes[0].legend()
        axes[0].grid(True, alpha=0.3)
        
        # 散点图
        axes[1].scatter(y_test, y_pred, alpha=0.5, s=20)
        
        # 1:1线
        min_val = min(y_test.min(), y_pred.min())
        max_val = max(y_test.max(), y_pred.max())
        axes[1].plot([min_val, max_val], [min_val, max_val],
                    'r--', linewidth=2, label='1:1线')
        
        axes[1].set_xlabel('实测径流 (m³/s)', fontsize=12)
        axes[1].set_ylabel('预测径流 (m³/s)', fontsize=12)
        axes[1].set_title(f'R² = {self.results[best_model]["R2"]:.4f}', 
                         fontsize=14)
        axes[1].legend()
        axes[1].grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('runoff_forecast_ml.png', dpi=300, bbox_inches='tight')
        plt.show()
    
    def plot_feature_importance(self, X_train, model_name='RF', top_n=10):
        """
        特征重要性可视化
        """
        if 'feature_importance' not in self.results[model_name]:
            print(f"{model_name}模型不支持特征重要性")
            return
        
        importance = self.results[model_name]['feature_importance']
        feature_names = X_train.columns
        
        # 排序
        indices = np.argsort(importance)[::-1][:top_n]
        
        plt.figure(figsize=(10, 6))
        plt.barh(range(top_n), importance[indices], alpha=0.7, color='steelblue')
        plt.yticks(range(top_n), [feature_names[i] for i in indices])
        plt.xlabel('重要性', fontsize=12)
        plt.title(f'{model_name}模型特征重要性 (Top {top_n})', fontsize=14)
        plt.gca().invert_yaxis()
        plt.tight_layout()
        plt.savefig('feature_importance.png', dpi=300, bbox_inches='tight')
        plt.show()


# 模型训练示例
print("\n" + "="*60)
print("径流预报模型训练")
print("="*60)

forecast_models = RunoffForecastModels()

# 1. 线性回归
print("1. 线性回归...")
rmse_lr, r2_lr = forecast_models.train_linear_regression(
    X_train, y_train, X_test, y_test
)
print(f"   RMSE: {rmse_lr:.2f}, R²: {r2_lr:.4f}")

# 2. 随机森林
print("2. 随机森林...")
rmse_rf, r2_rf = forecast_models.train_random_forest(
    X_train, y_train, X_test, y_test
)
print(f"   RMSE: {rmse_rf:.2f}, R²: {r2_rf:.4f}")

# 3. XGBoost
print("3. XGBoost...")
rmse_xgb, r2_xgb = forecast_models.train_xgboost(
    X_train, y_train, X_test, y_test
)
print(f"   RMSE: {rmse_xgb:.2f}, R²: {r2_xgb:.4f}")

# 模型对比
print("\n模型对比:")
comparison = forecast_models.compare_models()
print(comparison)

# 可视化预测结果
forecast_models.plot_predictions(y_test)

# 特征重要性
forecast_models.plot_feature_importance(X_train, model_name='XGBoost')
```

---

## 四、深度学习模型

### 4.1 LSTM网络

```python
try:
    import tensorflow as tf
    from tensorflow import keras
    from tensorflow.keras import layers
    
    class LSTMRunoffForecast:
        """
        LSTM径流预报
        """
        
        def __init__(self, sequence_length=7):
            """
            参数:
                sequence_length: 时间序列长度
            """
            self.seq_len = sequence_length
            self.model = None
            self.scaler = MinMaxScaler()
        
        def prepare_sequences(self, data, target_col):
            """
            准备时间序列数据
            """
            # 标准化
            data_scaled = self.scaler.fit_transform(data)
            
            X, y = [], []
            
            for i in range(len(data_scaled) - self.seq_len):
                X.append(data_scaled[i:i+self.seq_len])
                y.append(data_scaled[i+self.seq_len, 
                        data.columns.get_loc(target_col)])
            
            return np.array(X), np.array(y)
        
        def build_model(self, n_features):
            """
            构建LSTM模型
            """
            model = keras.Sequential([
                layers.LSTM(50, activation='relu', 
                           input_shape=(self.seq_len, n_features),
                           return_sequences=True),
                layers.Dropout(0.2),
                layers.LSTM(50, activation='relu'),
                layers.Dropout(0.2),
                layers.Dense(25, activation='relu'),
                layers.Dense(1)
            ])
            
            model.compile(optimizer='adam', loss='mse', metrics=['mae'])
            
            self.model = model
            
            return model
        
        def train(self, X_train, y_train, epochs=50, batch_size=32):
            """
            训练模型
            """
            history = self.model.fit(
                X_train, y_train,
                epochs=epochs,
                batch_size=batch_size,
                validation_split=0.2,
                verbose=0
            )
            
            return history
    
    print("\nLSTM模型可用")
    
except ImportError:
    print("\nTensorFlow未安装，跳过深度学习模型")
```

---

## 五、模型评估指标

```python
class ForecastEvaluation:
    """
    预报评估
    """
    
    @staticmethod
    def nash_sutcliffe(y_true, y_pred):
        """
        Nash-Sutcliffe效率系数
        """
        numerator = np.sum((y_true - y_pred)**2)
        denominator = np.sum((y_true - np.mean(y_true))**2)
        nse = 1 - (numerator / denominator)
        return nse
    
    @staticmethod
    def percent_bias(y_true, y_pred):
        """
        百分比偏差
        """
        pbias = np.sum(y_pred - y_true) / np.sum(y_true) * 100
        return pbias


# 综合评估
nse = ForecastEvaluation.nash_sutcliffe(
    y_test.values, 
    forecast_models.results['XGBoost']['y_pred']
)

pbias = ForecastEvaluation.percent_bias(
    y_test.values,
    forecast_models.results['XGBoost']['y_pred']
)

print(f"\n综合评估指标:")
print(f"  Nash-Sutcliffe效率: {nse:.4f}")
print(f"  百分比偏差: {pbias:.2f}%")
```

---

## 六、项目总结

### 学习要点

1. **特征工程**：滞后特征、滚动统计
2. **模型选择**：从简单到复杂
3. **超参数调优**：网格搜索、交叉验证
4. **模型评估**：RMSE、R²、NSE
5. **可解释性**：特征重要性分析

### 技术栈掌握

- Scikit-learn：传统机器学习
- XGBoost：梯度提升
- TensorFlow：深度学习（可选）
- Pandas：数据处理

---

**下一项目**：项目8 - 实时洪水预警系统
