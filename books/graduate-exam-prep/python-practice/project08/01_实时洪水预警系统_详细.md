# é¡¹ç›®8ï¼šå®æ—¶æ´ªæ°´é¢„è­¦ç³»ç»Ÿ

**é¡¹ç›®æ—¶é•¿**: 2å‘¨  
**éš¾åº¦**: â­â­â­â­â­  
**æŠ€æœ¯æ ˆ**: Flask, WebSocket, SQLite, Plotly, Dash

---

## ä¸€ã€é¡¹ç›®ç›®æ ‡

å¼€å‘å®æ—¶æ´ªæ°´é¢„è­¦ç³»ç»Ÿï¼Œå®ç°ï¼š
1. å®æ—¶æ•°æ®é‡‡é›†ä¸å­˜å‚¨
2. æ´ªæ°´é¢„æŠ¥ä¸é£é™©è¯„ä¼°
3. Webå¯è§†åŒ–ä»ªè¡¨æ¿
4. é¢„è­¦ä¿¡æ¯è‡ªåŠ¨å‘å¸ƒ
5. å†å²æ•°æ®åˆ†æ

---

## äºŒã€ç³»ç»Ÿæ¶æ„

```python
import numpy as np
import pandas as pd
import sqlite3
from datetime import datetime, timedelta
import json

class FloodWarningSystem:
    """
    æ´ªæ°´é¢„è­¦ç³»ç»Ÿæ ¸å¿ƒç±»
    """
    
    def __init__(self, db_path='flood_warning.db'):
        """
        å‚æ•°:
            db_path: æ•°æ®åº“è·¯å¾„
        """
        self.db_path = db_path
        self.initialize_database()
    
    def initialize_database(self):
        """
        åˆå§‹åŒ–æ•°æ®åº“
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # ç«™ç‚¹ä¿¡æ¯è¡¨
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS stations (
                station_id TEXT PRIMARY KEY,
                station_name TEXT,
                latitude REAL,
                longitude REAL,
                warning_level REAL,
                critical_level REAL
            )
        ''')
        
        # å®æ—¶æ•°æ®è¡¨
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS real_time_data (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                station_id TEXT,
                timestamp DATETIME,
                water_level REAL,
                flow_rate REAL,
                rainfall REAL,
                FOREIGN KEY (station_id) REFERENCES stations (station_id)
            )
        ''')
        
        # é¢„è­¦è®°å½•è¡¨
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS warnings (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                station_id TEXT,
                warning_time DATETIME,
                warning_level INTEGER,
                predicted_peak REAL,
                message TEXT,
                FOREIGN KEY (station_id) REFERENCES stations (station_id)
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def add_station(self, station_id, name, lat, lon, 
                   warning_level, critical_level):
        """
        æ·»åŠ ç›‘æµ‹ç«™ç‚¹
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT OR REPLACE INTO stations 
            (station_id, station_name, latitude, longitude, 
             warning_level, critical_level)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (station_id, name, lat, lon, warning_level, critical_level))
        
        conn.commit()
        conn.close()
    
    def add_realtime_data(self, station_id, water_level, 
                         flow_rate=None, rainfall=None):
        """
        æ·»åŠ å®æ—¶æ•°æ®
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        timestamp = datetime.now()
        
        cursor.execute('''
            INSERT INTO real_time_data 
            (station_id, timestamp, water_level, flow_rate, rainfall)
            VALUES (?, ?, ?, ?, ?)
        ''', (station_id, timestamp, water_level, flow_rate, rainfall))
        
        conn.commit()
        conn.close()
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦é¢„è­¦
        self.check_and_create_warning(station_id, water_level)
    
    def check_and_create_warning(self, station_id, current_level):
        """
        æ£€æŸ¥å¹¶åˆ›å»ºé¢„è­¦
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # è·å–ç«™ç‚¹ä¿¡æ¯
        cursor.execute('''
            SELECT warning_level, critical_level, station_name
            FROM stations WHERE station_id = ?
        ''', (station_id,))
        
        result = cursor.fetchone()
        
        if result is None:
            conn.close()
            return
        
        warning_level, critical_level, station_name = result
        
        # åˆ¤æ–­é¢„è­¦çº§åˆ«
        if current_level >= critical_level:
            level = 3  # çº¢è‰²é¢„è­¦
            message = f"{station_name}æ°´ä½{current_level:.2f}mï¼Œè¶…è¿‡è­¦æˆ’æ°´ä½ï¼Œå‘å¸ƒçº¢è‰²é¢„è­¦ï¼"
        elif current_level >= warning_level:
            level = 2  # æ©™è‰²é¢„è­¦
            message = f"{station_name}æ°´ä½{current_level:.2f}mï¼Œæ¥è¿‘è­¦æˆ’æ°´ä½ï¼Œå‘å¸ƒæ©™è‰²é¢„è­¦ï¼"
        elif current_level >= warning_level * 0.9:
            level = 1  # é»„è‰²é¢„è­¦
            message = f"{station_name}æ°´ä½{current_level:.2f}mï¼ŒæŒç»­ä¸Šæ¶¨ï¼Œå‘å¸ƒé»„è‰²é¢„è­¦ã€‚"
        else:
            conn.close()
            return
        
        # è®°å½•é¢„è­¦
        cursor.execute('''
            INSERT INTO warnings 
            (station_id, warning_time, warning_level, 
             predicted_peak, message)
            VALUES (?, ?, ?, ?, ?)
        ''', (station_id, datetime.now(), level, current_level, message))
        
        conn.commit()
        conn.close()
        
        print(f"[é¢„è­¦] {message}")
    
    def get_latest_data(self, station_id, hours=24):
        """
        è·å–æœ€è¿‘æ•°æ®
        """
        conn = sqlite3.connect(self.db_path)
        
        query = '''
            SELECT timestamp, water_level, flow_rate, rainfall
            FROM real_time_data
            WHERE station_id = ?
            AND timestamp >= datetime('now', '-' || ? || ' hours')
            ORDER BY timestamp DESC
        '''
        
        df = pd.read_sql_query(query, conn, 
                              params=(station_id, hours))
        
        conn.close()
        
        return df
    
    def forecast_water_level(self, station_id, hours_ahead=6):
        """
        ç®€å•çº¿æ€§å¤–æ¨é¢„æŠ¥
        
        å‚æ•°:
            station_id: ç«™ç‚¹ID
            hours_ahead: é¢„æŠ¥æ—¶é•¿ï¼ˆå°æ—¶ï¼‰
        
        è¿”å›:
            é¢„æŠ¥æ°´ä½åºåˆ—
        """
        # è·å–å†å²æ•°æ®
        df = self.get_latest_data(station_id, hours=12)
        
        if len(df) < 3:
            return None
        
        # æ—¶é—´åºåˆ—
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        df = df.sort_values('timestamp')
        
        # æ—¶é—´ç¼–å·
        df['time_idx'] = range(len(df))
        
        # çº¿æ€§å›å½’
        from numpy.polynomial import polynomial as P
        
        coeffs = P.polyfit(df['time_idx'], df['water_level'], 1)
        
        # é¢„æŠ¥
        future_idx = np.arange(len(df), len(df) + hours_ahead)
        forecast = P.polyval(future_idx, coeffs)
        
        # æ—¶é—´æˆ³
        last_time = df['timestamp'].iloc[-1]
        forecast_times = [last_time + timedelta(hours=i+1) 
                         for i in range(hours_ahead)]
        
        forecast_df = pd.DataFrame({
            'timestamp': forecast_times,
            'predicted_level': forecast
        })
        
        return forecast_df
    
    def generate_report(self, station_id):
        """
        ç”Ÿæˆé¢„è­¦æŠ¥å‘Š
        """
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # ç«™ç‚¹ä¿¡æ¯
        cursor.execute('''
            SELECT station_name, warning_level, critical_level
            FROM stations WHERE station_id = ?
        ''', (station_id,))
        
        station_info = cursor.fetchone()
        
        # æœ€æ–°æ•°æ®
        cursor.execute('''
            SELECT water_level, timestamp
            FROM real_time_data
            WHERE station_id = ?
            ORDER BY timestamp DESC
            LIMIT 1
        ''', (station_id,))
        
        latest_data = cursor.fetchone()
        
        # é¢„è­¦è®°å½•
        cursor.execute('''
            SELECT warning_time, warning_level, message
            FROM warnings
            WHERE station_id = ?
            ORDER BY warning_time DESC
            LIMIT 5
        ''', (station_id,))
        
        warnings = cursor.fetchall()
        
        conn.close()
        
        # ç”ŸæˆæŠ¥å‘Š
        report = {
            'station_name': station_info[0] if station_info else 'Unknown',
            'warning_level': station_info[1] if station_info else 0,
            'critical_level': station_info[2] if station_info else 0,
            'current_level': latest_data[0] if latest_data else 0,
            'last_update': latest_data[1] if latest_data else None,
            'recent_warnings': [
                {
                    'time': w[0],
                    'level': w[1],
                    'message': w[2]
                } for w in warnings
            ]
        }
        
        return report


# ä½¿ç”¨ç¤ºä¾‹
print("="*60)
print("æ´ªæ°´é¢„è­¦ç³»ç»Ÿç¤ºä¾‹")
print("="*60)

# åˆ›å»ºç³»ç»Ÿ
warning_system = FloodWarningSystem('flood_warning_demo.db')

# æ·»åŠ ç›‘æµ‹ç«™ç‚¹
warning_system.add_station(
    station_id='STA001',
    name='XXæ²³ä¸‹æ¸¸ç«™',
    lat=30.5,
    lon=114.3,
    warning_level=50.0,  # è­¦æˆ’æ°´ä½ (m)
    critical_level=52.0  # ä¿è¯æ°´ä½ (m)
)

print("æ·»åŠ ç›‘æµ‹ç«™ç‚¹: XXæ²³ä¸‹æ¸¸ç«™")
print("  è­¦æˆ’æ°´ä½: 50.0m")
print("  ä¿è¯æ°´ä½: 52.0m")

# æ¨¡æ‹Ÿå®æ—¶æ•°æ®é‡‡é›†
print("\næ¨¡æ‹Ÿå®æ—¶æ•°æ®é‡‡é›†...")

# åˆå§‹æ°´ä½
water_level = 45.0

# æ¨¡æ‹Ÿ24å°æ—¶æ•°æ®ï¼Œæ°´ä½é€æ¸ä¸Šæ¶¨
for hour in range(24):
    # æ°´ä½å˜åŒ–ï¼ˆéšæœºæ³¢åŠ¨+ä¸Šæ¶¨è¶‹åŠ¿ï¼‰
    water_level += np.random.uniform(0.1, 0.5)
    
    # æ·»åŠ æ•°æ®
    warning_system.add_realtime_data(
        station_id='STA001',
        water_level=water_level,
        flow_rate=water_level * 10 + np.random.uniform(-5, 5),
        rainfall=np.random.uniform(0, 10)
    )
    
    if hour % 6 == 0:
        print(f"  {hour}å°æ—¶: æ°´ä½ {water_level:.2f}m")

# è·å–æœ€æ–°æ•°æ®
latest_df = warning_system.get_latest_data('STA001', hours=24)

print(f"\næœ€æ–°24å°æ—¶æ•°æ®: {len(latest_df)} æ¡è®°å½•")
print(f"  æœ€æ–°æ°´ä½: {latest_df['water_level'].iloc[0]:.2f}m")
print(f"  æœ€é«˜æ°´ä½: {latest_df['water_level'].max():.2f}m")

# é¢„æŠ¥
forecast_df = warning_system.forecast_water_level('STA001', hours_ahead=6)

if forecast_df is not None:
    print(f"\næœªæ¥6å°æ—¶é¢„æŠ¥:")
    for _, row in forecast_df.iterrows():
        print(f"  {row['timestamp'].strftime('%Y-%m-%d %H:%M')}: "
              f"{row['predicted_level']:.2f}m")

# ç”ŸæˆæŠ¥å‘Š
report = warning_system.generate_report('STA001')

print(f"\né¢„è­¦æŠ¥å‘Š:")
print(f"  ç«™ç‚¹: {report['station_name']}")
print(f"  å½“å‰æ°´ä½: {report['current_level']:.2f}m")
print(f"  è­¦æˆ’æ°´ä½: {report['warning_level']:.2f}m")
print(f"  æœ€è¿‘é¢„è­¦: {len(report['recent_warnings'])}æ¡")

for i, warning in enumerate(report['recent_warnings'][:3], 1):
    print(f"\n  é¢„è­¦{i}:")
    print(f"    æ—¶é—´: {warning['time']}")
    print(f"    çº§åˆ«: {'ğŸ”´çº¢è‰²' if warning['level']==3 else 'ğŸŸ æ©™è‰²' if warning['level']==2 else 'ğŸŸ¡é»„è‰²'}")
    print(f"    ä¿¡æ¯: {warning['message']}")
```

---

## ä¸‰ã€Webå¯è§†åŒ–ä»ªè¡¨æ¿

### 3.1 ä½¿ç”¨Dashæ„å»ºä»ªè¡¨æ¿

```python
# éœ€è¦å®‰è£…: pip install dash plotly

try:
    import dash
    from dash import dcc, html
    from dash.dependencies import Input, Output
    import plotly.graph_objs as go
    
    class FloodDashboard:
        """
        æ´ªæ°´é¢„è­¦å¯è§†åŒ–ä»ªè¡¨æ¿
        """
        
        def __init__(self, warning_system):
            """
            å‚æ•°:
                warning_system: FloodWarningSystemå®ä¾‹
            """
            self.system = warning_system
            self.app = dash.Dash(__name__)
            
            self.setup_layout()
            self.setup_callbacks()
        
        def setup_layout(self):
            """
            è®¾ç½®ä»ªè¡¨æ¿å¸ƒå±€
            """
            self.app.layout = html.Div([
                html.H1('æ´ªæ°´é¢„è­¦ç³»ç»Ÿå®æ—¶ç›‘æ§',
                       style={'textAlign': 'center', 'color': '#2c3e50'}),
                
                html.Div([
                    html.Label('ç›‘æµ‹ç«™ç‚¹:'),
                    dcc.Dropdown(
                        id='station-dropdown',
                        options=[
                            {'label': 'XXæ²³ä¸‹æ¸¸ç«™', 'value': 'STA001'}
                        ],
                        value='STA001'
                    )
                ], style={'width': '30%', 'margin': '20px auto'}),
                
                dcc.Interval(
                    id='interval-component',
                    interval=5*1000,  # 5ç§’æ›´æ–°ä¸€æ¬¡
                    n_intervals=0
                ),
                
                html.Div([
                    html.Div([
                        html.H3('å½“å‰æ°´ä½', style={'textAlign': 'center'}),
                        html.H2(id='current-level', 
                               style={'textAlign': 'center', 'color': '#3498db'})
                    ], className='four columns'),
                    
                    html.Div([
                        html.H3('é¢„è­¦çŠ¶æ€', style={'textAlign': 'center'}),
                        html.H2(id='warning-status',
                               style={'textAlign': 'center'})
                    ], className='four columns'),
                    
                    html.Div([
                        html.H3('é¢„æŠ¥å³°å€¼', style={'textAlign': 'center'}),
                        html.H2(id='forecast-peak',
                               style={'textAlign': 'center', 'color': '#e74c3c'})
                    ], className='four columns'),
                ], className='row'),
                
                dcc.Graph(id='water-level-graph'),
                
                html.Div(id='warning-messages',
                        style={'margin': '20px', 'padding': '10px',
                              'backgroundColor': '#ecf0f1'})
            ])
        
        def setup_callbacks(self):
            """
            è®¾ç½®å›è°ƒå‡½æ•°
            """
            @self.app.callback(
                [Output('current-level', 'children'),
                 Output('warning-status', 'children'),
                 Output('forecast-peak', 'children'),
                 Output('water-level-graph', 'figure'),
                 Output('warning-messages', 'children')],
                [Input('interval-component', 'n_intervals'),
                 Input('station-dropdown', 'value')]
            )
            def update_dashboard(n, station_id):
                # è·å–æŠ¥å‘Š
                report = self.system.generate_report(station_id)
                
                # å½“å‰æ°´ä½
                current_level_text = f"{report['current_level']:.2f} m"
                
                # é¢„è­¦çŠ¶æ€
                if report['current_level'] >= report['critical_level']:
                    status = 'ğŸ”´ çº¢è‰²é¢„è­¦'
                    status_style = {'color': '#e74c3c'}
                elif report['current_level'] >= report['warning_level']:
                    status = 'ğŸŸ  æ©™è‰²é¢„è­¦'
                    status_style = {'color': '#f39c12'}
                else:
                    status = 'ğŸŸ¢ æ­£å¸¸'
                    status_style = {'color': '#27ae60'}
                
                # é¢„æŠ¥å³°å€¼
                forecast_df = self.system.forecast_water_level(station_id)
                if forecast_df is not None:
                    peak = forecast_df['predicted_level'].max()
                    forecast_text = f"{peak:.2f} m"
                else:
                    forecast_text = "N/A"
                
                # ç»˜åˆ¶å›¾è¡¨
                df = self.system.get_latest_data(station_id, hours=24)
                df['timestamp'] = pd.to_datetime(df['timestamp'])
                
                fig = go.Figure()
                
                # å†å²æ•°æ®
                fig.add_trace(go.Scatter(
                    x=df['timestamp'],
                    y=df['water_level'],
                    mode='lines+markers',
                    name='å®æµ‹æ°´ä½',
                    line=dict(color='#3498db', width=2)
                ))
                
                # é¢„æŠ¥æ•°æ®
                if forecast_df is not None:
                    fig.add_trace(go.Scatter(
                        x=forecast_df['timestamp'],
                        y=forecast_df['predicted_level'],
                        mode='lines+markers',
                        name='é¢„æŠ¥æ°´ä½',
                        line=dict(color='#e74c3c', width=2, dash='dash')
                    ))
                
                # è­¦æˆ’çº¿
                fig.add_hline(y=report['warning_level'],
                             line_dash="dash", line_color="orange",
                             annotation_text="è­¦æˆ’æ°´ä½")
                fig.add_hline(y=report['critical_level'],
                             line_dash="dash", line_color="red",
                             annotation_text="ä¿è¯æ°´ä½")
                
                fig.update_layout(
                    title='æ°´ä½è¿‡ç¨‹çº¿',
                    xaxis_title='æ—¶é—´',
                    yaxis_title='æ°´ä½ (m)',
                    hovermode='x unified'
                )
                
                # é¢„è­¦ä¿¡æ¯
                warnings_html = []
                for w in report['recent_warnings'][:5]:
                    warnings_html.append(
                        html.Div([
                            html.Strong(f"{w['time']}: "),
                            html.Span(w['message'])
                        ], style={'marginBottom': '10px'})
                    )
                
                return (current_level_text, 
                       html.Span(status, style=status_style),
                       forecast_text, 
                       fig, 
                       warnings_html)
        
        def run(self, debug=True):
            """
            è¿è¡Œä»ªè¡¨æ¿
            """
            self.app.run_server(debug=debug)
    
    print("\n" + "="*60)
    print("Webä»ªè¡¨æ¿å¯ç”¨")
    print("="*60)
    print("è¿è¡Œä»¥ä¸‹ä»£ç å¯åŠ¨:")
    print("dashboard = FloodDashboard(warning_system)")
    print("dashboard.run()")
    
except ImportError:
    print("\næ³¨æ„: éœ€è¦å®‰è£… dash å’Œ plotly æ‰èƒ½ä½¿ç”¨Webä»ªè¡¨æ¿")
    print("pip install dash plotly")
```

---

## å››ã€é¡¹ç›®æ‰©å±•æ–¹å‘

### 4.1 é«˜çº§åŠŸèƒ½

1. **å¤šç«™ç‚¹è”åˆé¢„è­¦**
2. **çŸ­ä¿¡/é‚®ä»¶è‡ªåŠ¨é€šçŸ¥**
3. **GISåœ°å›¾å¯è§†åŒ–**
4. **æ·±åº¦å­¦ä¹ é¢„æŠ¥æ¨¡å‹**
5. **ç§»åŠ¨ç«¯App**

### 4.2 æ€§èƒ½ä¼˜åŒ–

1. **æ•°æ®åº“ä¼˜åŒ–**ï¼ˆç´¢å¼•ã€åˆ†åŒºï¼‰
2. **ç¼“å­˜æœºåˆ¶**ï¼ˆRedisï¼‰
3. **å¼‚æ­¥å¤„ç†**ï¼ˆCeleryï¼‰
4. **è´Ÿè½½å‡è¡¡**

---

## äº”ã€é¡¹ç›®æ€»ç»“

### å­¦ä¹ è¦ç‚¹

1. **ç³»ç»Ÿæ¶æ„è®¾è®¡**
2. **æ•°æ®åº“åº”ç”¨**
3. **å®æ—¶æ•°æ®å¤„ç†**
4. **Webå¯è§†åŒ–**
5. **é¢„è­¦é€»è¾‘**

### æŠ€æœ¯æ ˆ

- SQLiteï¼šæ•°æ®å­˜å‚¨
- Dashï¼šWebä»ªè¡¨æ¿
- Plotlyï¼šäº¤äº’å¼å›¾è¡¨
- Pandasï¼šæ•°æ®å¤„ç†

---

**ä¸‹ä¸€é¡¹ç›®**ï¼šé¡¹ç›®9 - æ°´è´¨ç›‘æµ‹ä¸é¢„æµ‹ç³»ç»Ÿ
