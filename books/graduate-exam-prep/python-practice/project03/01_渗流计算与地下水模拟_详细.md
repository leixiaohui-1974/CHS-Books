# 项目3：渗流计算与地下水模拟系统

**项目难度**: ⭐⭐⭐⭐⭐  
**预计时间**: 12小时  
**知识点**: 渗流理论、数值求解、有限差分、可视化

---

## 一、项目目标

开发完整的地下水渗流计算系统：
1. 达西定律计算
2. 井流计算（承压水、潜水）
3. 井群干扰分析
4. 渗流场数值模拟
5. 等势线与流线绘制

---

## 二、核心理论

### 2.1 达西定律

$$v = ki$$

其中：
- v：渗透流速 (m/d)
- k：渗透系数 (m/d)
- i：水力梯度

### 2.2 裘布依公式（承压水完整井）

$$Q = \frac{2\pi kM(H-h_0)}{\ln(R/r_0)}$$

其中：
- Q：井流量 (m³/d)
- k：渗透系数 (m/d)
- M：含水层厚度 (m)
- H：初始水头 (m)
- h₀：井内水头 (m)
- R：影响半径 (m)
- r₀：井半径 (m)

---

## 三、完整实现

### 3.1 地下水核心类

```python
"""
groundwater.py
地下水渗流计算核心模块
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import fsolve
from scipy.interpolate import griddata
import matplotlib.tri as tri

class GroundwaterFlow:
    """
    地下水渗流基类
    """
    
    def __init__(self, k, domain_size=(1000, 1000)):
        """
        初始化
        
        参数:
            k: 渗透系数 (m/d)
            domain_size: 计算域大小 (m)
        """
        self.k = k
        self.domain_size = domain_size
    
    def darcy_velocity(self, i):
        """
        达西定律
        
        参数:
            i: 水力梯度
        """
        v = self.k * i
        return v
    
    def darcy_discharge(self, i, A):
        """
        达西流量
        
        参数:
            i: 水力梯度
            A: 过流断面积 (m²)
        """
        Q = self.k * i * A
        return Q


class ConfinedAquifer(GroundwaterFlow):
    """
    承压含水层
    """
    
    def __init__(self, k, M, H0, domain_size=(1000, 1000)):
        """
        参数:
            k: 渗透系数 (m/d)
            M: 含水层厚度 (m)
            H0: 初始水头 (m)
        """
        super().__init__(k, domain_size)
        self.M = M
        self.H0 = H0
    
    def well_flow_steady(self, s, R, r0):
        """
        稳定井流（裘布依公式）
        
        参数:
            s: 水位降深 (m)
            R: 影响半径 (m)
            r0: 井半径 (m)
        
        返回:
            流量 (m³/d)
        """
        Q = (2 * np.pi * self.k * self.M * s) / np.log(R / r0)
        return Q
    
    def drawdown_at_distance(self, Q, R, r):
        """
        距井r处的水位降深
        
        参数:
            Q: 井流量 (m³/d)
            R: 影响半径 (m)
            r: 距离 (m)
        """
        s_r = (Q / (2 * np.pi * self.k * self.M)) * np.log(R / r)
        return s_r
    
    def head_distribution(self, Q, R, r0, grid_size=50):
        """
        水头分布场
        
        返回:
            X, Y, H (网格坐标和水头)
        """
        x = np.linspace(-self.domain_size[0]/2, self.domain_size[0]/2, grid_size)
        y = np.linspace(-self.domain_size[1]/2, self.domain_size[1]/2, grid_size)
        X, Y = np.meshgrid(x, y)
        
        # 距井距离
        r = np.sqrt(X**2 + Y**2)
        r = np.maximum(r, r0)  # 避免r=0
        
        # 水位降深
        s = self.drawdown_at_distance(Q, R, r)
        
        # 水头
        H = self.H0 - s
        
        return X, Y, H, s
    
    def plot_head_contour(self, Q, R, r0):
        """
        绘制等水头线
        """
        X, Y, H, s = self.head_distribution(Q, R, r0)
        
        fig, axes = plt.subplots(1, 2, figsize=(14, 6))
        
        # 等水头线
        levels_H = np.linspace(np.min(H), np.max(H), 20)
        cs1 = axes[0].contour(X, Y, H, levels=levels_H, cmap='Blues')
        axes[0].clabel(cs1, inline=True, fontsize=8)
        axes[0].plot(0, 0, 'ro', markersize=10, label='抽水井')
        axes[0].set_xlabel('X (m)', fontsize=12)
        axes[0].set_ylabel('Y (m)', fontsize=12)
        axes[0].set_title('等水头线图', fontsize=14)
        axes[0].legend()
        axes[0].axis('equal')
        axes[0].grid(True, alpha=0.3)
        
        # 水位降深
        levels_s = np.linspace(0, np.max(s), 15)
        cs2 = axes[1].contourf(X, Y, s, levels=levels_s, cmap='YlOrRd')
        axes[1].plot(0, 0, 'ro', markersize=10, label='抽水井')
        axes[1].set_xlabel('X (m)', fontsize=12)
        axes[1].set_ylabel('Y (m)', fontsize=12)
        axes[1].set_title('水位降深分布', fontsize=14)
        axes[1].legend()
        axes[1].axis('equal')
        plt.colorbar(cs2, ax=axes[1], label='降深 (m)')
        
        plt.tight_layout()
        plt.savefig('head_distribution.png', dpi=300, bbox_inches='tight')
        plt.show()


class UnconfinedAquifer(GroundwaterFlow):
    """
    潜水含水层
    """
    
    def __init__(self, k, H0, domain_size=(1000, 1000)):
        """
        参数:
            k: 渗透系数 (m/d)
            H0: 初始水位 (m，从不透水层算起)
        """
        super().__init__(k, domain_size)
        self.H0 = H0
    
    def well_flow_steady(self, h0, R, r0):
        """
        潜水稳定井流（裘布依公式）
        
        Q = π*k*(H₀² - h₀²) / ln(R/r₀)
        
        参数:
            h0: 井内水位 (m)
            R: 影响半径 (m)
            r0: 井半径 (m)
        """
        Q = (np.pi * self.k * (self.H0**2 - h0**2)) / np.log(R / r0)
        return Q
    
    def water_table_at_distance(self, Q, R, r):
        """
        距井r处的水位
        
        h² = H₀² - (Q/(π*k))*ln(R/r)
        """
        h_squared = self.H0**2 - (Q / (np.pi * self.k)) * np.log(R / r)
        h = np.sqrt(np.maximum(h_squared, 0))  # 确保非负
        return h


class WellInterferenceSystem:
    """
    井群干扰系统
    """
    
    def __init__(self, aquifer):
        """
        参数:
            aquifer: ConfinedAquifer 或 UnconfinedAquifer 实例
        """
        self.aquifer = aquifer
        self.wells = []  # [(x, y, Q), ...]
    
    def add_well(self, x, y, Q):
        """
        添加抽水井
        
        参数:
            x, y: 井位置 (m)
            Q: 抽水量 (m³/d)
        """
        self.wells.append((x, y, Q))
    
    def superposition_head(self, x, y, R):
        """
        叠加原理计算(x,y)处水头
        
        对于承压水：H = H₀ - Σs_i
        """
        H = self.aquifer.H0
        
        for wx, wy, Q in self.wells:
            r = np.sqrt((x - wx)**2 + (y - wy)**2)
            if r < 0.01:  # 避免井点奇异
                r = 0.01
            
            # 该井引起的降深
            s_i = self.aquifer.drawdown_at_distance(Q, R, r)
            H -= s_i
        
        return H
    
    def interference_field(self, R, grid_size=100):
        """
        计算干扰场
        """
        x = np.linspace(-self.aquifer.domain_size[0]/2, 
                       self.aquifer.domain_size[0]/2, grid_size)
        y = np.linspace(-self.aquifer.domain_size[1]/2, 
                       self.aquifer.domain_size[1]/2, grid_size)
        X, Y = np.meshgrid(x, y)
        
        H = np.zeros_like(X)
        
        for i in range(grid_size):
            for j in range(grid_size):
                H[i, j] = self.superposition_head(X[i, j], Y[i, j], R)
        
        s = self.aquifer.H0 - H
        
        return X, Y, H, s
    
    def plot_interference_field(self, R):
        """
        绘制井群干扰场
        """
        X, Y, H, s = self.interference_field(R, grid_size=80)
        
        fig, ax = plt.subplots(figsize=(10, 8))
        
        # 等水位线
        levels = np.linspace(np.min(H), np.max(H), 20)
        cs = ax.contour(X, Y, H, levels=levels, cmap='Blues', linewidths=1.5)
        ax.clabel(cs, inline=True, fontsize=8)
        
        # 水位降深填充
        cf = ax.contourf(X, Y, s, levels=15, cmap='YlOrRd', alpha=0.6)
        
        # 标注井位
        for wx, wy, Q in self.wells:
            ax.plot(wx, wy, 'ro', markersize=12)
            ax.text(wx+20, wy+20, f'Q={Q}m³/d', fontsize=9, 
                   bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))
        
        ax.set_xlabel('X (m)', fontsize=12)
        ax.set_ylabel('Y (m)', fontsize=12)
        ax.set_title('井群干扰水位场', fontsize=14)
        ax.axis('equal')
        ax.grid(True, alpha=0.3)
        plt.colorbar(cf, ax=ax, label='水位降深 (m)')
        
        plt.tight_layout()
        plt.savefig('well_interference_field.png', dpi=300, bbox_inches='tight')
        plt.show()


# ============ 使用示例 ============

def example_confined_aquifer():
    """
    示例1：承压水单井流
    """
    print("="*60)
    print("示例1：承压水单井流计算")
    print("="*60)
    
    # 创建承压含水层
    aquifer = ConfinedAquifer(
        k=15,      # 渗透系数 15 m/d
        M=30,      # 厚度 30 m
        H0=50,     # 初始水头 50 m
        domain_size=(500, 500)
    )
    
    # 井参数
    s = 5      # 降深 5 m
    R = 150    # 影响半径 150 m
    r0 = 0.15  # 井半径 0.15 m
    
    # 计算井流量
    Q = aquifer.well_flow_steady(s, R, r0)
    print(f"\n井流量: Q = {Q:.2f} m³/d")
    
    # 不同距离处的降深
    distances = [1, 5, 10, 20, 50, 100]
    print(f"\n距井不同距离的水位降深:")
    for r in distances:
        s_r = aquifer.drawdown_at_distance(Q, R, r)
        print(f"  r = {r:3d}m: s = {s_r:.3f} m")
    
    # 绘制水头分布
    aquifer.plot_head_contour(Q, R, r0)


def example_well_interference():
    """
    示例2：井群干扰
    """
    print("\n" + "="*60)
    print("示例2：井群干扰分析")
    print("="*60)
    
    # 创建含水层
    aquifer = ConfinedAquifer(
        k=12,
        M=25,
        H0=60,
        domain_size=(600, 600)
    )
    
    # 创建井群系统
    well_system = WellInterferenceSystem(aquifer)
    
    # 添加抽水井
    wells_config = [
        (-100, 0, 1000),    # 井1
        (100, 0, 1000),     # 井2
        (0, 100, 800),      # 井3
    ]
    
    for x, y, Q in wells_config:
        well_system.add_well(x, y, Q)
    
    print(f"\n井群配置:")
    for i, (x, y, Q) in enumerate(wells_config, 1):
        print(f"  井{i}: 位置({x}, {y})m, 流量{Q}m³/d")
    
    # 计算中心点水头
    H_center = well_system.superposition_head(0, 0, R=180)
    s_center = aquifer.H0 - H_center
    print(f"\n中心点(0,0):")
    print(f"  水头: {H_center:.2f} m")
    print(f"  降深: {s_center:.2f} m")
    
    # 绘制干扰场
    well_system.plot_interference_field(R=180)


def example_unconfined_aquifer():
    """
    示例3：潜水井流
    """
    print("\n" + "="*60)
    print("示例3：潜水井流计算")
    print("="*60)
    
    # 创建潜水含水层
    aquifer = UnconfinedAquifer(
        k=10,      # m/d
        H0=20,     # 初始水位 20 m
        domain_size=(400, 400)
    )
    
    # 井参数
    h0 = 10    # 井内水位 10 m
    R = 120    # 影响半径
    r0 = 0.2   # 井半径
    
    # 计算井流量
    Q = aquifer.well_flow_steady(h0, R, r0)
    print(f"\n潜水井流量: Q = {Q:.2f} m³/d")
    
    # 不同距离水位
    distances = [1, 5, 10, 20, 50, 100]
    print(f"\n距井不同距离的水位:")
    for r in distances:
        h = aquifer.water_table_at_distance(Q, R, r)
        print(f"  r = {r:3d}m: h = {h:.3f} m")


# 运行所有示例
if __name__ == "__main__":
    example_confined_aquifer()
    example_well_interference()
    example_unconfined_aquifer()
```

---

## 四、数值模拟（有限差分）

### 4.1 稳态渗流方程

$$\frac{\partial^2 h}{\partial x^2} + \frac{\partial^2 h}{\partial y^2} = 0$$

### 4.2 有限差分格式

$$h_{i,j} = \frac{h_{i+1,j} + h_{i-1,j} + h_{i,j+1} + h_{i,j-1}}{4}$$

### 4.3 Python实现

```python
class FiniteDifferenceGroundwater:
    """
    有限差分地下水模拟
    """
    
    def __init__(self, nx, ny, dx, dy):
        self.nx = nx
        self.ny = ny
        self.dx = dx
        self.dy = dy
        self.h = np.zeros((ny, nx))
    
    def set_boundary(self, h_left, h_right, h_top, h_bottom):
        """
        设置边界条件
        """
        self.h[:, 0] = h_left       # 左边界
        self.h[:, -1] = h_right     # 右边界
        self.h[0, :] = h_bottom     # 下边界
        self.h[-1, :] = h_top       # 上边界
    
    def solve_laplace(self, max_iter=10000, tol=1e-6):
        """
        求解拉普拉斯方程（迭代法）
        """
        for iteration in range(max_iter):
            h_old = self.h.copy()
            
            # 内部节点更新
            for i in range(1, self.ny-1):
                for j in range(1, self.nx-1):
                    self.h[i, j] = 0.25 * (
                        self.h[i+1, j] + self.h[i-1, j] +
                        self.h[i, j+1] + self.h[i, j-1]
                    )
            
            # 收敛判断
            error = np.max(np.abs(self.h - h_old))
            if error < tol:
                print(f"收敛于第{iteration+1}次迭代，误差={error:.2e}")
                break
        
        return self.h
```

---

## 五、项目作业

### 作业1（必做）
1. 完善`UnconfinedAquifer`可视化
2. 实现4井对称布置干扰分析
3. 添加单元测试

### 作业2（选做）
使用有限差分法模拟矩形区域渗流场，含：
- 左右边界：定水头
- 上下边界：不透水
- 绘制流线和等势线

---

**项目总结**：
- 地下水渗流完整体系
- 井流公式系统实现
- 井群干扰叠加原理
- 数值模拟基础

**下一项目**：水库调度优化系统
