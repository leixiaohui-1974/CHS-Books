# 第8章：场论初步（梯度、散度、旋度）

**学习时间**: 4小时  
**难度**: ⭐⭐⭐⭐⭐  
**考试权重**: 8%

---

## 一、数量场与向量场

### 1.1 基本概念

**数量场**：每点对应一个数量
$$u = u(x, y, z)$$

例：温度场、电位

**向量场**：每点对应一个向量
$$\mathbf{F} = P(x,y,z)\mathbf{i} + Q(x,y,z)\mathbf{j} + R(x,y,z)\mathbf{k}$$

例：速度场、力场

### 1.2 方向导数

沿方向$\mathbf{l}$的方向导数：
$$\frac{\partial u}{\partial \mathbf{l}} = \frac{\partial u}{\partial x}\cos\alpha + \frac{\partial u}{\partial y}\cos\beta + \frac{\partial u}{\partial z}\cos\gamma$$

---

## 二、梯度（Gradient）

### 2.1 定义

$$\text{grad}\,u = \nabla u = \frac{\partial u}{\partial x}\mathbf{i} + \frac{\partial u}{\partial y}\mathbf{j} + \frac{\partial u}{\partial z}\mathbf{k}$$

**意义**：
- 方向：函数增长最快的方向
- 大小：最大方向导数

### 2.2 性质

1. $\nabla(u+v) = \nabla u + \nabla v$
2. $\nabla(uv) = u\nabla v + v\nabla u$
3. $\nabla(u/v) = (v\nabla u - u\nabla v)/v^2$

### 2.3 方向导数与梯度关系

$$\frac{\partial u}{\partial \mathbf{l}} = \nabla u \cdot \mathbf{e}_l$$

其中$\mathbf{e}_l$为$\mathbf{l}$方向的单位向量

---

## 三、散度（Divergence）

### 3.1 定义

$$\text{div}\,\mathbf{F} = \nabla \cdot \mathbf{F} = \frac{\partial P}{\partial x} + \frac{\partial Q}{\partial y} + \frac{\partial R}{\partial z}$$

**意义**：通量源的强度

- div$\mathbf{F} > 0$：源（发散）
- div$\mathbf{F} < 0$：汇（收敛）
- div$\mathbf{F} = 0$：无源场

### 3.2 物理意义

**流体力学**：单位体积的流量变化率

**高斯公式**：
$$\iiint_{\Omega}\text{div}\,\mathbf{F}\,dV = \oiint_{\Sigma}\mathbf{F}\cdot\mathbf{n}\,dS$$

---

## 四、旋度（Curl）

### 4.1 定义

$$\text{curl}\,\mathbf{F} = \nabla \times \mathbf{F} = \begin{vmatrix}
\mathbf{i} & \mathbf{j} & \mathbf{k} \\
\frac{\partial}{\partial x} & \frac{\partial}{\partial y} & \frac{\partial}{\partial z} \\
P & Q & R
\end{vmatrix}$$

$$= \left(\frac{\partial R}{\partial y} - \frac{\partial Q}{\partial z}\right)\mathbf{i} + \left(\frac{\partial P}{\partial z} - \frac{\partial R}{\partial x}\right)\mathbf{j} + \left(\frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y}\right)\mathbf{k}$$

**意义**：旋转强度

### 4.2 无旋场

**curl**$\mathbf{F} = 0$ ⇔ $\mathbf{F}$为**保守场**（势场）

⇔ 路径积分与路径无关

⇔ $\mathbf{F} = \nabla u$（存在势函数）

### Python实现

```python
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

class FieldTheory:
    """
    场论计算工具
    """
    
    @staticmethod
    def gradient(f, x, y, z, h=1e-5):
        """
        数值计算梯度
        
        grad u = (∂u/∂x, ∂u/∂y, ∂u/∂z)
        
        参数:
            f: 标量场函数 f(x, y, z)
            x, y, z: 点坐标
            h: 步长
        
        返回:
            梯度向量 [gx, gy, gz]
        """
        # 数值偏导数
        df_dx = (f(x+h, y, z) - f(x-h, y, z)) / (2*h)
        df_dy = (f(x, y+h, z) - f(x, y-h, z)) / (2*h)
        df_dz = (f(x, y, z+h) - f(x, y, z-h)) / (2*h)
        
        return np.array([df_dx, df_dy, df_dz])
    
    @staticmethod
    def directional_derivative(grad_u, direction):
        """
        方向导数
        
        ∂u/∂l = grad u · e_l
        
        参数:
            grad_u: 梯度向量
            direction: 方向向量
        
        返回:
            方向导数
        """
        # 归一化方向
        e_l = direction / np.linalg.norm(direction)
        
        # 点积
        dir_deriv = np.dot(grad_u, e_l)
        
        return dir_deriv
    
    @staticmethod
    def divergence(F, x, y, z, h=1e-5):
        """
        数值计算散度
        
        div F = ∂P/∂x + ∂Q/∂y + ∂R/∂z
        
        参数:
            F: 向量场函数 F(x,y,z) 返回 [P, Q, R]
            x, y, z: 点坐标
            h: 步长
        
        返回:
            散度（标量）
        """
        # F在各点的值
        F_center = F(x, y, z)
        
        F_xp = F(x+h, y, z)
        F_xm = F(x-h, y, z)
        
        F_yp = F(x, y+h, z)
        F_ym = F(x, y-h, z)
        
        F_zp = F(x, y, z+h)
        F_zm = F(x, y, z-h)
        
        # 偏导数
        dP_dx = (F_xp[0] - F_xm[0]) / (2*h)
        dQ_dy = (F_yp[1] - F_ym[1]) / (2*h)
        dR_dz = (F_zp[2] - F_zm[2]) / (2*h)
        
        div_F = dP_dx + dQ_dy + dR_dz
        
        return div_F
    
    @staticmethod
    def curl(F, x, y, z, h=1e-5):
        """
        数值计算旋度
        
        curl F = (∂R/∂y - ∂Q/∂z, ∂P/∂z - ∂R/∂x, ∂Q/∂x - ∂P/∂y)
        
        参数:
            F: 向量场函数
            x, y, z: 点坐标
            h: 步长
        
        返回:
            旋度向量 [cx, cy, cz]
        """
        F_xp = F(x+h, y, z)
        F_xm = F(x-h, y, z)
        
        F_yp = F(x, y+h, z)
        F_ym = F(x, y-h, z)
        
        F_zp = F(x, y, z+h)
        F_zm = F(x, y, z-h)
        
        # 各分量偏导数
        dP_dy = (F_yp[0] - F_ym[0]) / (2*h)
        dP_dz = (F_zp[0] - F_zm[0]) / (2*h)
        
        dQ_dx = (F_xp[1] - F_xm[1]) / (2*h)
        dQ_dz = (F_zp[1] - F_zm[1]) / (2*h)
        
        dR_dx = (F_xp[2] - F_xm[2]) / (2*h)
        dR_dy = (F_yp[2] - F_ym[2]) / (2*h)
        
        # 旋度
        curl_x = dR_dy - dQ_dz
        curl_y = dP_dz - dR_dx
        curl_z = dQ_dx - dP_dy
        
        return np.array([curl_x, curl_y, curl_z])
    
    @staticmethod
    def plot_gradient_field_2d(f, x_range=(-2, 2), y_range=(-2, 2)):
        """
        绘制二维标量场及其梯度
        """
        x = np.linspace(x_range[0], x_range[1], 100)
        y = np.linspace(y_range[0], y_range[1], 100)
        X, Y = np.meshgrid(x, y)
        
        # 计算标量场
        Z = np.zeros_like(X)
        for i in range(X.shape[0]):
            for j in range(X.shape[1]):
                Z[i, j] = f(X[i, j], Y[i, j], 0)
        
        fig, axes = plt.subplots(1, 2, figsize=(14, 6))
        
        # 标量场等高线
        contour = axes[0].contour(X, Y, Z, levels=15)
        axes[0].clabel(contour, inline=True, fontsize=8)
        axes[0].set_xlabel('x')
        axes[0].set_ylabel('y')
        axes[0].set_title('标量场')
        axes[0].grid(True, alpha=0.3)
        
        # 梯度场
        x_grad = np.linspace(x_range[0], x_range[1], 15)
        y_grad = np.linspace(y_range[0], y_range[1], 15)
        X_grad, Y_grad = np.meshgrid(x_grad, y_grad)
        
        U = np.zeros_like(X_grad)
        V = np.zeros_like(Y_grad)
        
        for i in range(X_grad.shape[0]):
            for j in range(X_grad.shape[1]):
                grad = FieldTheory.gradient(f, X_grad[i, j], Y_grad[i, j], 0)
                U[i, j] = grad[0]
                V[i, j] = grad[1]
        
        axes[1].quiver(X_grad, Y_grad, U, V, alpha=0.6)
        axes[1].contour(X, Y, Z, levels=15, alpha=0.3)
        axes[1].set_xlabel('x')
        axes[1].set_ylabel('y')
        axes[1].set_title('梯度场')
        axes[1].grid(True, alpha=0.3)
        axes[1].axis('equal')
        
        plt.tight_layout()
        plt.savefig('gradient_field.png', dpi=300, bbox_inches='tight')
        plt.show()
    
    @staticmethod
    def plot_vector_field_2d(F_2d, x_range=(-2, 2), y_range=(-2, 2)):
        """
        绘制二维向量场
        """
        x = np.linspace(x_range[0], x_range[1], 20)
        y = np.linspace(y_range[0], y_range[1], 20)
        X, Y = np.meshgrid(x, y)
        
        U = np.zeros_like(X)
        V = np.zeros_like(Y)
        
        for i in range(X.shape[0]):
            for j in range(X.shape[1]):
                F_val = F_2d(X[i, j], Y[i, j])
                U[i, j] = F_val[0]
                V[i, j] = F_val[1]
        
        plt.figure(figsize=(8, 8))
        plt.quiver(X, Y, U, V, alpha=0.7)
        plt.xlabel('x')
        plt.ylabel('y')
        plt.title('向量场')
        plt.grid(True, alpha=0.3)
        plt.axis('equal')
        plt.savefig('vector_field.png', dpi=300, bbox_inches='tight')
        plt.show()


# 示例1：梯度
print("="*60)
print("示例1：梯度计算")
print("="*60)

# 标量场 u = x² + y² + z²
def u_sphere(x, y, z):
    return x**2 + y**2 + z**2

# 计算梯度
point = (1, 2, 3)
grad_u = FieldTheory.gradient(u_sphere, *point)

print(f"标量场: u = x² + y² + z²")
print(f"点: {point}")
print(f"梯度: ∇u = {grad_u}")
print(f"理论值: ∇u = (2x, 2y, 2z) = {np.array([2*p for p in point])}")

# 方向导数
direction = np.array([1, 1, 1])
dir_deriv = FieldTheory.directional_derivative(grad_u, direction)

print(f"\n方向: {direction}")
print(f"方向导数: {dir_deriv:.6f}")
print(f"最大方向导数（梯度模）: {np.linalg.norm(grad_u):.6f}")

# 示例2：散度
print("\n" + "="*60)
print("示例2：散度计算")
print("="*60)

# 向量场 F = (x, y, z)
def F_radial(x, y, z):
    return np.array([x, y, z])

point_2 = (1, 1, 1)
div_F = FieldTheory.divergence(F_radial, *point_2)

print(f"向量场: F = (x, y, z)")
print(f"点: {point_2}")
print(f"散度: div F = {div_F:.6f}")
print(f"理论值: div F = ∂x/∂x + ∂y/∂y + ∂z/∂z = 3")

# 示例3：旋度
print("\n" + "="*60)
print("示例3：旋度计算")
print("="*60)

# 向量场 F = (-y, x, 0) (绕z轴旋转)
def F_rotation(x, y, z):
    return np.array([-y, x, 0])

point_3 = (1, 0, 0)
curl_F = FieldTheory.curl(F_rotation, *point_3)

print(f"向量场: F = (-y, x, 0)")
print(f"点: {point_3}")
print(f"旋度: curl F = {curl_F}")
print(f"理论值: curl F = (0, 0, 2)")

# 可视化
print("\n" + "="*60)
print("示例4：可视化")
print("="*60)

# 标量场及梯度
FieldTheory.plot_gradient_field_2d(u_sphere)

# 向量场
def F_2d_rotation(x, y):
    return np.array([-y, x])

FieldTheory.plot_vector_field_2d(F_2d_rotation)
```

---

## 五、典型考题

### 考题1：计算梯度

**【题目】**求$u = xyz$在点$(1,2,3)$的梯度

**【解答】**

$$\nabla u = (yz, xz, xy) = (6, 3, 2)$$

---

### 考题2：判断保守场

**【题目】**判断$\mathbf{F} = (y^2, 2xy, 0)$是否为保守场

**【解答】**

计算旋度：
$$\text{curl}\,\mathbf{F} = \left(0, 0, \frac{\partial(2xy)}{\partial x} - \frac{\partial y^2}{\partial y}\right) = (0, 0, 2y - 2y) = 0$$

**是保守场**

---

### 考题3：求势函数

**【题目】**已知$\mathbf{F} = (2xy, x^2, 0)$为保守场，求势函数$u$

**【解答】**

$$\frac{\partial u}{\partial x} = 2xy \Rightarrow u = x^2y + f(y,z)$$

$$\frac{\partial u}{\partial y} = x^2 \Rightarrow \frac{\partial f}{\partial y} = 0$$

$$\frac{\partial u}{\partial z} = 0 \Rightarrow \frac{\partial f}{\partial z} = 0$$

**势函数**：$u = x^2y + C$

---

## 六、速记口诀

> 梯度指向增长快  
> 散度描述通量变  
> 旋度反映场旋转  
> 保守场中旋度零

---

**本章重点**：
- 梯度、散度、旋度计算
- 保守场判别
- 势函数求解
- 物理意义理解

**下一章**：复变函数初步
