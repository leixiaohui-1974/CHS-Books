# 第2章：线性代数核心定理与速算技巧

**学习时间**: 6小时  
**难度**: ⭐⭐⭐⭐  
**考试权重**: 22%

---

## 一、行列式计算

### 1.1 行列式定义与性质

#### 重要性质（必背）

1. **转置性质**：$|A^T| = |A|$
2. **倍乘性质**：某行乘k，行列式乘k
3. **互换性质**：交换两行，行列式变号
4. **可加性**：某行可拆，行列式可拆
5. **倍加性质**：某行加另一行的k倍，行列式不变

#### Python实现

```python
import numpy as np
import sympy as sp

class DeterminantCalculator:
    """
    行列式计算器
    """
    
    @staticmethod
    def det_2x2(a, b, c, d):
        """
        2×2行列式
        
        |a  b|
        |c  d| = ad - bc
        """
        return a*d - b*c
    
    @staticmethod
    def det_3x3(matrix):
        """
        3×3行列式（对角线法则）
        """
        a = matrix
        det = (a[0,0]*a[1,1]*a[2,2] + 
               a[0,1]*a[1,2]*a[2,0] + 
               a[0,2]*a[1,0]*a[2,1] -
               a[0,2]*a[1,1]*a[2,0] - 
               a[0,0]*a[1,2]*a[2,1] - 
               a[0,1]*a[1,0]*a[2,2])
        return det
    
    @staticmethod
    def det_triangular(matrix):
        """
        三角行列式（主对角线元素之积）
        """
        return np.prod(np.diag(matrix))
    
    @staticmethod
    def det_by_row_reduction(matrix):
        """
        行化简求行列式
        """
        A = matrix.copy().astype(float)
        n = A.shape[0]
        det = 1
        
        for i in range(n):
            # 选主元
            if A[i,i] == 0:
                for j in range(i+1, n):
                    if A[j,i] != 0:
                        A[[i,j]] = A[[j,i]]  # 交换行
                        det *= -1
                        break
            
            if A[i,i] == 0:
                return 0  # 行列式为0
            
            # 消元
            for j in range(i+1, n):
                factor = A[j,i] / A[i,i]
                A[j] = A[j] - factor * A[i]
        
        # 上三角行列式
        det *= np.prod(np.diag(A))
        
        return det
    
    @staticmethod
    def det_special_forms():
        """
        特殊形式行列式
        """
        examples = {
            "范德蒙行列式": """
            |1   1   1   1  |
            |x1  x2  x3  x4 | = ∏(xi - xj), i>j
            |x1² x2² x3² x4²|
            |x1³ x2³ x3³ x4³|
            """,
            
            "分块行列式": """
            |A  O|
            |C  B| = |A| · |B|
            """,
            
            "行（列）和相等": """
            提取公因子，化为行列式计算
            """
        }
        return examples


# 示例
calc = DeterminantCalculator()

# 2×2行列式
det1 = calc.det_2x2(2, 3, 1, 4)
print(f"2×2行列式: {det1}")

# 3×3行列式
A3 = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 10]
])

det2 = calc.det_3x3(A3)
det2_np = np.linalg.det(A3)
print(f"\n3×3行列式:")
print(f"  对角线法: {det2:.2f}")
print(f"  NumPy验证: {det2_np:.2f}")

# 行化简法
A4 = np.array([
    [2, 1, 3, 4],
    [1, 2, 1, 2],
    [3, 1, 2, 1],
    [1, 3, 2, 3]
], dtype=float)

det3 = calc.det_by_row_reduction(A4)
det3_np = np.linalg.det(A4)
print(f"\n4×4行列式:")
print(f"  行化简法: {det3:.2f}")
print(f"  NumPy验证: {det3_np:.2f}")
```

---

## 二、矩阵运算

### 2.1 矩阵乘法

**重要性质**：
1. $(AB)^T = B^T A^T$
2. $(AB)^{-1} = B^{-1} A^{-1}$
3. $|AB| = |A| \cdot |B|$

### 2.2 矩阵的秩

**定义**：矩阵中非零子式的最高阶数

**性质**：
1. $r(AB) \leq \min\{r(A), r(B)\}$
2. $r(A+B) \leq r(A) + r(B)$
3. $r(A^T A) = r(A)$

### 2.3 Python实现

```python
class MatrixOperations:
    """
    矩阵运算工具
    """
    
    @staticmethod
    def rank_by_row_reduction(A):
        """
        行化简求秩
        """
        matrix = A.copy().astype(float)
        m, n = matrix.shape
        rank = 0
        
        for col in range(n):
            if rank >= m:
                break
            
            # 找主元
            pivot_row = None
            for row in range(rank, m):
                if abs(matrix[row, col]) > 1e-10:
                    pivot_row = row
                    break
            
            if pivot_row is None:
                continue
            
            # 交换行
            if pivot_row != rank:
                matrix[[rank, pivot_row]] = matrix[[pivot_row, rank]]
            
            # 归一化
            matrix[rank] = matrix[rank] / matrix[rank, col]
            
            # 消元
            for row in range(m):
                if row != rank and abs(matrix[row, col]) > 1e-10:
                    matrix[row] = matrix[row] - matrix[row, col] * matrix[rank]
            
            rank += 1
        
        return rank, matrix
    
    @staticmethod
    def inverse_by_adjoint(A):
        """
        伴随矩阵法求逆
        
        A^(-1) = (1/|A|) * A*
        """
        n = A.shape[0]
        det_A = np.linalg.det(A)
        
        if abs(det_A) < 1e-10:
            raise ValueError("矩阵不可逆")
        
        # 伴随矩阵（代数余子式）
        adjoint = np.zeros_like(A)
        
        for i in range(n):
            for j in range(n):
                # 去掉第i行第j列
                minor = np.delete(np.delete(A, i, axis=0), j, axis=1)
                cofactor = ((-1)**(i+j)) * np.linalg.det(minor)
                adjoint[j, i] = cofactor  # 注意转置
        
        A_inv = adjoint / det_A
        
        return A_inv
    
    @staticmethod
    def matrix_power(A, k):
        """
        矩阵的幂A^k
        """
        if k == 0:
            return np.eye(A.shape[0])
        elif k == 1:
            return A
        else:
            result = A.copy()
            for _ in range(k-1):
                result = result @ A
            return result


# 示例
ops = MatrixOperations()

# 求秩
B = np.array([
    [1, 2, 3, 4],
    [2, 4, 6, 8],
    [3, 5, 7, 9]
], dtype=float)

rank_B, B_reduced = ops.rank_by_row_reduction(B)
print(f"矩阵的秩: r(B) = {rank_B}")

# 求逆
C = np.array([
    [1, 2, 1],
    [2, 1, 1],
    [1, 1, 2]
], dtype=float)

C_inv = ops.inverse_by_adjoint(C)
C_inv_np = np.linalg.inv(C)

print(f"\n矩阵的逆:")
print("伴随矩阵法:")
print(C_inv)
print("\nNumPy验证:")
print(C_inv_np)

# 验证 C @ C_inv = I
I = C @ C_inv
print(f"\n验证 CC^(-1) = I:")
print(I)
```

---

## 三、特征值与特征向量

### 3.1 特征方程

$$|A - \lambda I| = 0$$

### 3.2 重要性质

1. $\sum \lambda_i = tr(A)$（迹）
2. $\prod \lambda_i = |A|$
3. $A^k$的特征值为$\lambda_i^k$

### 3.3 Python实现

```python
class EigenAnalysis:
    """
    特征值与特征向量分析
    """
    
    @staticmethod
    def characteristic_polynomial(A):
        """
        特征多项式（符号计算）
        """
        lam = sp.Symbol('lambda')
        n = A.shape[0]
        I = sp.eye(n)
        
        A_sym = sp.Matrix(A)
        char_poly = (A_sym - lam*I).det()
        
        return char_poly, lam
    
    @staticmethod
    def eigen_analysis(A):
        """
        完整特征值分析
        """
        # NumPy数值计算
        eigenvalues, eigenvectors = np.linalg.eig(A)
        
        # 验证
        print(f"特征值:")
        for i, lam in enumerate(eigenvalues):
            print(f"  λ_{i+1} = {lam:.4f}")
        
        print(f"\n性质验证:")
        print(f"  迹tr(A) = {np.trace(A):.4f}")
        print(f"  Σλ_i = {np.sum(eigenvalues):.4f}")
        print(f"  |A| = {np.linalg.det(A):.4f}")
        print(f"  Πλ_i = {np.prod(eigenvalues):.4f}")
        
        # 特征向量
        print(f"\n特征向量:")
        for i in range(len(eigenvalues)):
            v = eigenvectors[:, i]
            print(f"  v_{i+1} = {v}")
            
            # 验证 Av = λv
            Av = A @ v
            lam_v = eigenvalues[i] * v
            error = np.linalg.norm(Av - lam_v)
            print(f"    验证误差: {error:.2e}")
        
        return eigenvalues, eigenvectors
    
    @staticmethod
    def diagonalization(A):
        """
        矩阵对角化: A = PDP^(-1)
        """
        eigenvalues, eigenvectors = np.linalg.eig(A)
        
        P = eigenvectors
        D = np.diag(eigenvalues)
        P_inv = np.linalg.inv(P)
        
        # 验证
        A_reconstructed = P @ D @ P_inv
        
        print(f"对角化:")
        print(f"D (对角矩阵):")
        print(D)
        print(f"\n验证 A = PDP^(-1):")
        print(f"重构误差: {np.linalg.norm(A - A_reconstructed):.2e}")
        
        return P, D, P_inv


# 示例
eigen = EigenAnalysis()

# 特征值分析
D = np.array([
    [3, 1, 0],
    [0, 3, 1],
    [0, 0, 3]
], dtype=float)

eigenvalues, eigenvectors = eigen.eigen_analysis(D)

# 对角化
E = np.array([
    [1, 2],
    [2, 1]
], dtype=float)

P, D_diag, P_inv = eigen.diagonalization(E)
```

---

## 四、典型考题

### 考题1：行列式计算（15分）

**【题目】**计算：
$$\begin{vmatrix}
1 & 2 & 3 & 4 \\
2 & 3 & 4 & 5 \\
3 & 4 & 5 & 6 \\
4 & 5 & 6 & 7
\end{vmatrix}$$

**【解答】**

观察：每行元素成等差数列，行与行之间差一个常数

**方法：行变换**

$r_2 - r_1$，$r_3 - r_2$，$r_4 - r_3$：

$$\begin{vmatrix}
1 & 2 & 3 & 4 \\
1 & 1 & 1 & 1 \\
1 & 1 & 1 & 1 \\
1 & 1 & 1 & 1
\end{vmatrix}$$

第2、3、4行相同 → **行列式 = 0** ✓

---

### 考题2：求矩阵的秩（15分）

**【题目】**求矩阵秩：
$$A = \begin{pmatrix}
1 & 2 & 3 \\
2 & 4 & 6 \\
3 & 6 & 9
\end{pmatrix}$$

**【解答】**

行化简：
$$\begin{pmatrix}
1 & 2 & 3 \\
2 & 4 & 6 \\
3 & 6 & 9
\end{pmatrix}
\xrightarrow{r_2-2r_1}
\begin{pmatrix}
1 & 2 & 3 \\
0 & 0 & 0 \\
3 & 6 & 9
\end{pmatrix}
\xrightarrow{r_3-3r_1}
\begin{pmatrix}
1 & 2 & 3 \\
0 & 0 & 0 \\
0 & 0 & 0
\end{pmatrix}$$

**秩r(A) = 1** ✓

---

## 五、高频考点速查

### 5.1 行列式口诀

> 互换变号，倍乘倍变  
> 倍加不变，三角对角  
> 分块对角，上下相乘

### 5.2 矩阵秩的性质

| 性质 | 公式 |
|------|------|
| 乘法 | $r(AB) \leq \min\{r(A), r(B)\}$ |
| 加法 | $r(A+B) \leq r(A) + r(B)$ |
| 转置 | $r(A^T) = r(A)$ |
| 平方 | $r(A^T A) = r(A)$ |

---

**本章习题**: 见配套练习册  
**下一章**: 概率论核心定理
