# 第6章：多元函数微积分速解技巧

**学习时间**: 5小时  
**难度**: ⭐⭐⭐⭐  
**考试权重**: 18%

---

## 一、偏导数与全微分

### 1.1 偏导数

**定义**：
$$\frac{\partial f}{\partial x} = \lim_{\Delta x \to 0}\frac{f(x+\Delta x, y) - f(x,y)}{\Delta x}$$

**几何意义**：沿坐标轴方向的变化率

### 1.2 全微分

$$df = \frac{\partial f}{\partial x}dx + \frac{\partial f}{\partial y}dy$$

**可微条件**：偏导数连续 ⇒ 可微

### 1.3 链式法则

**情形1**：$z=f(u,v)$，$u=u(t)$，$v=v(t)$

$$\frac{dz}{dt} = \frac{\partial f}{\partial u}\frac{du}{dt} + \frac{\partial f}{\partial v}\frac{dv}{dt}$$

**情形2**：$z=f(u,v)$，$u=u(x,y)$，$v=v(x,y)$

$$\frac{\partial z}{\partial x} = \frac{\partial f}{\partial u}\frac{\partial u}{\partial x} + \frac{\partial f}{\partial v}\frac{\partial v}{\partial x}$$

---

## 二、多元函数极值

### 2.1 无条件极值

**必要条件**：
$$\frac{\partial f}{\partial x} = 0, \quad \frac{\partial f}{\partial y} = 0$$

**充分条件**（二阶判别法）：

设驻点 $(x_0, y_0)$，记：
- $A = f_{xx}(x_0, y_0)$
- $B = f_{xy}(x_0, y_0)$
- $C = f_{yy}(x_0, y_0)$

判别式：$\Delta = AC - B^2$

| $\Delta$ | $A$ | 结论 |
|---------|-----|------|
| > 0 | > 0 | 极小值 |
| > 0 | < 0 | 极大值 |
| < 0 | - | 鞍点 |
| = 0 | - | 不确定 |

### 2.2 条件极值（拉格朗日乘数法）

求 $f(x,y)$ 在约束 $\varphi(x,y)=0$ 下的极值：

构造：
$$L(x,y,\lambda) = f(x,y) + \lambda\varphi(x,y)$$

解方程组：
$$\begin{cases}
\frac{\partial L}{\partial x} = 0 \\
\frac{\partial L}{\partial y} = 0 \\
\frac{\partial L}{\partial \lambda} = 0
\end{cases}$$

### Python实现

```python
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from scipy.optimize import minimize
import sympy as sp

class MultivariateCalculus:
    """
    多元函数微积分工具
    """
    
    @staticmethod
    def partial_derivatives_symbolic(f_expr, variables):
        """
        符号偏导数
        
        参数:
            f_expr: 函数表达式（sympy）
            variables: 变量列表
        
        返回:
            偏导数字典
        """
        partials = {}
        
        for var in variables:
            partials[f'∂f/∂{var}'] = sp.diff(f_expr, var)
        
        return partials
    
    @staticmethod
    def gradient_numerical(f, x, y, h=1e-5):
        """
        数值梯度
        
        参数:
            f: 函数 f(x, y)
            x, y: 点坐标
            h: 步长
        
        返回:
            梯度 [∂f/∂x, ∂f/∂y]
        """
        df_dx = (f(x + h, y) - f(x - h, y)) / (2 * h)
        df_dy = (f(x, y + h) - f(x, y - h)) / (2 * h)
        
        return np.array([df_dx, df_dy])
    
    @staticmethod
    def find_critical_points(f_expr, variables):
        """
        查找驻点（符号计算）
        
        参数:
            f_expr: 函数表达式
            variables: 变量列表
        
        返回:
            驻点列表
        """
        # 计算偏导数
        equations = [sp.diff(f_expr, var) for var in variables]
        
        # 求解方程组
        critical_points = sp.solve(equations, variables)
        
        return critical_points
    
    @staticmethod
    def second_derivative_test(f_expr, variables, critical_point):
        """
        二阶导数判别法
        
        参数:
            f_expr: 函数表达式
            variables: [x, y]
            critical_point: 驻点 {x: val, y: val}
        
        返回:
            判别结果
        """
        x, y = variables
        
        # 二阶偏导数
        f_xx = sp.diff(f_expr, x, 2)
        f_xy = sp.diff(f_expr, x, y)
        f_yy = sp.diff(f_expr, y, 2)
        
        # 代入驻点
        A = float(f_xx.subs(critical_point))
        B = float(f_xy.subs(critical_point))
        C = float(f_yy.subs(critical_point))
        
        # 判别式
        Delta = A * C - B**2
        
        if Delta > 0:
            if A > 0:
                result = "极小值"
            else:
                result = "极大值"
        elif Delta < 0:
            result = "鞍点"
        else:
            result = "不确定"
        
        # 函数值
        f_value = float(f_expr.subs(critical_point))
        
        return {
            'A': A,
            'B': B,
            'C': C,
            'Delta': Delta,
            'result': result,
            'f_value': f_value
        }
    
    @staticmethod
    def lagrange_multiplier(f_expr, g_expr, variables):
        """
        拉格朗日乘数法
        
        参数:
            f_expr: 目标函数
            g_expr: 约束条件 g=0
            variables: 变量列表
        
        返回:
            极值点
        """
        # 拉格朗日函数
        lambda_sym = sp.Symbol('lambda')
        L = f_expr + lambda_sym * g_expr
        
        # 求解
        all_vars = variables + [lambda_sym]
        equations = [sp.diff(L, var) for var in all_vars]
        
        solutions = sp.solve(equations, all_vars)
        
        return solutions


# 示例1：偏导数
print("="*60)
print("示例1：偏导数计算")
print("="*60)

x, y = sp.symbols('x y')
f = x**2 * y + x * y**2 + x * y

print(f"函数: f(x,y) = {f}")

partials = MultivariateCalculus.partial_derivatives_symbolic(f, [x, y])

print("\n偏导数:")
for name, expr in partials.items():
    print(f"  {name} = {expr}")

# 数值验证
f_numeric = sp.lambdify((x, y), f, 'numpy')
x0, y0 = 1, 2

grad_numerical = MultivariateCalculus.gradient_numerical(f_numeric, x0, y0)
grad_symbolic = np.array([
    float(partials['∂f/∂x'].subs({x: x0, y: y0})),
    float(partials['∂f/∂y'].subs({x: x0, y: y0}))
])

print(f"\n在点({x0}, {y0})的梯度:")
print(f"  符号计算: {grad_symbolic}")
print(f"  数值计算: {grad_numerical}")

# 示例2：无条件极值
print("\n" + "="*60)
print("示例2：无条件极值")
print("="*60)

f2 = x**2 + y**2 - 2*x - 4*y + 5

print(f"函数: f(x,y) = {f2}")

# 查找驻点
critical_pts = MultivariateCalculus.find_critical_points(f2, [x, y])

print(f"\n驻点: {critical_pts}")

# 判别
if isinstance(critical_pts, dict):
    critical_pts = [critical_pts]

for i, pt in enumerate(critical_pts, 1):
    print(f"\n驻点{i}: {pt}")
    
    test_result = MultivariateCalculus.second_derivative_test(f2, [x, y], pt)
    
    print(f"  A = {test_result['A']:.2f}")
    print(f"  B = {test_result['B']:.2f}")
    print(f"  C = {test_result['C']:.2f}")
    print(f"  Δ = {test_result['Delta']:.2f}")
    print(f"  结论: {test_result['result']}")
    print(f"  函数值: {test_result['f_value']:.2f}")

# 3D可视化
x_vals = np.linspace(-2, 4, 100)
y_vals = np.linspace(-2, 6, 100)
X, Y = np.meshgrid(x_vals, y_vals)

f2_numeric = sp.lambdify((x, y), f2, 'numpy')
Z = f2_numeric(X, Y)

fig = plt.figure(figsize=(12, 5))

# 3D曲面
ax1 = fig.add_subplot(121, projection='3d')
surf = ax1.plot_surface(X, Y, Z, cmap='viridis', alpha=0.8)
ax1.set_xlabel('x')
ax1.set_ylabel('y')
ax1.set_zlabel('f(x,y)')
ax1.set_title('函数曲面')
plt.colorbar(surf, ax=ax1, shrink=0.5)

# 等高线
ax2 = fig.add_subplot(122)
contour = ax2.contour(X, Y, Z, levels=20)
ax2.clabel(contour, inline=True, fontsize=8)

# 标注驻点
for pt in critical_pts:
    x_pt = float(pt[x])
    y_pt = float(pt[y])
    ax2.plot(x_pt, y_pt, 'r*', markersize=15, label='驻点')

ax2.set_xlabel('x')
ax2.set_ylabel('y')
ax2.set_title('等高线图')
ax2.legend()
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('multivariate_extremum.png', dpi=300, bbox_inches='tight')
plt.show()

# 示例3：条件极值
print("\n" + "="*60)
print("示例3：拉格朗日乘数法")
print("="*60)

f3 = x**2 + y**2
g3 = x + y - 1

print(f"目标函数: f(x,y) = {f3}")
print(f"约束条件: g(x,y) = {g3} = 0")

solutions = MultivariateCalculus.lagrange_multiplier(f3, g3, [x, y])

print(f"\n解: {solutions}")

# 验证
if isinstance(solutions, dict):
    solutions = [solutions]

print("\n极值点:")
for i, sol in enumerate(solutions, 1):
    x_val = float(sol[x])
    y_val = float(sol[y])
    f_val = float(f3.subs(sol))
    
    print(f"  点{i}: ({x_val:.4f}, {y_val:.4f}), f = {f_val:.4f}")
```

---

## 三、二重积分

### 3.1 直角坐标

$$\iint_D f(x,y)dxdy = \int_a^b dx \int_{\varphi_1(x)}^{\varphi_2(x)} f(x,y)dy$$

**计算步骤**：
1. 画出积分区域
2. 确定积分次序
3. 确定积分限
4. 计算积分

### 3.2 极坐标变换

$$x = r\cos\theta, \quad y = r\sin\theta$$

$$dxdy = r dr d\theta$$

$$\iint_D f(x,y)dxdy = \int_{\alpha}^{\beta}d\theta\int_{r_1(\theta)}^{r_2(\theta)} f(r\cos\theta, r\sin\theta) \cdot r dr$$

**适用情形**：
- 积分区域为圆或扇形
- 被积函数含 $x^2+y^2$

### 3.3 Python实现

```python
from scipy import integrate

class DoubleIntegral:
    """
    二重积分计算
    """
    
    @staticmethod
    def rectangular(f, x_range, y_func):
        """
        直角坐标二重积分
        
        参数:
            f: 被积函数 f(x, y)
            x_range: (a, b)
            y_func: (y1(x), y2(x))
        
        返回:
            积分值
        """
        def integrand(y, x):
            return f(x, y)
        
        result, error = integrate.dblquad(
            integrand,
            x_range[0], x_range[1],
            y_func[0], y_func[1]
        )
        
        return result, error
    
    @staticmethod
    def polar(f_polar, r_range, theta_range):
        """
        极坐标二重积分
        
        参数:
            f_polar: 被积函数 f(r, θ) * r
            r_range: (r1(θ), r2(θ))
            theta_range: (α, β)
        
        返回:
            积分值
        """
        def integrand(r, theta):
            return f_polar(r, theta)
        
        result, error = integrate.dblquad(
            integrand,
            theta_range[0], theta_range[1],
            r_range[0], r_range[1]
        )
        
        return result, error


# 二重积分示例
print("\n" + "="*60)
print("示例：二重积分")
print("="*60)

# 计算 ∬_D (x²+y²)dxdy，D: x²+y²≤1

# 方法1：极坐标
def f_polar(r, theta):
    return r**2 * r  # (x²+y²) * r = r² * r

result_polar, error = DoubleIntegral.polar(
    f_polar,
    r_range=(lambda theta: 0, lambda theta: 1),
    theta_range=(0, 2*np.pi)
)

print(f"极坐标法:")
print(f"  结果: {result_polar:.6f}")
print(f"  误差: {error:.2e}")
print(f"  理论值: π/2 = {np.pi/2:.6f}")

# 方法2：直角坐标
def f_rect(x, y):
    return x**2 + y**2

result_rect, error = DoubleIntegral.rectangular(
    f_rect,
    x_range=(-1, 1),
    y_func=(lambda x: -np.sqrt(1-x**2), lambda x: np.sqrt(1-x**2))
)

print(f"\n直角坐标法:")
print(f"  结果: {result_rect:.6f}")
print(f"  误差: {error:.2e}")
```

---

## 四、典型考题

### 考题1：求偏导数

**【题目】**设 $z = e^{xy} + \ln(x+y)$，求 $\frac{\partial z}{\partial x}$，$\frac{\partial z}{\partial y}$

**【解答】**

$$\frac{\partial z}{\partial x} = ye^{xy} + \frac{1}{x+y}$$

$$\frac{\partial z}{\partial y} = xe^{xy} + \frac{1}{x+y}$$

---

### 考题2：求极值

**【题目】**求 $f(x,y) = x^3 + y^3 - 3xy$ 的极值

**【解答】**

1. **求驻点**：
   $$\begin{cases}
   f_x = 3x^2 - 3y = 0 \\
   f_y = 3y^2 - 3x = 0
   \end{cases}$$
   
   得：$(0,0)$，$(1,1)$

2. **判别**：
   - $(0,0)$：$\Delta = -9 < 0$ → **鞍点**
   - $(1,1)$：$\Delta = 27 > 0$，$A = 6 > 0$ → **极小值** $f(1,1) = -1$

---

### 考题3：条件极值

**【题目】**求 $x^2+y^2$ 在约束 $x+y=1$ 下的最小值

**【解答】**

拉格朗日函数：
$$L = x^2 + y^2 + \lambda(x+y-1)$$

解方程组：
$$\begin{cases}
2x + \lambda = 0 \\
2y + \lambda = 0 \\
x + y - 1 = 0
\end{cases}$$

得：$x = y = \frac{1}{2}$

**最小值**：$f(\frac{1}{2}, \frac{1}{2}) = \frac{1}{2}$

---

## 五、速记口诀

> 偏导把另一个当常数  
> 极值先找驻点再判别  
> 条件极值拉格朗日  
> 二重积分选好坐标系

---

**本章重点**：
- 偏导数链式法则
- 极值判别（二阶导数测试）
- 拉格朗日乘数法
- 二重积分坐标变换

**下一章**：曲线曲面积分
