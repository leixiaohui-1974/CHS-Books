# 第5章：无穷级数与傅里叶级数

**学习时间**: 4小时  
**难度**: ⭐⭐⭐⭐  
**考试权重**: 10%

---

## 一、数项级数

### 1.1 基本概念

**级数收敛定义**：
$$\sum_{n=1}^{\infty} u_n = \lim_{n\to\infty} S_n$$

其中 $S_n = u_1 + u_2 + \cdots + u_n$（部分和）

### 1.2 常用判别法

#### 正项级数

1. **比较判别法**
   若 $u_n \leq v_n$：
   - $\sum v_n$ 收敛 → $\sum u_n$ 收敛
   - $\sum u_n$ 发散 → $\sum v_n$ 发散

2. **比值判别法**（达朗贝尔）
   $$\lim_{n\to\infty}\frac{u_{n+1}}{u_n} = \rho$$
   - ρ < 1：收敛
   - ρ > 1：发散
   - ρ = 1：不确定

3. **根值判别法**（柯西）
   $$\lim_{n\to\infty}\sqrt[n]{u_n} = \rho$$
   
   判别同上

#### 交错级数（莱布尼茨判别法）

$$\sum_{n=1}^{\infty}(-1)^{n-1}u_n$$

**收敛条件**：
1. $u_n$ 单调递减
2. $\lim_{n\to\infty}u_n = 0$

### 1.3 常见级数

| 级数 | 名称 | 收敛性 |
|------|------|--------|
| $\sum \frac{1}{n}$ | 调和级数 | 发散 |
| $\sum \frac{1}{n^p}$ | p-级数 | p>1收敛 |
| $\sum \frac{1}{n!}$ | 阶乘级数 | 收敛 |
| $\sum q^n$ | 几何级数 | \|q\|<1收敛 |

---

## 二、幂级数

### 2.1 收敛半径

$$\sum_{n=0}^{\infty}a_n x^n$$

**收敛半径**：
$$R = \lim_{n\to\infty}\left|\frac{a_n}{a_{n+1}}\right|$$ 或 $$R = \frac{1}{\lim_{n\to\infty}\sqrt[n]{|a_n|}}$$

**收敛域**：$(-R, R)$（端点单独判断）

### 2.2 常用展开式

1. **指数函数**
   $$e^x = \sum_{n=0}^{\infty}\frac{x^n}{n!} = 1 + x + \frac{x^2}{2!} + \cdots$$

2. **正弦函数**
   $$\sin x = \sum_{n=0}^{\infty}\frac{(-1)^n x^{2n+1}}{(2n+1)!} = x - \frac{x^3}{3!} + \frac{x^5}{5!} - \cdots$$

3. **余弦函数**
   $$\cos x = \sum_{n=0}^{\infty}\frac{(-1)^n x^{2n}}{(2n)!} = 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \cdots$$

4. **几何级数**
   $$\frac{1}{1-x} = \sum_{n=0}^{\infty}x^n = 1 + x + x^2 + \cdots \quad (|x|<1)$$

### Python实现

```python
import numpy as np
import matplotlib.pyplot as plt
import sympy as sp

class SeriesAnalysis:
    """
    级数分析工具
    """
    
    @staticmethod
    def ratio_test(a_n_func, n_max=100):
        """
        比值判别法
        
        参数:
            a_n_func: 通项函数 a_n
            n_max: 计算到第几项
        
        返回:
            收敛性判断
        """
        n_vals = np.arange(1, n_max)
        ratios = []
        
        for n in n_vals:
            a_n = a_n_func(n)
            a_n1 = a_n_func(n + 1)
            
            if a_n != 0:
                ratio = abs(a_n1 / a_n)
                ratios.append(ratio)
        
        # 求极限
        rho = np.mean(ratios[-10:])  # 取后10项平均
        
        if rho < 1:
            result = "收敛"
        elif rho > 1:
            result = "发散"
        else:
            result = "不确定"
        
        return rho, result, ratios
    
    @staticmethod
    def power_series_radius(a_n_func, method='ratio'):
        """
        幂级数收敛半径
        
        参数:
            a_n_func: 系数a_n
            method: 'ratio'或'root'
        """
        if method == 'ratio':
            # R = lim |a_n / a_{n+1}|
            n_vals = np.arange(1, 100)
            ratios = []
            
            for n in n_vals:
                a_n = a_n_func(n)
                a_n1 = a_n_func(n + 1)
                
                if a_n1 != 0:
                    ratios.append(abs(a_n / a_n1))
            
            R = np.mean(ratios[-10:])
        
        else:  # root
            # R = 1 / lim nth_root(|a_n|)
            n_vals = np.arange(1, 100)
            roots = []
            
            for n in n_vals:
                a_n = a_n_func(n)
                roots.append(abs(a_n)**(1/n))
            
            R = 1 / np.mean(roots[-10:])
        
        return R
    
    @staticmethod
    def taylor_series(func, x0, order, x_range):
        """
        泰勒级数展开与可视化
        
        参数:
            func: 原函数（符号）
            x0: 展开中心
            order: 阶数
            x_range: 绘图范围
        """
        x = sp.Symbol('x')
        
        # 泰勒展开
        taylor_poly = func.series(x, x0, order).removeO()
        
        # 数值化
        func_num = sp.lambdify(x, func, 'numpy')
        taylor_num = sp.lambdify(x, taylor_poly, 'numpy')
        
        # 绘图
        x_vals = np.linspace(x_range[0], x_range[1], 200)
        y_func = func_num(x_vals)
        y_taylor = taylor_num(x_vals)
        
        plt.figure(figsize=(10, 6))
        plt.plot(x_vals, y_func, 'b-', linewidth=2, label='原函数')
        plt.plot(x_vals, y_taylor, 'r--', linewidth=2,
                label=f'泰勒级数（{order-1}阶）')
        plt.axvline(x0, color='gray', linestyle=':', alpha=0.5)
        plt.xlabel('x', fontsize=12)
        plt.ylabel('y', fontsize=12)
        plt.title(f'泰勒级数逼近: {func}', fontsize=14)
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.savefig('taylor_series.png', dpi=300, bbox_inches='tight')
        plt.show()
        
        return taylor_poly


# 示例1：比值判别法
print("="*60)
print("示例1：比值判别法")
print("="*60)

# 级数 Σ 1/n!
def a_n(n):
    return 1 / np.math.factorial(n)

rho, result, ratios = SeriesAnalysis.ratio_test(a_n)

print(f"级数: Σ 1/n!")
print(f"ρ = lim(a_{{n+1}}/a_n) ≈ {rho:.6f}")
print(f"判断: {result}")

# 示例2：幂级数收敛半径
print("\n" + "="*60)
print("示例2：幂级数收敛半径")
print("="*60)

# Σ x^n / n!
def a_n_exp(n):
    return 1 / np.math.factorial(n)

R = SeriesAnalysis.power_series_radius(a_n_exp)
print(f"级数: Σ x^n / n!")
print(f"收敛半径: R = {R:.2f}")
print(f"收敛域: (-∞, ∞)")

# 示例3：泰勒级数
print("\n" + "="*60)
print("示例3：泰勒级数展开")
print("="*60)

x = sp.Symbol('x')

# e^x在x=0展开
func_exp = sp.exp(x)
taylor_exp = SeriesAnalysis.taylor_series(func_exp, 0, 6, (-2, 2))
print(f"e^x 在 x=0 的泰勒展开:")
print(taylor_exp)

# sin(x)在x=0展开
func_sin = sp.sin(x)
taylor_sin = SeriesAnalysis.taylor_series(func_sin, 0, 8, (-np.pi, np.pi))
print(f"\nsin(x) 在 x=0 的泰勒展开:")
print(taylor_sin)
```

---

## 三、傅里叶级数

### 3.1 傅里叶展开

**周期函数** $f(x)$（周期$2\pi$）：

$$f(x) = \frac{a_0}{2} + \sum_{n=1}^{\infty}(a_n\cos nx + b_n\sin nx)$$

**系数公式**：
$$a_0 = \frac{1}{\pi}\int_{-\pi}^{\pi}f(x)dx$$

$$a_n = \frac{1}{\pi}\int_{-\pi}^{\pi}f(x)\cos nx\, dx$$

$$b_n = \frac{1}{\pi}\int_{-\pi}^{\pi}f(x)\sin nx\, dx$$

### 3.2 奇偶函数

**偶函数**：$b_n = 0$（只含余弦）

**奇函数**：$a_n = 0$（只含正弦）

### 3.3 Python实现

```python
class FourierSeries:
    """
    傅里叶级数分析
    """
    
    @staticmethod
    def fourier_coefficients(func, L=np.pi, n_terms=10):
        """
        计算傅里叶系数
        
        参数:
            func: 函数（可调用）
            L: 半周期
            n_terms: 项数
        
        返回:
            a0, a_n, b_n
        """
        # a0
        a0_integrand = lambda x: func(x)
        a0 = (1/L) * sp.integrate(a0_integrand, (x, -L, L))
        
        # 数值积分（更稳定）
        from scipy.integrate import quad
        
        a0, _ = quad(func, -L, L)
        a0 /= L
        
        # a_n, b_n
        a_n = []
        b_n = []
        
        for n in range(1, n_terms + 1):
            # a_n
            integrand_a = lambda x: func(x) * np.cos(n * np.pi * x / L)
            an, _ = quad(integrand_a, -L, L)
            an /= L
            a_n.append(an)
            
            # b_n
            integrand_b = lambda x: func(x) * np.sin(n * np.pi * x / L)
            bn, _ = quad(integrand_b, -L, L)
            bn /= L
            b_n.append(bn)
        
        return a0, np.array(a_n), np.array(b_n)
    
    @staticmethod
    def reconstruct(x, a0, a_n, b_n, L=np.pi):
        """
        重构傅里叶级数
        
        参数:
            x: 自变量
            a0, a_n, b_n: 傅里叶系数
            L: 半周期
        """
        result = a0 / 2
        
        for n in range(len(a_n)):
            result += a_n[n] * np.cos((n+1) * np.pi * x / L)
            result += b_n[n] * np.sin((n+1) * np.pi * x / L)
        
        return result
    
    @staticmethod
    def plot_fourier_approximation(func, L=np.pi, n_terms_list=[1, 3, 10]):
        """
        绘制傅里叶级数逼近
        """
        fig, axes = plt.subplots(1, len(n_terms_list), 
                                figsize=(15, 4))
        
        x_vals = np.linspace(-L, L, 500)
        y_func = np.array([func(x) for x in x_vals])
        
        for i, n_terms in enumerate(n_terms_list):
            a0, a_n, b_n = FourierSeries.fourier_coefficients(
                func, L, n_terms
            )
            
            y_fourier = np.array([
                FourierSeries.reconstruct(x, a0, a_n, b_n, L)
                for x in x_vals
            ])
            
            axes[i].plot(x_vals, y_func, 'b-', linewidth=2,
                        label='原函数', alpha=0.7)
            axes[i].plot(x_vals, y_fourier, 'r--', linewidth=2,
                        label=f'傅里叶级数（{n_terms}项）')
            axes[i].set_xlabel('x', fontsize=11)
            axes[i].set_ylabel('y', fontsize=11)
            axes[i].set_title(f'n={n_terms}', fontsize=12)
            axes[i].legend()
            axes[i].grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('fourier_approximation.png',
                   dpi=300, bbox_inches='tight')
        plt.show()


# 傅里叶级数示例
print("\n" + "="*60)
print("示例4：傅里叶级数")
print("="*60)

# 方波函数
def square_wave(x):
    if -np.pi < x < 0:
        return -1
    elif 0 <= x < np.pi:
        return 1
    else:
        return 0

# 矢量化
square_wave_vec = np.vectorize(square_wave)

# 傅里叶展开
FourierSeries.plot_fourier_approximation(square_wave, np.pi, [1, 5, 20])

print("方波函数的傅里叶级数:")
print("f(x) = (4/π) Σ [sin((2n-1)x) / (2n-1)]")
```

---

## 四、典型考题

### 考题1：判别级数收敛性

**【题目】**判别 $\sum_{n=1}^{\infty}\frac{1}{n(n+1)}$ 的收敛性

**【解答】**

部分分式分解：
$$\frac{1}{n(n+1)} = \frac{1}{n} - \frac{1}{n+1}$$

部分和：
$$S_n = \left(1 - \frac{1}{2}\right) + \left(\frac{1}{2} - \frac{1}{3}\right) + \cdots + \left(\frac{1}{n} - \frac{1}{n+1}\right)$$
$$= 1 - \frac{1}{n+1} \to 1$$

**收敛，和为1**

---

## 五、速记要点

| 类型 | 关键 |
|------|------|
| 正项级数 | 比值/根值判别法 |
| 交错级数 | 莱布尼茨判别法 |
| 幂级数 | 收敛半径R |
| 傅里叶 | 系数积分公式 |

---

**本章习题**: 见配套练习册  
**下一章**: 多元函数微积分
