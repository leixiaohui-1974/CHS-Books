# 第4章：渐变流水面曲线

**学习时间**: 4小时  
**考试频率**: ⭐⭐⭐⭐⭐  
**难度**: ⭐⭐⭐⭐⭐

---

## 一、渐变流基本概念

### 1.1 定义与特征

**渐变流（Gradually Varied Flow, GVF）**：流线接近平行，压强分布接近静水压强分布的非均匀流。

**特征**：
- 流线曲率半径很大
- 断面流速分布接近均匀流
- 水深沿程缓慢变化
- $\frac{dh}{dx} \ll 1$

### 1.2 基本微分方程

**能量方程**：
$$\frac{d}{dx}\left(z + h + \frac{\alpha v^2}{2g}\right) = -i_f$$

**简化形式**：
$$\frac{dh}{dx} = \frac{i_0 - i_f}{1 - Fr^2}$$

**参数说明**：
- $i_0 = -\frac{dz}{dx}$：底坡（正值为下降）
- $i_f = \frac{n^2 v^2}{R^{4/3}}$：摩阻坡度
- $Fr = \frac{v}{\sqrt{gh}}$：弗劳德数

---

## 二、水面曲线分类

### 2.1 三区分类

**根据水深与临界水深、正常水深的关系**：

**第I区**：$h > h_0$，$h > h_c$（深水区）

**第II区**：$h_c < h < h_0$或$h_0 < h < h_c$（中间区）

**第III区**：$h < h_0$，$h < h_c$（浅水区）

### 2.2 十二种水面曲线

#### (1) 缓坡（Mild, M）：$i_0 < i_c$

- **M1曲线**：$h > h_0 > h_c$，$\frac{dh}{dx} > 0$，壅水曲线
- **M2曲线**：$h_0 > h > h_c$，$\frac{dh}{dx} < 0$，降水曲线
- **M3曲线**：$h_0 > h_c > h$，$\frac{dh}{dx} < 0$，降水曲线

#### (2) 陡坡（Steep, S）：$i_0 > i_c$

- **S1曲线**：$h > h_c > h_0$，$\frac{dh}{dx} > 0$，壅水曲线
- **S2曲线**：$h_c > h > h_0$，$\frac{dh}{dx} < 0$，降水曲线
- **S3曲线**：$h_c > h_0 > h$，$\frac{dh}{dx} < 0$，降水曲线

#### (3) 临界坡（Critical, C）：$i_0 = i_c$

- **C1曲线**：$h > h_c = h_0$，$\frac{dh}{dx} > 0$
- **C3曲线**：$h < h_c = h_0$，$\frac{dh}{dx} < 0$

#### (4) 平坡（Horizontal, H）：$i_0 = 0$

- **H2曲线**：$h > h_c$，$\frac{dh}{dx} < 0$
- **H3曲线**：$h < h_c$，$\frac{dh}{dx} < 0$

#### (5) 逆坡（Adverse, A）：$i_0 < 0$

- **A2曲线**：$h > h_c$，$\frac{dh}{dx} < 0$
- **A3曲线**：$h < h_c$，$\frac{dh}{dx} < 0$

### 2.3 判断标准

$$\frac{dh}{dx} = \frac{i_0 - i_f}{1 - Fr^2}$$

**符号判断**：
- 分子：$i_0 - i_f > 0$（底坡 > 摩阻） → 有下降趋势
- 分母：$1 - Fr^2 > 0$（$Fr < 1$，缓流） → 符号同分子
- 分母：$1 - Fr^2 < 0$（$Fr > 1$，急流） → 符号反

**关键点**：
- $h = h_0$时，$i_f = i_0$，分子=0，$\frac{dh}{dx} = 0$（渐近于正常水深）
- $h = h_c$时，$Fr = 1$，分母=0，$\frac{dh}{dx} \to \infty$（渐近于临界水深）

---

## 三、水面曲线计算

### 3.1 逐段求和法（标准步长法）

**基本公式**：
$$\Delta x = \frac{\Delta E}{i_0 - \bar{i}_f}$$

**步骤**：
1. 已知起始断面水深$h_1$
2. 假设下一断面水深$h_2$
3. 计算$\Delta E = E_2 - E_1 = (h_2 + \frac{\alpha v_2^2}{2g}) - (h_1 + \frac{\alpha v_1^2}{2g})$
4. 计算平均摩阻坡度$\bar{i}_f = \frac{i_{f1} + i_{f2}}{2}$
5. 求$\Delta x = \frac{\Delta E}{i_0 - \bar{i}_f}$
6. 迭代至终点

### 3.2 试算法（变步长法）

**适用**：已知$x$，求$h$

**步骤**：
1. 假设$h_2$
2. 计算$\Delta x_{计算}$
3. 与$\Delta x_{给定}$比较
4. 调整$h_2$，重新计算
5. 迭代至收敛

### 3.3 Runge-Kutta方法

**将微分方程数值求解**：
$$\frac{dh}{dx} = f(x, h)$$

**四阶Runge-Kutta**：
$$k_1 = f(x_n, h_n)$$
$$k_2 = f(x_n + \frac{\Delta x}{2}, h_n + \frac{k_1 \Delta x}{2})$$
$$k_3 = f(x_n + \frac{\Delta x}{2}, h_n + \frac{k_2 \Delta x}{2})$$
$$k_4 = f(x_n + \Delta x, h_n + k_3 \Delta x)$$

$$h_{n+1} = h_n + \frac{\Delta x}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$

---

## 四、边界条件与控制断面

### 4.1 缓流边界条件

**下游控制**：从下游已知水深开始，向上游推算

**典型边界**：
- 闸门下游：$h = h_{下游}$
- 堰顶：$h = h_c$
- 陡坡过渡：$h = h_c$

### 4.2 急流边界条件

**上游控制**：从上游已知水深开始，向下游推算

**典型边界**：
- 闸门上游：$h = h_{上游}$
- 陡坡起点：$h = h_0$

### 4.3 控制断面

**定义**：唯一确定水深的断面

**常见控制断面**：
- 临界水深断面（宽顶堰、陡坡过渡）
- 闸门断面
- 跌水、瀑布

---

## 五、Python实现

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from scipy.optimize import fsolve

class GraduallyVariedFlow:
    """渐变流水面曲线计算"""
    
    def __init__(self, b, n, Q, i0):
        """
        参数:
            b: 矩形渠道宽度 (m)
            n: 糙率
            Q: 流量 (m³/s)
            i0: 底坡（正值为下降）
        """
        self.b = b
        self.n = n
        self.Q = Q
        self.i0 = i0
        self.g = 9.81
    
    def normal_depth(self):
        """计算正常水深（均匀流）"""
        def equation(h):
            A = self.b * h
            P = self.b + 2 * h
            R = A / P
            Q_calc = (1 / self.n) * A * R**(2/3) * np.sqrt(self.i0)
            return Q_calc - self.Q
        
        h0 = fsolve(equation, 1.0)[0]
        return h0
    
    def critical_depth(self):
        """计算临界水深"""
        # Q²/g = A³/B
        # 矩形: (bh)³/b = h³b²
        hc = (self.Q**2 / (self.g * self.b**2))**(1/3)
        return hc
    
    def velocity(self, h):
        """计算流速"""
        A = self.b * h
        v = self.Q / A
        return v
    
    def froude_number(self, h):
        """弗劳德数"""
        v = self.velocity(h)
        Fr = v / np.sqrt(self.g * h)
        return Fr
    
    def friction_slope(self, h):
        """摩阻坡度"""
        A = self.b * h
        P = self.b + 2 * h
        R = A / P
        v = self.velocity(h)
        
        if_slope = (self.n * v)**2 / R**(4/3)
        return if_slope
    
    def specific_energy(self, h):
        """单位能量"""
        v = self.velocity(h)
        E = h + v**2 / (2 * self.g)
        return E
    
    def water_surface_slope(self, h):
        """
        水面坡度 dh/dx
        
        dh/dx = (i0 - if) / (1 - Fr²)
        """
        if_val = self.friction_slope(h)
        Fr = self.froude_number(h)
        
        numerator = self.i0 - if_val
        denominator = 1 - Fr**2
        
        if abs(denominator) < 1e-6:
            return np.inf if denominator > 0 else -np.inf
        
        dh_dx = numerator / denominator
        return dh_dx
    
    def classify_profile(self, h, h0, hc):
        """
        分类水面曲线
        
        返回: 曲线类型（如'M1', 'S2'等）
        """
        # 判断坡度类型
        ic = self.critical_slope()
        
        if self.i0 > ic:
            slope_type = 'S'  # 陡坡
        elif self.i0 < ic and self.i0 > 0:
            slope_type = 'M'  # 缓坡
        elif abs(self.i0 - ic) < 1e-6:
            slope_type = 'C'  # 临界坡
        elif abs(self.i0) < 1e-6:
            slope_type = 'H'  # 平坡
        else:
            slope_type = 'A'  # 逆坡
        
        # 判断区域
        if slope_type == 'M':
            if h > h0 and h > hc:
                zone = '1'
            elif (h < h0 and h > hc):
                zone = '2'
            else:
                zone = '3'
        elif slope_type == 'S':
            if h > hc and h > h0:
                zone = '1'
            elif (h < hc and h > h0):
                zone = '2'
            else:
                zone = '3'
        else:
            zone = '1' if h > hc else '3'
        
        return slope_type + zone
    
    def critical_slope(self):
        """临界坡度"""
        hc = self.critical_depth()
        A = self.b * hc
        P = self.b + 2 * hc
        R = A / P
        
        ic = (self.n * self.Q / A)**2 / R**(4/3)
        return ic
    
    def compute_profile_standard_step(self, h_start, x_total, dx=10, direction='downstream'):
        """
        标准步长法计算水面曲线
        
        参数:
            h_start: 起始水深 (m)
            x_total: 计算总长度 (m)
            dx: 步长 (m)
            direction: 'downstream'下游推算, 'upstream'上游推算
        
        返回:
            x_values, h_values
        """
        n_steps = int(x_total / dx)
        
        x_values = [0]
        h_values = [h_start]
        
        h_current = h_start
        x_current = 0
        
        for _ in range(n_steps):
            # 当前断面
            E1 = self.specific_energy(h_current)
            if1 = self.friction_slope(h_current)
            
            # 试算下一断面水深
            dh_dx = self.water_surface_slope(h_current)
            
            if direction == 'downstream':
                h_next_guess = h_current + dh_dx * dx
            else:
                h_next_guess = h_current - dh_dx * dx
            
            # 迭代修正
            for _ in range(10):
                E2 = self.specific_energy(h_next_guess)
                if2 = self.friction_slope(h_next_guess)
                
                delta_E = E2 - E1
                if_avg = (if1 + if2) / 2
                
                dx_calc = delta_E / (self.i0 - if_avg)
                
                if abs(dx_calc - dx) < 0.01:
                    break
                
                # 调整h_next
                h_next_guess += (dx - dx_calc) * dh_dx * 0.5
            
            if direction == 'downstream':
                x_current += dx
            else:
                x_current -= dx
            
            h_current = h_next_guess
            
            x_values.append(x_current)
            h_values.append(h_current)
        
        return np.array(x_values), np.array(h_values)
    
    def compute_profile_rk4(self, h_start, x_total, n_steps=100, direction='downstream'):
        """
        Runge-Kutta 4阶方法计算水面曲线
        
        参数:
            h_start: 起始水深 (m)
            x_total: 计算总长度 (m)
            n_steps: 步数
            direction: 'downstream'下游推算, 'upstream'上游推算
        """
        dx = x_total / n_steps
        
        def dh_dx_func(x, h):
            return self.water_surface_slope(h)
        
        x_values = np.linspace(0, x_total, n_steps + 1)
        h_values = [h_start]
        
        h = h_start
        
        for i in range(n_steps):
            k1 = dh_dx_func(x_values[i], h)
            k2 = dh_dx_func(x_values[i] + dx/2, h + k1*dx/2)
            k3 = dh_dx_func(x_values[i] + dx/2, h + k2*dx/2)
            k4 = dh_dx_func(x_values[i] + dx, h + k3*dx)
            
            if direction == 'downstream':
                h = h + (dx / 6) * (k1 + 2*k2 + 2*k3 + k4)
            else:
                h = h - (dx / 6) * (k1 + 2*k2 + 2*k3 + k4)
            
            h_values.append(h)
        
        if direction == 'upstream':
            x_values = -x_values[::-1]
            h_values = h_values[::-1]
        
        return x_values, np.array(h_values)
    
    def plot_profile_classification(self):
        """绘制水面曲线分类图"""
        fig, axes = plt.subplots(2, 2, figsize=(16, 12))
        
        h0 = self.normal_depth()
        hc = self.critical_depth()
        
        # 1. 缓坡水面曲线（M型）
        ax1 = axes[0, 0]
        
        # 确保是缓坡
        ic = self.critical_slope()
        is_mild = self.i0 < ic
        
        if is_mild:
            x_range = np.linspace(0, 500, 100)
            
            # M1曲线：h > h0 > hc
            h_M1_start = h0 * 1.5
            _, h_M1 = self.compute_profile_rk4(h_M1_start, 500, 100, 'downstream')
            ax1.plot(x_range, h_M1, 'b-', linewidth=2, label='M1曲线（壅水）')
            
            # M2曲线：h0 > h > hc
            h_M2_start = (h0 + hc) / 2
            _, h_M2 = self.compute_profile_rk4(h_M2_start, 500, 100, 'downstream')
            ax1.plot(x_range, h_M2, 'g-', linewidth=2, label='M2曲线（降水）')
            
            ax1.axhline(h0, color='r', linestyle='--', linewidth=1.5, label=f'正常水深h₀={h0:.2f}m')
            ax1.axhline(hc, color='orange', linestyle='--', linewidth=1.5, label=f'临界水深hc={hc:.2f}m')
            
            ax1.set_xlabel('距离 x (m)', fontsize=11)
            ax1.set_ylabel('水深 h (m)', fontsize=11)
            ax1.set_title(f'缓坡水面曲线（M型）\ni₀={self.i0:.4f} < ic={ic:.4f}',
                         fontsize=13, fontweight='bold')
            ax1.legend()
            ax1.grid(True, alpha=0.3)
            ax1.set_ylim([0, h0 * 2])
        
        # 2. 水面坡度 vs 水深
        ax2 = axes[0, 1]
        
        h_range = np.linspace(0.1, h0 * 2, 200)
        dh_dx_values = [self.water_surface_slope(h) for h in h_range]
        
        # 限制纵坐标范围
        dh_dx_values = np.array(dh_dx_values)
        dh_dx_values = np.clip(dh_dx_values, -0.05, 0.05)
        
        ax2.plot(h_range, dh_dx_values, 'b-', linewidth=2)
        ax2.axhline(0, color='k', linewidth=0.5)
        ax2.axvline(h0, color='r', linestyle='--', label=f'h₀={h0:.2f}m')
        ax2.axvline(hc, color='orange', linestyle='--', label=f'hc={hc:.2f}m')
        
        ax2.set_xlabel('水深 h (m)', fontsize=11)
        ax2.set_ylabel('水面坡度 dh/dx', fontsize=11)
        ax2.set_title('水面坡度与水深的关系', fontsize=13, fontweight='bold')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        
        # 3. 弗劳德数 vs 水深
        ax3 = axes[1, 0]
        
        Fr_values = [self.froude_number(h) for h in h_range]
        
        ax3.plot(h_range, Fr_values, 'g-', linewidth=2)
        ax3.axhline(1, color='r', linestyle='--', linewidth=2, label='Fr=1（临界流）')
        ax3.axvline(hc, color='orange', linestyle='--', label=f'hc={hc:.2f}m')
        
        ax3.fill_between(h_range, 0, Fr_values, where=(np.array(Fr_values) > 1),
                        alpha=0.2, color='red', label='急流区（Fr>1）')
        ax3.fill_between(h_range, 0, Fr_values, where=(np.array(Fr_values) <= 1),
                        alpha=0.2, color='blue', label='缓流区（Fr<1）')
        
        ax3.set_xlabel('水深 h (m)', fontsize=11)
        ax3.set_ylabel('弗劳德数 Fr', fontsize=11)
        ax3.set_title('弗劳德数与水深的关系', fontsize=13, fontweight='bold')
        ax3.legend()
        ax3.grid(True, alpha=0.3)
        ax3.set_ylim([0, 3])
        
        # 4. 比能曲线
        ax4 = axes[1, 1]
        
        E_values = [self.specific_energy(h) for h in h_range]
        
        ax4.plot(E_values, h_range, 'b-', linewidth=2.5, label='E-h曲线')
        
        # 标注临界点
        Ec = self.specific_energy(hc)
        ax4.scatter([Ec], [hc], color='r', s=150, zorder=5, marker='*',
                   label=f'临界点（Ec={Ec:.2f}m, hc={hc:.2f}m）')
        
        # 标注正常水深
        E0 = self.specific_energy(h0)
        ax4.scatter([E0], [h0], color='g', s=100, zorder=5, marker='o',
                   label=f'正常水深（h₀={h0:.2f}m）')
        
        ax4.axhline(hc, color='orange', linestyle=':', alpha=0.5)
        ax4.axhline(h0, color='green', linestyle=':', alpha=0.5)
        
        ax4.set_xlabel('比能 E (m)', fontsize=11)
        ax4.set_ylabel('水深 h (m)', fontsize=11)
        ax4.set_title('比能曲线', fontsize=13, fontweight='bold')
        ax4.legend()
        ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('gradually_varied_flow_profiles.png', dpi=300)
        plt.show()

# 示例1：基本参数计算
print("="*60)
print("示例1：渐变流基本参数计算")
print("="*60)

b = 10  # m
n = 0.025
Q = 30  # m³/s
i0 = 0.001  # 缓坡

gvf = GraduallyVariedFlow(b, n, Q, i0)

h0 = gvf.normal_depth()
hc = gvf.critical_depth()
ic = gvf.critical_slope()

print(f"渠道参数:")
print(f"  宽度 b = {b} m")
print(f"  糙率 n = {n}")
print(f"  流量 Q = {Q} m³/s")
print(f"  底坡 i₀ = {i0}")

print(f"\n特征水深:")
print(f"  正常水深 h₀ = {h0:.3f} m")
print(f"  临界水深 hc = {hc:.3f} m")
print(f"  临界坡度 ic = {ic:.5f}")

print(f"\n坡度分类:")
if i0 > ic:
    print(f"  陡坡（i₀ > ic）: h₀ < hc")
elif i0 < ic:
    print(f"  缓坡（i₀ < ic）: h₀ > hc")
else:
    print(f"  临界坡（i₀ = ic）: h₀ = hc")

# 示例2：水面曲线计算
print("\n" + "="*60)
print("示例2：M1壅水曲线计算（标准步长法）")
print("="*60)

h_start = h0 * 1.3  # 起始水深（下游控制）
x_total = 500  # m

x_profile, h_profile = gvf.compute_profile_standard_step(h_start, x_total, dx=20, direction='upstream')

print(f"起始条件:")
print(f"  起始水深 h = {h_start:.3f} m")
print(f"  计算长度 = {x_total} m")

print(f"\n沿程水深:")
print(f"{'x(m)':<10s} {'h(m)':<10s} {'Fr':<10s} {'曲线类型':<10s}")
print("-" * 42)

for i in range(0, len(x_profile), len(x_profile)//5):
    x = x_profile[i]
    h = h_profile[i]
    Fr = gvf.froude_number(h)
    profile_type = gvf.classify_profile(h, h0, hc)
    print(f"{x:<10.1f} {h:<10.3f} {Fr:<10.3f} {profile_type:<10s}")

# 示例3：不同水深的水面坡度
print("\n" + "="*60)
print("示例3：水面坡度分析")
print("="*60)

test_depths = [0.5*hc, hc, 1.5*hc, h0, 1.5*h0]

print(f"{'水深h(m)':<12s} {'Fr':<10s} {'dh/dx':<15s} {'流态':<10s}")
print("-" * 50)

for h in test_depths:
    Fr = gvf.froude_number(h)
    dh_dx = gvf.water_surface_slope(h)
    
    if Fr < 1:
        regime = '缓流'
    elif Fr > 1:
        regime = '急流'
    else:
        regime = '临界流'
    
    print(f"{h:<12.3f} {Fr:<10.3f} {dh_dx:<15.6f} {regime:<10s}")

# 绘制水面曲线分类图
print("\n绘制渐变流水面曲线分类图...")
gvf.plot_profile_classification()
```

---

## 六、典型考题

### 【例题1】水面曲线分类（10分）

**题目**：矩形渠道，$b=8$m，$Q=20$m³/s，$i_0=0.0005$，$n=0.020$。某断面水深$h=2.5$m，判断水面曲线类型。

**【解答】**

(1) 计算正常水深$h_0$（均匀流）

(2) 计算临界水深$h_c = \sqrt[3]{\frac{Q^2}{gb^2}} = \sqrt[3]{\frac{400}{9.81 \times 64}} = 0.85$m

(3) 判断坡度类型：$h_0 > h_c$，缓坡

(4) 判断区域：$h = 2.5 > h_0$，第I区

**答**：M1曲线（缓坡壅水曲线）

---

### 【例题2】水面曲线计算（15分）

**题目**：已知下游断面水深$h_1=3.0$m，$i_0=0.001$，$Q=25$m³/s，$b=10$m，$n=0.025$。求距下游100m处水深。

**【解答】**（标准步长法，步骤略）

---

**本章重点**：
- 渐变流微分方程
- 水面曲线12种类型
- 标准步长法计算
- 边界条件与控制断面

**下一章**：非恒定流
