# 第2章：水库优化调度

**方法**: 动态规划、线性规划、智能优化  
**目标**: 多目标平衡

---

## 一、水库调度问题

### 1.1 基本方程

**连续性方程**：
$$V_{t+1} = V_t + I_t - R_t - E_t - L_t$$

- $V_t$：时段初库容
- $I_t$：入库流量
- $R_t$：出库流量
- $E_t$：蒸发损失
- $L_t$：渗漏损失

**水位-库容关系**：
$$Z_t = f(V_t)$$

通常为多项式或分段函数。

### 1.2 调度目标

**单目标**：
- 防洪：最小化洪峰、最大化滞洪
- 发电：最大化发电量
- 供水：满足用水需求

**多目标**：
$$\max F = w_1 F_1 + w_2 F_2 + \cdots + w_n F_n$$

---

## 二、动态规划法

### 2.1 基本原理

**Bellman最优性原理**：
最优策略的子策略也是最优的。

**递推方程**：
$$f_t(V_t) = \max_{R_t} [B_t(V_t, R_t) + f_{t+1}(V_{t+1})]$$

- $f_t(V_t)$：从$t$时段到终点的最大效益
- $B_t$：当前时段效益

### 2.2 求解步骤

1. **离散化**：状态、决策变量
2. **边界条件**：$f_T(V_T) = 0$或给定
3. **逆推计算**：从$t=T-1$到$t=1$
4. **正推追踪**：确定最优决策序列

### Python实现

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import linprog, minimize

class ReservoirOptimization:
    """水库优化调度"""
    
    def __init__(self, V_min, V_max, V_dead, Z_func):
        """
        参数:
            V_min: 最小库容 (万m³)
            V_max: 最大库容 (万m³)
            V_dead: 死库容 (万m³)
            Z_func: 水位-库容函数 Z=f(V)
        """
        self.V_min = V_min
        self.V_max = V_max
        self.V_dead = V_dead
        self.Z_func = Z_func
    
    def power_generation(self, Q, H, eta=0.85):
        """
        发电量计算
        
        N = 9.81 × η × Q × H (kW)
        
        参数:
            Q: 流量 (m³/s)
            H: 水头 (m)
            eta: 效率
        
        返回:
            出力 (kW)
        """
        N = 9.81 * eta * Q * H
        return N
    
    def dynamic_programming_hydropower(self, inflows, V0, n_stages=12, 
                                       n_states=20, Z_tail=100):
        """
        动态规划求解水电站优化调度
        
        参数:
            inflows: 入库流量序列 (m³/s)
            V0: 初始库容 (万m³)
            n_stages: 时段数
            n_states: 状态离散数
            Z_tail: 尾水位 (m)
        
        返回:
            最优调度方案
        """
        # 离散化库容
        V_states = np.linspace(self.V_min, self.V_max, n_states)
        
        # 初始化
        T = n_stages
        f = np.zeros((T+1, n_states))  # 效益函数
        policy = np.zeros((T, n_states), dtype=int)  # 决策
        
        # 边界条件：终期库容尽量大
        f[T, :] = V_states / self.V_max * 1000  # 奖励终期高水位
        
        # 逆推
        for t in range(T-1, -1, -1):
            I_t = inflows[t]  # m³/s
            I_t_vol = I_t * 30 * 24 * 3600 / 10000  # 转为万m³（假设月调度）
            
            for i, V_t in enumerate(V_states):
                max_benefit = -np.inf
                best_j = 0
                
                # 遍历下时段库容
                for j, V_next in enumerate(V_states):
                    # 出库量
                    R_t_vol = V_t + I_t_vol - V_next
                    
                    # 约束检查
                    if R_t_vol < 0:
                        continue
                    
                    R_t = R_t_vol * 10000 / (30 * 24 * 3600)  # m³/s
                    
                    if R_t < 0:
                        continue
                    
                    # 平均水位
                    Z_t = self.Z_func((V_t + V_next) / 2)
                    H_t = Z_t - Z_tail
                    
                    if H_t < 0:
                        continue
                    
                    # 发电量（时段电能，以万kWh为单位）
                    N_t = self.power_generation(R_t, H_t)
                    E_t = N_t * 30 * 24 / 10000  # 万kWh
                    
                    # 总效益
                    benefit = E_t + f[t+1, j]
                    
                    if benefit > max_benefit:
                        max_benefit = benefit
                        best_j = j
                
                f[t, i] = max_benefit
                policy[t, i] = best_j
        
        # 正推追踪
        V_opt = np.zeros(T+1)
        R_opt = np.zeros(T)
        E_opt = np.zeros(T)
        
        # 找初始状态
        i_current = np.argmin(np.abs(V_states - V0))
        V_opt[0] = V_states[i_current]
        
        for t in range(T):
            i_next = policy[t, i_current]
            V_opt[t+1] = V_states[i_next]
            
            I_t = inflows[t]
            I_t_vol = I_t * 30 * 24 * 3600 / 10000
            
            R_t_vol = V_opt[t] + I_t_vol - V_opt[t+1]
            R_opt[t] = R_t_vol * 10000 / (30 * 24 * 3600)
            
            Z_avg = self.Z_func((V_opt[t] + V_opt[t+1]) / 2)
            H_t = Z_avg - Z_tail
            
            N_t = self.power_generation(R_opt[t], H_t)
            E_opt[t] = N_t * 30 * 24 / 10000
        
        results = {
            'V_opt': V_opt,
            'R_opt': R_opt,
            'E_opt': E_opt,
            'E_total': E_opt.sum()
        }
        
        return results
    
    def linear_programming_water_supply(self, demands, inflows, n_periods):
        """
        线性规划求解供水调度
        
        min Σ短缺²
        s.t. 水量平衡、库容约束
        
        参数:
            demands: 需水量序列 (万m³)
            inflows: 来水量序列 (万m³)
            n_periods: 时段数
        
        返回:
            供水方案
        """
        # 决策变量：[R_1, R_2, ..., R_n, V_1, ..., V_n, D_1, ..., D_n]
        # R: 供水量, V: 库容, D: 短缺量
        
        n = n_periods
        
        # 目标函数：最小化短缺
        c = np.zeros(3 * n)
        c[2*n:3*n] = np.ones(n)  # 短缺量系数
        
        # 约束矩阵
        A_eq = []
        b_eq = []
        
        # 初始库容
        V0 = self.V_max * 0.5
        
        for t in range(n):
            # 水量平衡: V_{t+1} = V_t + I_t - R_t
            row = np.zeros(3 * n)
            
            if t == 0:
                # V_1 = V_0 + I_0 - R_0
                row[t] = 1  # R_0
                row[n + t] = -1  # V_1
                A_eq.append(row)
                b_eq.append(V0 - inflows[t])
            else:
                # V_{t+1} = V_t + I_t - R_t
                row[t] = 1  # R_t
                row[n + t - 1] = -1  # V_t
                row[n + t] = 1  # V_{t+1}
                A_eq.append(row)
                b_eq.append(-inflows[t])
            
            # 供需关系: R_t + D_t = demand_t
            row = np.zeros(3 * n)
            row[t] = 1  # R_t
            row[2*n + t] = 1  # D_t
            A_eq.append(row)
            b_eq.append(demands[t])
        
        A_eq = np.array(A_eq)
        b_eq = np.array(b_eq)
        
        # 不等式约束
        A_ub = []
        b_ub = []
        
        for t in range(n):
            # V_t <= V_max
            row = np.zeros(3 * n)
            row[n + t] = 1
            A_ub.append(row)
            b_ub.append(self.V_max)
            
            # V_t >= V_min
            row = np.zeros(3 * n)
            row[n + t] = -1
            A_ub.append(row)
            b_ub.append(-self.V_min)
        
        A_ub = np.array(A_ub)
        b_ub = np.array(b_ub)
        
        # 求解
        bounds = [(0, None)] * (3 * n)
        
        result = linprog(c, A_ub=A_ub, b_ub=b_ub, 
                        A_eq=A_eq, b_eq=b_eq, 
                        bounds=bounds, method='highs')
        
        if result.success:
            R_opt = result.x[0:n]
            V_opt = result.x[n:2*n]
            D_opt = result.x[2*n:3*n]
            
            return {
                'R': R_opt,
                'V': V_opt,
                'D': D_opt,
                'total_shortage': D_opt.sum()
            }
        else:
            return None
    
    def plot_operation_results(self, inflows, V_opt, R_opt, demands=None):
        """绘制调度结果"""
        T = len(V_opt) - 1
        months = np.arange(1, T+1)
        
        fig, axes = plt.subplots(3, 1, figsize=(12, 10))
        
        # 库容过程
        axes[0].plot(months, V_opt[:-1], 'b-o', linewidth=2, 
                    markersize=6, label='库容')
        axes[0].axhline(self.V_max, color='r', linestyle='--',
                       label='最大库容')
        axes[0].axhline(self.V_min, color='orange', linestyle='--',
                       label='最小库容')
        axes[0].set_xlabel('时段', fontsize=12)
        axes[0].set_ylabel('库容 (万m³)', fontsize=12)
        axes[0].set_title('水库库容过程', fontsize=14)
        axes[0].legend()
        axes[0].grid(True, alpha=0.3)
        
        # 来水与出库
        axes[1].bar(months - 0.2, inflows, width=0.4, 
                   label='入库', alpha=0.7)
        axes[1].bar(months + 0.2, R_opt, width=0.4,
                   label='出库', alpha=0.7)
        axes[1].set_xlabel('时段', fontsize=12)
        axes[1].set_ylabel('流量 (m³/s)', fontsize=12)
        axes[1].set_title('入库与出库流量', fontsize=14)
        axes[1].legend()
        axes[1].grid(True, alpha=0.3, axis='y')
        
        # 如果有需水量，绘制供需对比
        if demands is not None:
            axes[2].plot(months, demands, 'r-o', linewidth=2,
                        markersize=6, label='需水')
            axes[2].plot(months, R_opt, 'b-s', linewidth=2,
                        markersize=6, label='供水')
            axes[2].set_xlabel('时段', fontsize=12)
            axes[2].set_ylabel('水量 (万m³)', fontsize=12)
            axes[2].set_title('供需平衡', fontsize=14)
            axes[2].legend()
            axes[2].grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('reservoir_operation.png', dpi=300)
        plt.show()

# 示例1：水电站优化调度
print("="*60)
print("示例1：水电站发电优化调度")
print("="*60)

# 水位-库容关系（简化为线性）
def Z_func(V):
    """水位-库容关系 Z = a + b*V"""
    return 100 + 0.5 * V  # V单位：万m³

# 创建水库
reservoir = ReservoirOptimization(
    V_min=1000,   # 万m³
    V_max=5000,   # 万m³
    V_dead=500,   # 万m³
    Z_func=Z_func
)

# 入库流量（典型年，12个月）
inflows = np.array([50, 60, 80, 120, 200, 300,
                   350, 280, 180, 120, 80, 60])  # m³/s

V0 = 3000  # 初始库容

print(f"水库参数:")
print(f"  最小库容: {reservoir.V_min} 万m³")
print(f"  最大库容: {reservoir.V_max} 万m³")
print(f"  初始库容: {V0} 万m³")

print(f"\n入库流量（月均）:")
for i, Q in enumerate(inflows):
    print(f"  {i+1}月: {Q} m³/s")

# 动态规划求解
results = reservoir.dynamic_programming_hydropower(
    inflows, V0, n_stages=12, n_states=15
)

print(f"\n优化结果:")
print(f"  总发电量: {results['E_total']:.0f} 万kWh")

print(f"\n各月调度:")
print(f"{'月份':>4s} {'入库':>8s} {'库容':>8s} {'出库':>8s} {'发电':>8s}")
print("-" * 42)

for t in range(12):
    print(f"{t+1:4d} {inflows[t]:8.1f} {results['V_opt'][t]:8.0f} "
          f"{results['R_opt'][t]:8.1f} {results['E_opt'][t]:8.0f}")

# 可视化
reservoir.plot_operation_results(
    inflows, results['V_opt'], results['R_opt']
)
```

---

## 三、多水库联合调度

### 3.1 串联水库

**特点**：上游水库出库=下游水库入库

**调度原则**：
- 上游优先蓄水（水头高）
- 下游优先发电（流量大）

### 3.2 并联水库

**特点**：各水库独立入库，汇流后统一利用

**调度原则**：
- 水文补偿：丰枯互济
- 容量补偿：大库调节小库

---

## 四、不确定性分析

### 4.1 随机优化

**两阶段随机规划**：
$$\min E[C_1(x) + C_2(x, \xi)]$$

$\xi$：随机来水

### 4.2 鲁棒优化

**最坏情况优化**：
$$\min_x \max_{\xi \in U} f(x, \xi)$$

---

## 五、典型考题

### 【例题】水库调度计算

**题目**（30分）

水库，V_max=2000万m³，V_min=500万m³，初始库容V_0=1200万m³。
来水I=150万m³，需水D=180万m³。

求：
1. 能否满足需水？
2. 最优出库量
3. 期末库容

**【解答】**

(1) **可用水量**（10分）

$$Q_{可用} = V_0 - V_{min} + I = 1200 - 500 + 150 = 850 \text{ 万m}^3$$

$$Q_{可用} > D = 180 \text{ 万m}^3$$

**能满足需水**

(2) **最优出库**（10分）

目标：尽量保持高水位

$$R = D = 180 \text{ 万m}^3$$

(3) **期末库容**（10分）

$$V_1 = V_0 + I - R = 1200 + 150 - 180 = 1170 \text{ 万m}^3$$

验证：$V_{min} < V_1 < V_{max}$ ✓

---

**本章重点**：
- 动态规划原理
- 水量平衡方程
- 多目标优化
- 不确定性处理
