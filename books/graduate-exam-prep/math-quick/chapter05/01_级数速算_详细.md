# 第5章：级数速算技巧

**学习时间**: 3小时  
**考试频率**: ⭐⭐⭐⭐  
**难度**: ⭐⭐⭐⭐

---

## 一、数项级数收敛性速判

### 技巧1：正项级数比值判别法（达朗贝尔判别法）

**定理**：$\sum u_n$为正项级数，$\lim_{n\to\infty}\frac{u_{n+1}}{u_n} = \rho$

- $\rho < 1$：收敛
- $\rho > 1$：发散
- $\rho = 1$：不确定

**速算口诀**：后比前，小于1收敛

**例**：$\sum\frac{n!}{n^n}$

$$\rho = \lim_{n\to\infty}\frac{(n+1)! / (n+1)^{n+1}}{n! / n^n} = \lim_{n\to\infty}\frac{n^n}{(n+1)^n} = \lim_{n\to\infty}\frac{1}{(1+1/n)^n} = \frac{1}{e} < 1$$

收敛！

---

### 技巧2：根值判别法（柯西判别法）

**定理**：$\lim_{n\to\infty}\sqrt[n]{u_n} = \rho$

- $\rho < 1$：收敛
- $\rho > 1$：发散
- $\rho = 1$：不确定

**速算口诀**：开$n$次根，小于1收敛

**例**：$\sum\left(\frac{n}{2n+1}\right)^n$

$$\rho = \lim_{n\to\infty}\frac{n}{2n+1} = \frac{1}{2} < 1$$

收敛！

---

### 技巧3：比较判别法（放缩法）

**常用比较级数**：

| 级数 | 收敛性 |
|------|--------|
| $\sum\frac{1}{n^p}$ | $p > 1$收敛，$p \leq 1$发散 |
| $\sum\frac{1}{n\ln^p n}$ | $p > 1$收敛 |
| $\sum q^n$ | $\|q\| < 1$收敛 |

**速算技巧**：找主要项，放缩比较

**例**：$\sum\frac{1}{n^2 + n}$

$$\frac{1}{n^2 + n} < \frac{1}{n^2}, \quad \sum\frac{1}{n^2}\text{收敛}$$

故原级数收敛

---

### 技巧4：交错级数莱布尼茨判别法

**定理**：$\sum(-1)^{n-1}u_n$，若：
1. $u_n \geq u_{n+1}$（单调递减）
2. $\lim_{n\to\infty}u_n = 0$

则级数收敛

**例**：$\sum\frac{(-1)^{n-1}}{n}$

$\frac{1}{n}$单调递减，$\lim\frac{1}{n}=0$，收敛！（调和级数加交错符号）

---

### 技巧5：绝对收敛vs条件收敛

**速判**：
1. 先判$\sum|u_n|$是否收敛
2. 若收敛→绝对收敛
3. 若发散，再判$\sum u_n$是否收敛
4. 若$\sum u_n$收敛→条件收敛

---

## 二、幂级数收敛域速算

### 技巧6：收敛半径公式（背下来！）

**比值法**：
$$R = \lim_{n\to\infty}\left|\frac{a_n}{a_{n+1}}\right|$$

**根值法**：
$$R = \frac{1}{\lim_{n\to\infty}\sqrt[n]{|a_n|}}$$

**收敛域**：
1. 求$R$
2. 收敛区间$(-R, R)$
3. 检验端点$x = \pm R$

---

### 技巧7：常用幂级数（必背！）

$$e^x = \sum_{n=0}^{\infty}\frac{x^n}{n!}, \quad x \in (-\infty, +\infty)$$

$$\sin x = \sum_{n=0}^{\infty}\frac{(-1)^n x^{2n+1}}{(2n+1)!}, \quad x \in (-\infty, +\infty)$$

$$\cos x = \sum_{n=0}^{\infty}\frac{(-1)^n x^{2n}}{(2n)!}, \quad x \in (-\infty, +\infty)$$

$$\ln(1+x) = \sum_{n=1}^{\infty}\frac{(-1)^{n-1} x^n}{n}, \quad x \in (-1, 1]$$

$$\frac{1}{1-x} = \sum_{n=0}^{\infty}x^n, \quad x \in (-1, 1)$$

$$(1+x)^\alpha = 1 + \sum_{n=1}^{\infty}\frac{\alpha(\alpha-1)\cdots(\alpha-n+1)}{n!}x^n, \quad x \in (-1, 1)$$

---

### 技巧8：幂级数求和速算

**步骤**：
1. 识别标准展开式
2. 变量代换
3. 逐项积分/求导

**例**：求$\sum_{n=1}^{\infty}nx^{n-1}$

$$\frac{1}{1-x} = \sum_{n=0}^{\infty}x^n$$

两边求导：
$$\frac{1}{(1-x)^2} = \sum_{n=1}^{\infty}nx^{n-1}$$

---

### 技巧9：泰勒展开速算

**麦克劳林公式（$x_0=0$）**：

$$f(x) = \sum_{n=0}^{\infty}\frac{f^{(n)}(0)}{n!}x^n$$

**记忆技巧**：算前3-4项，观察规律

**例**：$e^{x^2}$展开

$$e^x = 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \cdots$$

代入$x^2$：
$$e^{x^2} = 1 + x^2 + \frac{x^4}{2!} + \frac{x^6}{3!} + \cdots$$

---

## 三、傅里叶级数速算

### 技巧10：傅里叶系数快速计算

**周期$2\pi$的傅里叶级数**：

$$f(x) = \frac{a_0}{2} + \sum_{n=1}^{\infty}(a_n\cos nx + b_n\sin nx)$$

**系数公式（背下来！）**：

$$a_0 = \frac{1}{\pi}\int_{-\pi}^{\pi}f(x)dx$$

$$a_n = \frac{1}{\pi}\int_{-\pi}^{\pi}f(x)\cos nx \, dx$$

$$b_n = \frac{1}{\pi}\int_{-\pi}^{\pi}f(x)\sin nx \, dx$$

---

### 技巧11：奇偶函数简化

**偶函数**（$f(-x)=f(x)$）：
- $b_n = 0$（只有余弦项）
- $a_n = \frac{2}{\pi}\int_0^{\pi}f(x)\cos nx \, dx$

**奇函数**（$f(-x)=-f(x)$）：
- $a_n = 0$（只有正弦项）
- $b_n = \frac{2}{\pi}\int_0^{\pi}f(x)\sin nx \, dx$

---

### 技巧12：典型函数展开（必背！）

**锯齿波**（$f(x) = x$，$x \in (-\pi, \pi)$）：

$$x = 2\sum_{n=1}^{\infty}\frac{(-1)^{n+1}}{n}\sin nx$$

**方波**：

$$f(x) = \begin{cases}
1, & 0 < x < \pi \\
-1, & -\pi < x < 0
\end{cases}$$

$$f(x) = \frac{4}{\pi}\sum_{n=1,3,5,\cdots}\frac{1}{n}\sin nx$$

---

## 四、Python实现

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.special import factorial

class SeriesQuick:
    """级数速算"""
    
    @staticmethod
    def convergence_test_ratio(u_func, n_max=100):
        """
        比值判别法
        
        参数:
            u_func: 通项函数 u_n
            n_max: 测试的最大n值
        
        返回:
            rho: 极限值
            converges: 是否收敛
        """
        n_vals = np.arange(10, n_max)
        ratios = []
        
        for n in n_vals:
            u_n = u_func(n)
            u_n1 = u_func(n + 1)
            
            if u_n != 0:
                ratio = u_n1 / u_n
                ratios.append(abs(ratio))
        
        rho = np.mean(ratios[-10:])  # 取后10个值的平均
        
        if rho < 1:
            converges = True
        elif rho > 1:
            converges = False
        else:
            converges = None  # 不确定
        
        return rho, converges
    
    @staticmethod
    def power_series_radius(a_func, method='ratio'):
        """
        幂级数收敛半径
        
        参数:
            a_func: 系数函数 a_n
            method: 'ratio' or 'root'
        
        返回:
            R: 收敛半径
        """
        n_vals = np.arange(1, 100)
        
        if method == 'ratio':
            ratios = []
            for n in n_vals:
                a_n = a_func(n)
                a_n1 = a_func(n + 1)
                
                if a_n1 != 0:
                    ratios.append(abs(a_n / a_n1))
            
            R = np.mean(ratios[-10:])
        
        elif method == 'root':
            roots = []
            for n in n_vals:
                a_n = a_func(n)
                root = abs(a_n)**(1/n)
                roots.append(root)
            
            lim_root = np.mean(roots[-10:])
            R = 1 / lim_root if lim_root != 0 else np.inf
        
        return R
    
    @staticmethod
    def fourier_coefficients(f, period=2*np.pi, n_terms=10):
        """
        傅里叶系数计算
        
        参数:
            f: 函数
            period: 周期（默认2π）
            n_terms: 计算的项数
        
        返回:
            a0, a_n, b_n
        """
        L = period / 2
        
        # a0
        x_vals = np.linspace(-L, L, 1000)
        a0 = np.trapz(f(x_vals), x_vals) / L
        
        # a_n, b_n
        a_n = []
        b_n = []
        
        for n in range(1, n_terms + 1):
            omega = n * np.pi / L
            
            a_n_val = np.trapz(f(x_vals) * np.cos(omega * x_vals), x_vals) / L
            b_n_val = np.trapz(f(x_vals) * np.sin(omega * x_vals), x_vals) / L
            
            a_n.append(a_n_val)
            b_n.append(b_n_val)
        
        return a0, np.array(a_n), np.array(b_n)
    
    @staticmethod
    def fourier_series_sum(x, a0, a_n, b_n, period=2*np.pi):
        """
        傅里叶级数求和
        """
        L = period / 2
        f_sum = a0 / 2
        
        for n, (an, bn) in enumerate(zip(a_n, b_n), 1):
            omega = n * np.pi / L
            f_sum += an * np.cos(omega * x) + bn * np.sin(omega * x)
        
        return f_sum
    
    @staticmethod
    def plot_series_convergence():
        """绘制级数收敛性分析"""
        fig, axes = plt.subplots(2, 2, figsize=(16, 12))
        
        # 1. 比值判别法演示
        ax1 = axes[0, 0]
        
        # 级数1：Σ n!/n^n（收敛）
        def u1(n):
            return factorial(n) / n**n
        
        n_vals = np.arange(1, 50)
        ratios1 = [u1(n+1)/u1(n) for n in n_vals[:-1]]
        
        ax1.plot(n_vals[:-1], ratios1, 'b-', linewidth=2, label='Σ n!/n^n')
        ax1.axhline(1, color='r', linestyle='--', linewidth=2, label='ρ=1（临界）')
        ax1.axhline(1/np.e, color='g', linestyle=':', linewidth=1.5,
                   label=f'极限 ρ=1/e≈{1/np.e:.3f}')
        
        ax1.set_xlabel('n', fontsize=11)
        ax1.set_ylabel('u(n+1)/u(n)', fontsize=11)
        ax1.set_title('比值判别法：收敛性分析', fontsize=13, fontweight='bold')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        ax1.set_ylim([0, 1.5])
        
        # 2. 部分和收敛演示
        ax2 = axes[0, 1]
        
        # 交错调和级数：Σ (-1)^(n-1)/n
        n_vals2 = np.arange(1, 200)
        partial_sums = np.cumsum([(-1)**(n-1)/n for n in n_vals2])
        
        ax2.plot(n_vals2, partial_sums, 'b-', linewidth=2, label='部分和 S_n')
        ax2.axhline(np.log(2), color='r', linestyle='--', linewidth=2,
                   label=f'极限 ln2≈{np.log(2):.4f}')
        
        ax2.set_xlabel('n', fontsize=11)
        ax2.set_ylabel('S_n', fontsize=11)
        ax2.set_title('交错调和级数：Σ(-1)^(n-1)/n', fontsize=13, fontweight='bold')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        
        # 3. 幂级数收敛域
        ax3 = axes[1, 0]
        
        # Σ x^n/n!（e^x展开，R=∞）
        x_vals = np.linspace(-5, 5, 200)
        n_terms_list = [5, 10, 20]
        colors = ['lightblue', 'skyblue', 'steelblue']
        
        for n_terms, color in zip(n_terms_list, colors):
            series_sum = sum(x_vals**n / factorial(n) for n in range(n_terms))
            ax3.plot(x_vals, series_sum, color=color, linewidth=2,
                    label=f'前{n_terms}项和')
        
        ax3.plot(x_vals, np.exp(x_vals), 'r--', linewidth=2.5, label='e^x（精确）')
        
        ax3.set_xlabel('x', fontsize=11)
        ax3.set_ylabel('和函数', fontsize=11)
        ax3.set_title('幂级数：e^x = Σ x^n/n!', fontsize=13, fontweight='bold')
        ax3.legend()
        ax3.grid(True, alpha=0.3)
        ax3.set_ylim([-2, 20])
        
        # 4. 傅里叶级数逼近
        ax4 = axes[1, 1]
        
        # 方波函数
        def square_wave(x):
            return np.where((x % (2*np.pi)) < np.pi, 1, -1)
        
        x_fourier = np.linspace(-2*np.pi, 2*np.pi, 1000)
        f_original = square_wave(x_fourier)
        
        ax4.plot(x_fourier, f_original, 'k-', linewidth=2, alpha=0.3, label='原函数')
        
        # 傅里叶级数（只取奇数项）
        for N in [3, 7, 15]:
            f_approx = np.zeros_like(x_fourier)
            for n in range(1, N+1, 2):
                f_approx += (4 / (np.pi * n)) * np.sin(n * x_fourier)
            
            ax4.plot(x_fourier, f_approx, linewidth=2, label=f'前{N}项')
        
        ax4.set_xlabel('x', fontsize=11)
        ax4.set_ylabel('f(x)', fontsize=11)
        ax4.set_title('傅里叶级数：方波逼近', fontsize=13, fontweight='bold')
        ax4.legend()
        ax4.grid(True, alpha=0.3)
        ax4.set_ylim([-1.5, 1.5])
        
        plt.tight_layout()
        plt.savefig('series_quick_analysis.png', dpi=300)
        plt.show()

# 示例1：比值判别法
print("="*60)
print("示例1：比值判别法速判收敛性")
print("="*60)

series_quick = SeriesQuick()

# 测试级数1：Σ n!/n^n
def u1(n):
    return float(factorial(n)) / n**n

rho1, converges1 = series_quick.convergence_test_ratio(u1)

print(f"级数1：Σ n!/n^n")
print(f"  ρ = lim(u_(n+1)/u_n) ≈ {rho1:.4f}")
print(f"  判定：{'收敛' if converges1 else '发散' if converges1 is False else '不确定'}")
print(f"  理论值：ρ = 1/e ≈ {1/np.e:.4f}")

# 测试级数2：Σ 2^n/n!
def u2(n):
    return 2**n / float(factorial(n))

rho2, converges2 = series_quick.convergence_test_ratio(u2)

print(f"\n级数2：Σ 2^n/n!")
print(f"  ρ ≈ {rho2:.4f}")
print(f"  判定：{'收敛' if converges2 else '发散' if converges2 is False else '不确定'}")

# 示例2：幂级数收敛半径
print("\n" + "="*60)
print("示例2：幂级数收敛半径速算")
print("="*60)

# 级数1：Σ x^n/n!
def a1(n):
    return 1 / float(factorial(n))

R1 = series_quick.power_series_radius(a1, method='ratio')

print(f"级数1：Σ x^n/n!")
print(f"  收敛半径 R = {R1:.2f}")
print(f"  收敛域：(-∞, +∞)")

# 级数2：Σ n*x^n
def a2(n):
    return n

R2 = series_quick.power_series_radius(a2, method='ratio')

print(f"\n级数2：Σ n·x^n")
print(f"  收敛半径 R ≈ {R2:.2f}")
print(f"  收敛域：(-1, 1)")

# 示例3：傅里叶级数
print("\n" + "="*60)
print("示例3：傅里叶级数展开")
print("="*60)

# 锯齿波 f(x) = x, x∈(-π, π)
def sawtooth(x):
    return x

a0, a_n, b_n = series_quick.fourier_coefficients(sawtooth, period=2*np.pi, n_terms=5)

print(f"函数：f(x) = x, x∈(-π, π)")
print(f"\n傅里叶系数:")
print(f"  a₀ = {a0:.6f}")

print(f"\n  n    a_n         b_n")
print("-" * 30)
for n, (an, bn) in enumerate(zip(a_n, b_n), 1):
    print(f"  {n}  {an:10.6f}  {bn:10.6f}")

print(f"\n理论值（奇函数，a_n=0）:")
print(f"  b_n = 2·(-1)^(n+1)/n")
for n in range(1, 6):
    b_theory = 2 * (-1)**(n+1) / n
    print(f"  b_{n} = {b_theory:.6f}")

# 示例4：常用级数求和
print("\n" + "="*60)
print("示例4：常用级数求和（必背公式验证）")
print("="*60)

x_test = 0.5

# e^x
e_x_series = sum(x_test**n / factorial(n) for n in range(20))
e_x_exact = np.exp(x_test)

print(f"x = {x_test}")
print(f"\n1. e^x = Σ x^n/n!")
print(f"   级数和（前20项）: {e_x_series:.8f}")
print(f"   精确值: {e_x_exact:.8f}")
print(f"   误差: {abs(e_x_series - e_x_exact):.2e}")

# sin(x)
sin_x_series = sum((-1)**n * x_test**(2*n+1) / factorial(2*n+1) for n in range(10))
sin_x_exact = np.sin(x_test)

print(f"\n2. sin(x) = Σ (-1)^n·x^(2n+1)/(2n+1)!")
print(f"   级数和（前10项）: {sin_x_series:.8f}")
print(f"   精确值: {sin_x_exact:.8f}")
print(f"   误差: {abs(sin_x_series - sin_x_exact):.2e}")

# ln(1+x)
ln_x_series = sum((-1)**(n-1) * x_test**n / n for n in range(1, 100))
ln_x_exact = np.log(1 + x_test)

print(f"\n3. ln(1+x) = Σ (-1)^(n-1)·x^n/n")
print(f"   级数和（前99项）: {ln_x_series:.8f}")
print(f"   精确值: {ln_x_exact:.8f}")
print(f"   误差: {abs(ln_x_series - ln_x_exact):.2e}")

# 绘制分析图
print("\n绘制级数收敛性分析图...")
series_quick.plot_series_convergence()
```

---

## 六、速记口诀

**收敛性判别**：
> 正项级数看比值  
> 后项比前小于1  
> 根值开方更简单  
> 放缩比较找主项

**幂级数收敛**：
> 收敛半径公式记  
> 端点检验别忘记  
> 常用展开要背熟  
> 逐项求导积分计

**傅里叶展开**：
> 周期函数傅里叶  
> 系数积分三公式  
> 奇偶对称可简化  
> 典型函数要记牢

---

**本章重点**：
- 比值/根值判别法
- 幂级数收敛半径
- 常用级数展开（必背）
- 傅里叶系数计算

**全书完成！**
