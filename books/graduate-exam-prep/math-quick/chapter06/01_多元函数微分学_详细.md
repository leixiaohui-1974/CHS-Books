# 第6章：多元函数微分学速算

**学习时间**: 4小时  
**考试频率**: ⭐⭐⭐⭐⭐  
**难度**: ⭐⭐⭐⭐

---

## 一、偏导数速算

### 1.1 基本定义

**偏导数**：固定其他变量，对某一变量求导

$$\frac{\partial f}{\partial x} = \lim_{\Delta x \to 0} \frac{f(x+\Delta x, y) - f(x,y)}{\Delta x}$$

**计算规则**：
- 对$x$求偏导：把$y$看作常数
- 对$y$求偏导：把$x$看作常数

### 1.2 典型函数偏导数

| 函数 | $\partial f/\partial x$ | $\partial f/\partial y$ |
|------|-------------------------|-------------------------|
| $f=x^2+y^2$ | $2x$ | $2y$ |
| $f=xy$ | $y$ | $x$ |
| $f=x^y$ | $yx^{y-1}$ | $x^y\ln x$ |
| $f=e^{xy}$ | $ye^{xy}$ | $xe^{xy}$ |
| $f=\ln(x^2+y^2)$ | $\frac{2x}{x^2+y^2}$ | $\frac{2y}{x^2+y^2}$ |

### 1.3 速算技巧

**技巧1：链式法则**
$$\frac{\partial f}{\partial x} = \frac{\partial f}{\partial u}\frac{\partial u}{\partial x} + \frac{\partial f}{\partial v}\frac{\partial v}{\partial x}$$

**例题1**：$f = \sin(x^2+y^2)$，求$\partial f/\partial x$

**解**：
令$u = x^2+y^2$，则$f = \sin u$

$$\frac{\partial f}{\partial x} = \cos u \cdot 2x = 2x\cos(x^2+y^2)$$

---

**技巧2：隐函数求导**

**例题2**：$x^2+y^2+z^2=1$，求$\partial z/\partial x$

**解**：
两边对$x$求偏导（$y$为常数）：
$$2x + 0 + 2z\frac{\partial z}{\partial x} = 0$$

$$\frac{\partial z}{\partial x} = -\frac{x}{z}$$

---

## 二、全微分速算

### 2.1 全微分定义

$$\mathrm{d}f = \frac{\partial f}{\partial x}\mathrm{d}x + \frac{\partial f}{\partial y}\mathrm{d}y$$

**可微条件**：偏导数连续$\Rightarrow$可微

### 2.2 近似计算

$$f(x_0+\Delta x, y_0+\Delta y) \approx f(x_0,y_0) + f_x\Delta x + f_y\Delta y$$

**例题3**：计算$\sqrt{(2.02)^2+(2.97)^2}$

**解**：
令$f(x,y) = \sqrt{x^2+y^2}$，$(x_0,y_0)=(2,3)$

$$f_x = \frac{x}{\sqrt{x^2+y^2}}, \quad f_y = \frac{y}{\sqrt{x^2+y^2}}$$

在$(2,3)$处：$f(2,3)=\sqrt{13}$

$$f_x(2,3)=\frac{2}{\sqrt{13}}, \quad f_y(2,3)=\frac{3}{\sqrt{13}}$$

$$f(2.02,2.97) \approx \sqrt{13} + \frac{2}{\sqrt{13}}(0.02) + \frac{3}{\sqrt{13}}(-0.03)$$
$$= \sqrt{13} + \frac{0.04-0.09}{\sqrt{13}} = \sqrt{13} - \frac{0.05}{\sqrt{13}} \approx 3.606 - 0.014 = 3.592$$

---

## 三、方向导数与梯度

### 3.1 方向导数

**定义**：函数在某点沿方向$\vec{l}=(\cos\alpha, \cos\beta)$的变化率

$$\frac{\partial f}{\partial \vec{l}} = f_x\cos\alpha + f_y\cos\beta$$

**最大方向导数**：沿梯度方向

### 3.2 梯度

**定义**：
$$\nabla f = \left(\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}\right)$$

**性质**：
- 梯度方向：函数增长最快的方向
- 梯度模：最大方向导数的值
- 梯度⊥等值线

**例题4**：$f(x,y)=x^2+y^2$在$(1,2)$处沿$(3,4)$方向的方向导数

**解**：
1. 求梯度：$\nabla f = (2x, 2y)$，在$(1,2)$处$\nabla f(1,2)=(2,4)$

2. 单位方向向量：$\vec{l}=\frac{(3,4)}{5}=(\frac{3}{5}, \frac{4}{5})$

3. 方向导数：
$$\frac{\partial f}{\partial \vec{l}} = 2 \cdot \frac{3}{5} + 4 \cdot \frac{4}{5} = \frac{6+16}{5} = \frac{22}{5}$$

---

## 四、多元函数极值

### 4.1 无条件极值

**必要条件**：$f_x=0, f_y=0$

**充分条件**（二阶导数判别）：

令$A=f_{xx}, B=f_{xy}, C=f_{yy}$，$\Delta=AC-B^2$

| 条件 | 结论 |
|------|------|
| $\Delta>0, A>0$ | 极小值 |
| $\Delta>0, A<0$ | 极大值 |
| $\Delta<0$ | 鞍点 |
| $\Delta=0$ | 不确定 |

**例题5**：求$f(x,y)=x^3+y^3-3xy$的极值

**解**：
1. 求驻点：
$$f_x = 3x^2-3y=0 \Rightarrow x^2=y$$
$$f_y = 3y^2-3x=0 \Rightarrow y^2=x$$

联立：$x^4=x \Rightarrow x(x^3-1)=0$

$x=0$或$x=1$，对应$(0,0)$和$(1,1)$

2. 判别：
$$A=6x, \quad B=-3, \quad C=6y$$

在$(0,0)$：$\Delta=0-9=-9<0$，鞍点

在$(1,1)$：$\Delta=6\times 6-9=27>0, A=6>0$，极小值

$f(1,1)=-1$

---

### 4.2 条件极值（拉格朗日乘数法）

**问题**：求$f(x,y)$在约束$g(x,y)=0$下的极值

**方法**：构造拉格朗日函数
$$L(x,y,\lambda) = f(x,y) + \lambda g(x,y)$$

求解方程组：
$$\begin{cases}
L_x = f_x + \lambda g_x = 0 \\
L_y = f_y + \lambda g_y = 0 \\
L_\lambda = g(x,y) = 0
\end{cases}$$

**例题6**：求$f(x,y)=xy$在$x^2+y^2=1$上的最大最小值

**解**：
$$L = xy + \lambda(x^2+y^2-1)$$

$$L_x = y + 2\lambda x = 0 \quad (1)$$
$$L_y = x + 2\lambda y = 0 \quad (2)$$
$$x^2+y^2=1 \quad (3)$$

由(1)(2)：$x \cdot (1) - y \cdot (2)$得
$$xy + 2\lambda x^2 - xy - 2\lambda y^2 = 0$$
$$2\lambda(x^2-y^2)=0$$

**情况1**：$\lambda=0$
由(1)(2)得$x=y=0$，不满足(3)

**情况2**：$x^2=y^2$
$x=\pm y$，代入(3)：$2x^2=1$，$x=\pm\frac{\sqrt{2}}{2}$

驻点：$(\frac{\sqrt{2}}{2}, \frac{\sqrt{2}}{2})$，$f=\frac{1}{2}$（最大值）
      $(\frac{\sqrt{2}}{2}, -\frac{\sqrt{2}}{2})$，$f=-\frac{1}{2}$（最小值）

---

## 五、Python实现

```python
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from scipy.optimize import minimize

class MultivariableCalculus:
    """多元函数微分学工具类"""
    
    @staticmethod
    def numerical_partial(f, x0, y0, var='x', h=1e-6):
        """
        数值计算偏导数
        
        参数:
            f: 函数，接受(x,y)返回标量
            x0, y0: 计算点
            var: 'x'或'y'
            h: 步长
        """
        if var == 'x':
            return (f(x0+h, y0) - f(x0-h, y0)) / (2*h)
        else:
            return (f(x0, y0+h) - f(x0, y0-h)) / (2*h)
    
    @staticmethod
    def gradient(f, x0, y0, h=1e-6):
        """计算梯度"""
        fx = MultivariableCalculus.numerical_partial(f, x0, y0, 'x', h)
        fy = MultivariableCalculus.numerical_partial(f, x0, y0, 'y', h)
        return np.array([fx, fy])
    
    @staticmethod
    def directional_derivative(f, x0, y0, direction, h=1e-6):
        """
        方向导数
        
        参数:
            direction: 方向向量，自动归一化
        """
        grad = MultivariableCalculus.gradient(f, x0, y0, h)
        
        # 归一化方向向量
        direction = np.array(direction)
        direction = direction / np.linalg.norm(direction)
        
        return np.dot(grad, direction)
    
    @staticmethod
    def find_critical_points(f, x_range, y_range, tol=1e-4):
        """
        寻找驻点
        
        参数:
            f: 函数
            x_range, y_range: 搜索范围(min, max)
            tol: 容差
        """
        critical_points = []
        
        # 网格搜索初值
        x_init = np.linspace(x_range[0], x_range[1], 5)
        y_init = np.linspace(y_range[0], y_range[1], 5)
        
        for x0 in x_init:
            for y0 in y_init:
                # 使用minimize寻找驻点
                result = minimize(f, [x0, y0], method='BFGS')
                
                if result.success:
                    point = result.x
                    
                    # 检查是否已存在
                    is_duplicate = False
                    for p in critical_points:
                        if np.linalg.norm(point - p) < tol:
                            is_duplicate = True
                            break
                    
                    if not is_duplicate:
                        critical_points.append(point)
        
        return critical_points
    
    @staticmethod
    def classify_critical_point(f, x0, y0, h=1e-4):
        """
        判别驻点类型
        
        返回: 'minimum', 'maximum', 'saddle', 'uncertain'
        """
        # 计算二阶偏导数
        fxx = (f(x0+h, y0) - 2*f(x0, y0) + f(x0-h, y0)) / h**2
        fyy = (f(x0, y0+h) - 2*f(x0, y0) + f(x0, y0-h)) / h**2
        fxy = (f(x0+h, y0+h) - f(x0+h, y0-h) - f(x0-h, y0+h) + f(x0-h, y0-h)) / (4*h**2)
        
        A, B, C = fxx, fxy, fyy
        Delta = A*C - B**2
        
        if Delta > 1e-10:
            if A > 0:
                return 'minimum'
            else:
                return 'maximum'
        elif Delta < -1e-10:
            return 'saddle'
        else:
            return 'uncertain'
    
    @staticmethod
    def plot_function_and_gradient(f, x_range, y_range):
        """
        绘制函数曲面和梯度场
        """
        fig = plt.figure(figsize=(16, 6))
        
        x = np.linspace(x_range[0], x_range[1], 100)
        y = np.linspace(y_range[0], y_range[1], 100)
        X, Y = np.meshgrid(x, y)
        Z = np.zeros_like(X)
        
        for i in range(X.shape[0]):
            for j in range(X.shape[1]):
                Z[i,j] = f(X[i,j], Y[i,j])
        
        # 3D曲面
        ax1 = fig.add_subplot(131, projection='3d')
        surf = ax1.plot_surface(X, Y, Z, cmap='viridis', alpha=0.8)
        ax1.set_xlabel('x')
        ax1.set_ylabel('y')
        ax1.set_zlabel('f(x,y)')
        ax1.set_title('函数曲面', fontweight='bold')
        fig.colorbar(surf, ax=ax1, shrink=0.5)
        
        # 等值线
        ax2 = fig.add_subplot(132)
        contour = ax2.contour(X, Y, Z, levels=15, cmap='viridis')
        ax2.clabel(contour, inline=True, fontsize=8)
        ax2.set_xlabel('x')
        ax2.set_ylabel('y')
        ax2.set_title('等值线', fontweight='bold')
        ax2.grid(True, alpha=0.3)
        
        # 梯度场
        ax3 = fig.add_subplot(133)
        
        x_grad = np.linspace(x_range[0], x_range[1], 15)
        y_grad = np.linspace(y_range[0], y_range[1], 15)
        X_grad, Y_grad = np.meshgrid(x_grad, y_grad)
        
        U = np.zeros_like(X_grad)
        V = np.zeros_like(Y_grad)
        
        for i in range(X_grad.shape[0]):
            for j in range(X_grad.shape[1]):
                grad = MultivariableCalculus.gradient(
                    f, X_grad[i,j], Y_grad[i,j])
                U[i,j] = grad[0]
                V[i,j] = grad[1]
        
        # 归一化箭头长度
        M = np.sqrt(U**2 + V**2)
        M[M==0] = 1
        U_norm = U / M
        V_norm = V / M
        
        ax3.quiver(X_grad, Y_grad, U_norm, V_norm, M, cmap='hot')
        ax3.contour(X, Y, Z, levels=15, alpha=0.3, colors='gray')
        ax3.set_xlabel('x')
        ax3.set_ylabel('y')
        ax3.set_title('梯度场（箭头指向增长最快方向）', fontweight='bold')
        ax3.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('multivariable_calculus.png', dpi=300)
        plt.show()

# 示例使用
print("="*60)
print("多元函数微分学计算器")
print("="*60)

mc = MultivariableCalculus()

# 定义函数
def f1(x, y):
    return x**2 + y**2

def f2(x, y):
    return x**3 + y**3 - 3*x*y

# 计算偏导数
print("\n示例1：f(x,y) = x² + y²")
x0, y0 = 1, 2
fx = mc.numerical_partial(f1, x0, y0, 'x')
fy = mc.numerical_partial(f1, x0, y0, 'y')
print(f"  在点({x0}, {y0})处：")
print(f"  ∂f/∂x = {fx:.6f}")
print(f"  ∂f/∂y = {fy:.6f}")

# 计算梯度
grad = mc.gradient(f1, x0, y0)
print(f"  梯度 ∇f = [{grad[0]:.6f}, {grad[1]:.6f}]")
print(f"  梯度模 |∇f| = {np.linalg.norm(grad):.6f}")

# 方向导数
direction = [3, 4]
df_dl = mc.directional_derivative(f1, x0, y0, direction)
print(f"  沿方向{direction}的方向导数 = {df_dl:.6f}")

# 寻找驻点
print("\n示例2：f(x,y) = x³ + y³ - 3xy")
critical_points = mc.find_critical_points(lambda p: f2(p[0], p[1]),
                                         (-2, 2), (-2, 2))
print(f"  驻点：")
for point in critical_points:
    x, y = point
    point_type = mc.classify_critical_point(f2, x, y)
    f_value = f2(x, y)
    print(f"    ({x:.4f}, {y:.4f}): {point_type}, f = {f_value:.4f}")

# 可视化
print("\n绘制函数曲面和梯度场...")
mc.plot_function_and_gradient(f2, (-2, 2), (-2, 2))
```

---

## 六、典型例题

### 例题7：全微分方程

**题**：验证$\mathrm{d}u = 2xy\mathrm{d}x + x^2\mathrm{d}y$是某个二元函数的全微分，并求该函数。

**解**：
设$P=2xy, Q=x^2$

检验：$\frac{\partial P}{\partial y}=2x, \frac{\partial Q}{\partial x}=2x$

$\frac{\partial P}{\partial y}=\frac{\partial Q}{\partial x}$，是全微分✓

求原函数：
$$u = \int P\mathrm{d}x = \int 2xy\mathrm{d}x = x^2y + \varphi(y)$$

代入$\frac{\partial u}{\partial y}=Q$：
$$x^2 + \varphi'(y) = x^2 \Rightarrow \varphi'(y)=0$$

$$\varphi(y)=C$$

$$u = x^2y + C$$

---

### 例题8：最值应用

**题**：用12m的篱笆围一个矩形场地，一边靠墙，求最大面积。

**解**：
设长$x$，宽$y$，约束$x+2y=12$

面积$S=xy$

拉格朗日函数：$L=xy+\lambda(x+2y-12)$

$$L_x=y+\lambda=0$$
$$L_y=x+2\lambda=0$$

解得：$x=6, y=3$

$S_{max}=18 \text{ m}^2$

---

**本章重点**：
- 偏导数计算规则
- 全微分与近似计算
- 梯度与方向导数
- 无条件极值判别
- 拉格朗日乘数法

**下一章**：重积分计算
