# 第9章：水利枢纽优化设计

**学习时间**: 5小时  
**考试频率**: ⭐⭐⭐⭐  
**难度**: ⭐⭐⭐⭐⭐

---

## 一、坝址选择与比选

### 1.1 坝址选择原则

**地质条件**：
- 基岩完整性
- 断层、破碎带分布
- 岩石抗压强度
- 渗透性

**地形条件**：
- 河谷形态（V型、U型）
- 河床宽度
- 坝肩条件
- 库容曲线

**水文条件**：
- 设计洪水
- 泥沙淤积
- 回水影响
- 水库调节性能

**工程条件**：
- 施工条件
- 材料来源
- 交通运输
- 征地移民

---

### 1.2 坝址比选方法

**技术指标**：
- 单位库容投资（元/m³）
- 坝高（m）
- 坝长（m）
- 地质条件等级

**经济指标**：
- 总投资（亿元）
- 单位电价（元/kW·h）
- 内部收益率（IRR）
- 静态回收期

**综合评价方法**：

#### (1) 层次分析法（AHP）

**步骤**：
1. 建立层次结构
2. 构造判断矩阵
3. 计算权重向量
4. 一致性检验
5. 综合评分

**判断矩阵**（A vs B）：

| 重要程度 | 标度 |
|---------|------|
| 同等重要 | 1 |
| 稍微重要 | 3 |
| 明显重要 | 5 |
| 强烈重要 | 7 |
| 极端重要 | 9 |

**一致性指标**：
$$
CI = \frac{\lambda_{\max} - n}{n - 1}
$$

**一致性比率**：
$$
CR = \frac{CI}{RI} < 0.10
$$

其中 $RI$ 是随机一致性指标（查表）

#### (2) 模糊综合评价

**评价矩阵**：
$$
R = [r_{ij}]_{m \times n}
$$

其中 $r_{ij}$ 是第 $i$ 个指标对第 $j$ 级评语的隶属度

**综合评价向量**：
$$
\mathbf{B} = \mathbf{W} \circ R = [b_1, b_2, \ldots, b_n]
$$

其中 $\mathbf{W}$ 是权重向量，$\circ$ 是模糊合成运算

---

## 二、坝型选择

### 2.1 坝型分类

**重力坝**：
- 混凝土重力坝
- 碾压混凝土（RCC）重力坝

**拱坝**：
- 单曲拱坝
- 双曲拱坝

**土石坝**：
- 均质土坝
- 心墙坝
- 斜墙坝
- 面板坝

---

### 2.2 坝型选择因素

| 因素 | 重力坝 | 拱坝 | 土石坝 |
|------|--------|------|--------|
| **地质条件** | 中等基岩即可 | 要求坚硬完整基岩 | 对地基要求低 |
| **河谷形状** | 任何河谷 | 窄河谷（L/H<5） | 任何河谷 |
| **坝高** | ≤300m | ≤305m（锦屏） | ≤300m（努列克） |
| **施工条件** | 混凝土量大 | 混凝土量小 | 就地取材 |
| **工期** | 较长 | 较长 | 较短 |
| **造价** | 较高 | 中等 | 较低 |

---

### 2.3 坝型选择决策模型

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import eig


class DamTypeSelection:
    """坝型选择决策系统"""
    
    def __init__(self):
        self.criteria = ['地质条件', '河谷形状', '坝高', '施工条件', 
                        '工期', '造价', '安全性']
        self.dam_types = ['重力坝', '拱坝', '土石坝']
    
    def ahp_analysis(self, judgment_matrix):
        """
        层次分析法（AHP）
        
        参数:
            judgment_matrix: 判断矩阵 (n x n)
        
        返回:
            weights: 权重向量
            CR: 一致性比率
        """
        n = judgment_matrix.shape[0]
        
        # 计算最大特征值和特征向量
        eigenvalues, eigenvectors = eig(judgment_matrix)
        
        # 找到最大特征值
        lambda_max_idx = np.argmax(eigenvalues.real)
        lambda_max = eigenvalues[lambda_max_idx].real
        
        # 对应的特征向量（归一化为权重）
        w = eigenvectors[:, lambda_max_idx].real
        weights = w / w.sum()
        
        # 一致性检验
        CI = (lambda_max - n) / (n - 1)
        
        # 随机一致性指标RI（查表）
        RI_table = {1: 0, 2: 0, 3: 0.58, 4: 0.90, 5: 1.12, 6: 1.24, 
                    7: 1.32, 8: 1.41, 9: 1.45, 10: 1.49}
        RI = RI_table.get(n, 1.49)
        
        CR = CI / RI if RI > 0 else 0
        
        return weights, CR
    
    def comprehensive_evaluation(self, criteria_weights, dam_scores):
        """
        综合评价
        
        参数:
            criteria_weights: 准则层权重 (n_criteria,)
            dam_scores: 各坝型各准则得分 (n_dams, n_criteria)
        
        返回:
            scores: 综合得分
        """
        scores = dam_scores @ criteria_weights
        
        return scores
    
    def fuzzy_evaluation(self, criteria_weights, membership_matrix):
        """
        模糊综合评价
        
        参数:
            criteria_weights: 准则权重
            membership_matrix: 隶属度矩阵 (n_criteria, n_grades)
        
        返回:
            evaluation_vector: 综合评价向量
        """
        evaluation_vector = criteria_weights @ membership_matrix
        
        return evaluation_vector
    
    def topsis_method(self, decision_matrix, weights, cost_criteria=[]):
        """
        TOPSIS法（逼近理想解排序法）
        
        参数:
            decision_matrix: 决策矩阵 (n_alternatives, n_criteria)
            weights: 准则权重
            cost_criteria: 成本型指标索引列表
        
        返回:
            scores: 综合得分
            ranking: 排名
        """
        n_alt, n_cri = decision_matrix.shape
        
        # 归一化
        normalized = decision_matrix / np.sqrt((decision_matrix**2).sum(axis=0))
        
        # 加权
        weighted = normalized * weights
        
        # 理想解和负理想解
        ideal_positive = np.zeros(n_cri)
        ideal_negative = np.zeros(n_cri)
        
        for j in range(n_cri):
            if j in cost_criteria:
                # 成本型（越小越好）
                ideal_positive[j] = weighted[:, j].min()
                ideal_negative[j] = weighted[:, j].max()
            else:
                # 效益型（越大越好）
                ideal_positive[j] = weighted[:, j].max()
                ideal_negative[j] = weighted[:, j].min()
        
        # 计算距离
        D_positive = np.sqrt(((weighted - ideal_positive)**2).sum(axis=1))
        D_negative = np.sqrt(((weighted - ideal_negative)**2).sum(axis=1))
        
        # 相对贴近度
        scores = D_negative / (D_positive + D_negative)
        
        # 排名
        ranking = np.argsort(-scores) + 1
        
        return scores, ranking


# 示例应用
print("="*60)
print("坝型选择决策分析")
print("="*60)

dts = DamTypeSelection()

# 1. AHP分析
print("\n1. 层次分析法（AHP）- 准则层权重计算")

# 准则层判断矩阵（7个准则）
judgment_matrix = np.array([
    [1,   2,   1,   3,   2,   2,   1],  # 地质条件
    [1/2, 1,   1/2, 2,   1,   1,   1/2],  # 河谷形状
    [1,   2,   1,   2,   1,   1,   1/2],  # 坝高
    [1/3, 1/2, 1/2, 1,   1/2, 1/2, 1/3],  # 施工条件
    [1/2, 1,   1,   2,   1,   1,   1/2],  # 工期
    [1/2, 1,   1,   2,   1,   1,   1/2],  # 造价
    [1,   2,   2,   3,   2,   2,   1]   # 安全性
])

weights, CR = dts.ahp_analysis(judgment_matrix)

print(f"\n准则权重：")
for i, criterion in enumerate(dts.criteria):
    print(f"  {criterion}: {weights[i]:.4f}")

print(f"\n一致性比率 CR = {CR:.4f}", end="")
if CR < 0.10:
    print(" (通过一致性检验)")
else:
    print(" (未通过，需调整判断矩阵)")

# 2. 综合评价
print("\n" + "="*60)
print("2. 综合评价 - 三种坝型评分")

# 各坝型各准则得分（0-100分）
dam_scores = np.array([
    [80, 85, 70, 60, 65, 55, 85],  # 重力坝
    [90, 60, 65, 70, 60, 70, 80],  # 拱坝
    [60, 90, 80, 85, 90, 90, 70]   # 土石坝
])

comprehensive_scores = dts.comprehensive_evaluation(weights, dam_scores)

print("\n综合得分：")
for i, dam_type in enumerate(dts.dam_types):
    print(f"  {dam_type}: {comprehensive_scores[i]:.2f}")

best_idx = np.argmax(comprehensive_scores)
print(f"\n推荐坝型：{dts.dam_types[best_idx]}")

# 3. TOPSIS方法
print("\n" + "="*60)
print("3. TOPSIS法 - 考虑成本型指标")

# 造价和工期是成本型（越小越好）
topsis_scores, ranking = dts.topsis_method(dam_scores, weights, 
                                          cost_criteria=[4, 5])

print("\nTOPSIS得分与排名：")
for i, dam_type in enumerate(dts.dam_types):
    print(f"  {dam_type}: 得分{topsis_scores[i]:.4f}, 排名第{ranking[i]}")

# 可视化
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# 准则权重雷达图
ax = axes[0, 0]
angles = np.linspace(0, 2*np.pi, len(dts.criteria), endpoint=False).tolist()
weights_plot = weights.tolist()
angles += angles[:1]
weights_plot += weights_plot[:1]

ax.plot(angles, weights_plot, 'o-', linewidth=2, color='blue')
ax.fill(angles, weights_plot, alpha=0.25, color='blue')
ax.set_xticks(angles[:-1])
ax.set_xticklabels(dts.criteria, fontsize=10)
ax.set_ylim(0, weights.max() * 1.2)
ax.set_title('准则权重分布（AHP）', fontsize=12, fontweight='bold')
ax.grid(True)

# 各坝型雷达图对比
ax = axes[0, 1]
colors = ['red', 'green', 'orange']

for i, (dam_type, color) in enumerate(zip(dts.dam_types, colors)):
    scores_plot = dam_scores[i, :].tolist()
    scores_plot += scores_plot[:1]
    
    ax.plot(angles, scores_plot, 'o-', linewidth=2, label=dam_type, color=color)
    ax.fill(angles, scores_plot, alpha=0.15, color=color)

ax.set_xticks(angles[:-1])
ax.set_xticklabels(dts.criteria, fontsize=9)
ax.set_ylim(0, 100)
ax.set_title('各坝型准则得分对比', fontsize=12, fontweight='bold')
ax.legend(loc='upper right')
ax.grid(True)

# 综合得分柱状图
ax = axes[1, 0]
x = np.arange(len(dts.dam_types))
bars1 = ax.bar(x - 0.2, comprehensive_scores, 0.4, label='加权平均', color='skyblue')
bars2 = ax.bar(x + 0.2, topsis_scores * 100, 0.4, label='TOPSIS', color='lightcoral')

ax.set_xlabel('坝型', fontsize=11)
ax.set_ylabel('综合得分', fontsize=11)
ax.set_title('不同方法综合评价结果对比', fontsize=12, fontweight='bold')
ax.set_xticks(x)
ax.set_xticklabels(dts.dam_types)
ax.legend()
ax.grid(True, alpha=0.3, axis='y')

# 添加数值标签
for bars in [bars1, bars2]:
    for bar in bars:
        height = bar.get_height()
        ax.text(bar.get_x() + bar.get_width()/2., height,
               f'{height:.1f}', ha='center', va='bottom', fontsize=9)

# 灵敏度分析
ax = axes[1, 1]

# 改变"造价"权重，观察排名变化
cost_weight_range = np.linspace(0.05, 0.30, 20)
rankings_history = []

for cost_weight in cost_weight_range:
    # 调整权重（简化：仅调整造价权重，其他等比缩放）
    adjusted_weights = weights.copy()
    adjusted_weights[5] = cost_weight
    
    # 重新归一化
    other_sum = adjusted_weights.sum() - cost_weight
    if other_sum > 0:
        for i in range(len(adjusted_weights)):
            if i != 5:
                adjusted_weights[i] = adjusted_weights[i] / other_sum * (1 - cost_weight)
    
    scores_temp = dts.comprehensive_evaluation(adjusted_weights, dam_scores)
    rankings_history.append(np.argsort(-scores_temp))

rankings_history = np.array(rankings_history)

for i, dam_type in enumerate(dts.dam_types):
    ax.plot(cost_weight_range, rankings_history[:, i] + 1, 'o-',
           label=dam_type, linewidth=2, markersize=4)

ax.set_xlabel('造价权重', fontsize=11)
ax.set_ylabel('排名', fontsize=11)
ax.set_title('灵敏度分析（造价权重变化）', fontsize=12, fontweight='bold')
ax.set_yticks([1, 2, 3])
ax.set_yticklabels(['第1名', '第2名', '第3名'])
ax.invert_yaxis()
ax.legend()
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('dam_type_selection.png', dpi=300, bbox_inches='tight')
plt.show()
```

---

## 三、枢纽布置优化

### 3.1 枢纽组成

**挡水建筑物**：
- 大坝

**泄水建筑物**：
- 溢洪道
- 泄洪隧洞
- 坝身泄水孔

**输水建筑物**：
- 引水隧洞
- 压力管道
- 渠道

**专门建筑物**：
- 水电站厂房
- 船闸/升船机
- 过鱼设施

---

### 3.2 布置原则

1. **因地制宜**：适应地形地质
2. **综合利用**：满足多目标要求
3. **经济合理**：降低工程量和投资
4. **施工方便**：缩短工期，保证质量
5. **运行安全**：可靠性高，便于管理

---

### 3.3 优化方法

#### (1) 溢洪道位置优化

**目标**：最小化泄洪雾化影响

**约束**：
- 泄流能力满足设计洪水
- 与其他建筑物间距安全
- 地质条件满足要求

**优化模型**：
$$
\begin{aligned}
\min \quad & f(\mathbf{x}) = \text{雾化影响范围面积} \\
\text{s.t.} \quad & Q_{\text{设计}} \leq Q_{\text{能力}}(\mathbf{x}) \\
& d_i(\mathbf{x}) \geq d_{\min}, \quad i = 1, \ldots, n \\
& \mathbf{x}_L \leq \mathbf{x} \leq \mathbf{x}_U
\end{aligned}
$$

其中 $\mathbf{x}$ 包括溢洪道位置、宽度、堰顶高程等决策变量

#### (2) 厂房位置优化

**目标**：最大化发电效益 - 最小化建设成本

**多目标优化**：
$$
\begin{aligned}
\max \quad & f_1(\mathbf{x}) = \text{NPV（净现值）} \\
\min \quad & f_2(\mathbf{x}) = \text{引水系统水头损失} \\
\text{s.t.} \quad & \text{地质约束} \\
& \text{施工约束} \\
& \text{运行约束}
\end{aligned}
$$

---

## 四、Python优化工具

```python
class HydropowerLayoutOptimization:
    """水利枢纽布置优化"""
    
    def __init__(self, Q_design, H_total, eta=0.9, rho=1000, g=9.81):
        """
        参数:
            Q_design: 设计流量 (m^3/s)
            H_total: 总水头 (m)
            eta: 综合效率
            rho: 水密度
            g: 重力加速度
        """
        self.Q_design = Q_design
        self.H_total = H_total
        self.eta = eta
        self.rho = rho
        self.g = g
    
    def power_output(self, Q, H_loss):
        """
        计算发电量
        
        参数:
            Q: 引用流量
            H_loss: 水头损失
        
        返回:
            P: 发电量 (MW)
        """
        H_net = self.H_total - H_loss
        P = self.eta * self.rho * self.g * Q * H_net / 1e6
        return P
    
    def headloss_tunnel(self, L, D, Q, epsilon=0.0002, nu=1e-6):
        """
        隧洞水头损失计算
        
        参数:
            L: 隧洞长度 (m)
            D: 隧洞直径 (m)
            Q: 流量 (m^3/s)
            epsilon: 粗糙度 (m)
            nu: 运动粘度 (m^2/s)
        
        返回:
            h_f: 沿程损失 (m)
        """
        A = np.pi * D**2 / 4
        v = Q / A
        Re = v * D / nu
        
        # Colebrook-White公式迭代求摩阻系数
        f = 0.02  # 初值
        for _ in range(10):
            f_new = 1 / (-2 * np.log10(epsilon / (3.7 * D) + 
                                       2.51 / (Re * np.sqrt(f))))**2
            if abs(f_new - f) < 1e-6:
                break
            f = f_new
        
        h_f = f * L / D * v**2 / (2 * self.g)
        
        return h_f
    
    def optimize_tunnel_diameter(self, L, Q, D_range=(3, 15)):
        """
        优化隧洞直径（经济直径）
        
        参数:
            L: 隧洞长度
            Q: 设计流量
            D_range: 直径范围
        
        返回:
            D_opt: 最优直径
            cost_min: 最小年费用
        """
        from scipy.optimize import minimize_scalar
        
        # 单位成本（简化）
        C_tunnel = 10000  # 元/m^3（隧洞开挖）
        C_energy = 0.3  # 元/kW·h（电价）
        T_operation = 5000  # 小时/年（运行小时数）
        
        def annual_cost(D):
            """年费用"""
            # 建设费用（年摊）
            V_tunnel = np.pi * D**2 / 4 * L
            Cost_construction = C_tunnel * V_tunnel / 30  # 30年摊销
            
            # 运行费用（水头损失）
            h_f = self.headloss_tunnel(L, D, Q)
            P_loss = self.rho * self.g * Q * h_f / 1e6  # MW
            Cost_operation = P_loss * T_operation * C_energy * 1e3
            
            return Cost_construction + Cost_operation
        
        result = minimize_scalar(annual_cost, bounds=D_range, method='bounded')
        
        D_opt = result.x
        cost_min = result.fun
        
        return D_opt, cost_min
    
    def pareto_front_layout(self, n_points=50):
        """
        生成布置方案Pareto前沿
        
        返回:
            pareto_solutions: (n_points, 2) 数组 [NPV, H_loss]
        """
        # 决策变量：隧洞长度L, 直径D
        L_range = np.linspace(500, 2000, n_points)
        
        solutions = []
        
        for L in L_range:
            D_opt, _ = self.optimize_tunnel_diameter(L, self.Q_design)
            
            # 计算水头损失
            h_loss = self.headloss_tunnel(L, D_opt, self.Q_design)
            
            # 计算发电量和NPV（简化）
            P = self.power_output(self.Q_design, h_loss)
            
            # 建设成本
            V_tunnel = np.pi * D_opt**2 / 4 * L
            Cost = 10000 * V_tunnel
            
            # 年收益
            Revenue = P * 5000 * 0.3 * 1e3  # 元/年
            
            # NPV（简化，30年，折现率8%）
            NPV = -Cost + Revenue * ((1 - (1.08)**-30) / 0.08)
            
            solutions.append([NPV / 1e8, h_loss])  # NPV单位：亿元
        
        return np.array(solutions)


# 测试
print("\n" + "="*60)
print("水利枢纽布置优化")
print("="*60)

hlo = HydropowerLayoutOptimization(Q_design=200, H_total=100)

# 1. 经济直径优化
print("\n1. 引水隧洞经济直径优化")

L_tunnel = 1000  # m
D_opt, cost_min = hlo.optimize_tunnel_diameter(L_tunnel, hlo.Q_design)

print(f"\n隧洞长度: {L_tunnel} m")
print(f"设计流量: {hlo.Q_design} m³/s")
print(f"最优直径: {D_opt:.2f} m")
print(f"最小年费用: {cost_min/1e6:.2f} 百万元/年")

# 计算水头损失和发电量
h_loss_opt = hlo.headloss_tunnel(L_tunnel, D_opt, hlo.Q_design)
P_opt = hlo.power_output(hlo.Q_design, h_loss_opt)

print(f"水头损失: {h_loss_opt:.2f} m")
print(f"发电量: {P_opt:.2f} MW")

# 2. Pareto前沿
print("\n2. 布置方案Pareto前沿分析")

pareto = hlo.pareto_front_layout(n_points=30)

# 可视化
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# 经济直径
ax = axes[0]
D_range = np.linspace(3, 15, 100)
costs = []

for D in D_range:
    V = np.pi * D**2 / 4 * L_tunnel
    Cost_construction = 10000 * V / 30
    
    h_f = hlo.headloss_tunnel(L_tunnel, D, hlo.Q_design)
    P_loss = hlo.rho * hlo.g * hlo.Q_design * h_f / 1e6
    Cost_operation = P_loss * 5000 * 0.3 * 1e3
    
    costs.append((Cost_construction + Cost_operation) / 1e6)

ax.plot(D_range, costs, 'b-', linewidth=2)
ax.axvline(D_opt, color='r', linestyle='--', linewidth=2, label=f'最优直径 D={D_opt:.2f}m')
ax.scatter([D_opt], [cost_min/1e6], color='red', s=100, zorder=5)

ax.set_xlabel('隧洞直径 (m)', fontsize=11)
ax.set_ylabel('年费用 (百万元/年)', fontsize=11)
ax.set_title('引水隧洞经济直径优化', fontsize=12, fontweight='bold')
ax.legend()
ax.grid(True, alpha=0.3)

# Pareto前沿
ax = axes[1]
ax.plot(pareto[:, 1], pareto[:, 0], 'go-', linewidth=2, markersize=5)
ax.set_xlabel('水头损失 (m)', fontsize=11)
ax.set_ylabel('净现值 NPV (亿元)', fontsize=11)
ax.set_title('布置方案Pareto前沿（隧洞长度-直径权衡）', fontsize=12, fontweight='bold')
ax.grid(True, alpha=0.3)

# 标注几个关键点
idx_max_npv = np.argmax(pareto[:, 0])
idx_min_loss = np.argmin(pareto[:, 1])

ax.scatter(pareto[idx_max_npv, 1], pareto[idx_max_npv, 0],
          color='red', s=100, marker='*', label='最大NPV', zorder=5)
ax.scatter(pareto[idx_min_loss, 1], pareto[idx_min_loss, 0],
          color='blue', s=100, marker='s', label='最小损失', zorder=5)

ax.legend()

plt.tight_layout()
plt.savefig('hydropower_layout_optimization.png', dpi=300, bbox_inches='tight')
plt.show()
```

---

## 五、本章要点

1. **坝址选择**：
   - 地质、地形、水文、工程条件
   - 层次分析法（AHP）
   - 模糊综合评价
   - TOPSIS法

2. **坝型选择**：
   - 重力坝、拱坝、土石坝特点对比
   - 多准则决策
   - 灵敏度分析

3. **枢纽布置优化**：
   - 溢洪道位置优化
   - 厂房位置优化
   - 引水系统优化
   - Pareto前沿分析

4. **优化工具**：
   - Python决策支持系统
   - 多目标优化
   - 经济分析

---

**下一章**：综合水利工程案例
