# 第8章：水工建筑物综合设计与优化

**学习时间**: 4小时  
**考试频率**: ⭐⭐⭐⭐⭐  
**难度**: ⭐⭐⭐⭐⭐

---

## 一、综合设计流程

### 1.1 设计阶段

**三阶段设计**：
1. **规划阶段**：
   - 流域规划
   - 坝址比选
   - 开发方式论证

2. **设计阶段**：
   - 可行性研究（可研）
   - 初步设计（初设）
   - 施工图设计

3. **施工阶段**：
   - 施工组织设计
   - 变更设计

### 1.2 设计标准

**防洪标准**：
| 工程等级 | 设计洪水 | 校核洪水 |
|----------|----------|----------|
| I级 | 100年一遇 | 1000-10000年 |
| II级 | 50年一遇 | 500-1000年 |
| III级 | 20-50年 | 200-500年 |

**抗震标准**：
根据地震烈度和工程等级确定设防标准

---

## 二、枢纽布置优化

### 2.1 坝址选择

**综合评价指标**：
```python
Score = w1·Geology + w2·Hydrology + w3·Economy + w4·Environment
```

**权重设置**：
- 地质条件：$w_1 = 0.35$
- 水文条件：$w_2 = 0.25$
- 工程造价：$w_3 = 0.25$
- 环境影响：$w_4 = 0.15$

### 2.2 枢纽总体布置

**典型布置**（河床式）：
```
上游：拦河坝 | 溢洪道 | 电站厂房 | 船闸/鱼道
```

**布置原则**：
1. 合理利用地形地质
2. 枢纽集中，管理方便
3. 泄洪消能有效
4. 施工便利
5. 运行安全可靠

---

## 三、水力设计优化

### 3.1 溢洪道优化

**目标函数**（多目标优化）：
$$\min \quad F = f_1(\text{造价}) + f_2(\text{风险}) + f_3(\text{环境})$$

**约束条件**：
- 泄洪能力：$Q \geq Q_{设计}$
- 下游水位：$H_{下} \leq H_{允许}$
- 消能充分度：$\eta \geq 0.8$

**设计变量**：
- 堰顶高程
- 堰面曲线参数
- 消力池尺寸

**例题1**：优化溢洪道堰顶高程

给定：
- 正常蓄水位：$H_N = 100$ m
- 设计洪水位：$H_d = 102$ m
- 校核洪水位：$H_c = 103$ m
- 坝顶高程：$H_{坝} = 105$ m

要求：确定堰顶高程$H_堰$，使得泄洪能力满足要求且安全。

**解**：
取$H_堰 = H_N = 100$ m（正常蓄水位作堰顶）

设计工况：
$$Q_d = m \cdot b \cdot \sqrt{2g} \cdot H_d^{3/2}$$

校核工况：
$$Q_c = m \cdot b \cdot \sqrt{2g} \cdot H_c^{3/2}$$

需满足：$Q_d \geq Q_{设计}$，$Q_c \geq Q_{校核}$

---

### 3.2 水轮机选型优化

**比转速**：
$$n_s = \frac{n \sqrt{N}}{H^{5/4}}$$

**选型原则**：
| $n_s$ | 水轮机类型 | 适用水头 |
|-------|------------|----------|
| $< 150$ | 冲击式(Pelton) | $> 200$ m |
| $150-400$ | 混流式(Francis) | $30-200$ m |
| $> 400$ | 轴流式(Kaplan) | $< 30$ m |

**优化目标**：
$$\max \quad \eta_{综合} = \eta_{水轮机} \times \eta_{发电机} \times \eta_{变压器}$$

---

## 四、结构优化设计

### 4.1 重力坝剖面优化

**优化模型**：
$$\min \quad V_{混凝土} = \frac{1}{2}(T_1 + T_2) \cdot H$$

**约束**：
- 抗滑稳定：$K_c \geq 1.05$
- 抗倾稳定：$K_0 \geq 1.5$
- 地基应力：$\sigma_{max} \leq [\sigma]$，$\sigma_{min} \geq 0$

**设计变量**：
- 上游坡比：$m_1$
- 下游坡比：$m_2$
- 顶宽：$T_1$

**例题2**：优化重力坝剖面

给定：
- 坝高：$H = 50$ m
- 上游水深：$h_1 = 45$ m
- 下游水深：$h_2 = 5$ m
- 地基$\tan\varphi = 0.7$，$[\sigma] = 1000$ kPa

求：最优剖面尺寸

**解**（采用优化算法）：

```python
from scipy.optimize import minimize

def objective(x):
    # x = [m2, T1], m1=0(直立)
    m2, T1 = x
    V = 0.5 * (T1 + (T1 + m2*H)) * H
    return V

def constraints_fun(x):
    # 返回约束违反程度（≥0为满足）
    # ... 计算抗滑、抗倾、应力
    pass
```

典型结果：
- 上游坡比：$m_1 = 0$（直立）
- 下游坡比：$m_2 = 0.7 \sim 0.8$
- 顶宽：$T_1 = 0.1H = 5$ m

---

### 4.2 土石坝优化

**目标**：
$$\min \quad C_{总} = C_{土方} + C_{防渗} + C_{排水}$$

**约束**：
- 渗透稳定：坡降$i < i_{临界}$
- 坝坡稳定：$K_{稳定} \geq 1.3$
- 沉降控制：$S < S_{允许}$

**设计变量**：
- 坝顶宽度
- 上下游坝坡
- 心墙/斜墙厚度
- 反滤层设计

---

## 五、可靠度设计

### 5.1 可靠度理论

**可靠度**：
$$R = P(Z > 0)$$

其中功能函数：
$$Z = g(R_1, R_2, \ldots) - S$$

**可靠指标**：
$$\beta = \frac{\mu_Z}{\sigma_Z}$$

**目标可靠指标**（规范）：
| 工程等级 | 安全级别 | $\beta$ |
|----------|----------|---------|
| I级 | 一级 | 4.2 |
| II级 | 二级 | 3.7 |
| III级 | 三级 | 3.2 |

### 5.2 随机有限元

**基本思想**：将材料参数、荷载视为随机变量

**Monte Carlo模拟**：
```python
n_sim = 10000
failures = 0

for i in range(n_sim):
    # 随机抽样
    phi = np.random.normal(mu_phi, sigma_phi)
    c = np.random.normal(mu_c, sigma_c)
    
    # 计算安全系数
    Kc = calculate_stability(phi, c, ...)
    
    if Kc < 1.0:
        failures += 1

pf = failures / n_sim  # 失效概率
```

---

## 六、经济分析与决策

### 6.1 工程经济评价

**投资估算**：
$$C_{总} = C_{建筑} + C_{设备} + C_{安装} + C_{其他}$$

**经济指标**：

**(1) 静态投资回收期**：
$$T = \frac{C_{总}}{年净收益}$$

**(2) 净现值NPV**：
$$NPV = \sum_{t=1}^n \frac{B_t - C_t}{(1+i)^t} - C_0$$

**(3) 内部收益率IRR**：
$$\sum_{t=0}^n \frac{CF_t}{(1+IRR)^t} = 0$$

### 6.2 多方案比选

**层次分析法（AHP）**：

**步骤**：
1. 建立层次结构
2. 构造判断矩阵
3. 计算权重
4. 一致性检验
5. 综合排序

**例题3**：三种坝型方案比选

| 方案 | 造价(亿元) | 工期(年) | 安全性 | 环境影响 |
|------|------------|----------|--------|----------|
| 混凝土重力坝 | 10 | 3 | 高 | 中 |
| 土石坝 | 7 | 4 | 中 | 高 |
| 碾压混凝土坝 | 8 | 2.5 | 高 | 低 |

**权重**：造价0.4，工期0.2，安全0.3，环境0.1

**评分**（归一化+加权）：
- 方案1：$0.4 \times 0.7 + 0.2 \times 0.67 + 0.3 \times 1.0 + 0.1 \times 0.67 = 0.78$
- 方案2：$0.4 \times 1.0 + 0.2 \times 0.5 + 0.3 \times 0.67 + 0.1 \times 0.33 = 0.73$
- 方案3：$0.4 \times 0.87 + 0.2 \times 1.0 + 0.3 \times 1.0 + 0.1 \times 1.0 = 0.88$ ✓

推荐方案3。

---

## 七、Python综合设计工具

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize, differential_evolution

class IntegratedDesignTool:
    """综合设计优化工具"""
    
    def __init__(self):
        self.g = 9.81
    
    def optimize_gravity_dam_profile(self, H, h1, h2, tan_phi, sigma_allow):
        """
        重力坝剖面优化
        
        参数:
            H: 坝高(m)
            h1, h2: 上下游水深(m)
            tan_phi: 摩擦系数
            sigma_allow: 地基承载力(kPa)
        
        返回:
            optimal_profile: 最优剖面参数
        """
        gamma_c = 24  # 混凝土容重 kN/m³
        gamma_w = 10  # 水容重 kN/m³
        
        def objective(x):
            # x = [m2, T1]
            m2, T1 = x
            V = 0.5 * (T1 + (T1 + m2*H)) * H  # 单宽体积
            return V
        
        def constraint_sliding(x):
            m2, T1 = x
            b = T1 + m2*H  # 底宽
            
            # 自重
            W = gamma_c * 0.5 * (T1 + b) * H
            
            # 水压力
            P1 = 0.5 * gamma_w * h1**2
            P2 = 0.5 * gamma_w * h2**2
            
            # 扬压力（简化）
            U = 0.5 * gamma_w * h1 * b * 0.5
            
            # 抗滑稳定系数
            Kc = (W - U) * tan_phi / (P1 - P2)
            
            return Kc - 1.05
        
        def constraint_overturning(x):
            m2, T1 = x
            b = T1 + m2*H
            
            W = gamma_c * 0.5 * (T1 + b) * H
            M_W = W * (b/3 + T1/6)  # 对趾点
            
            P1 = 0.5 * gamma_w * h1**2
            M_P1 = P1 * h1/3
            
            P2 = 0.5 * gamma_w * h2**2
            M_P2 = P2 * h2/3
            
            U = 0.5 * gamma_w * h1 * b * 0.5
            M_U = U * b/2
            
            M_resist = M_W + M_P2
            M_overt = M_P1 + M_U
            
            K0 = M_resist / M_overt
            
            return K0 - 1.5
        
        def constraint_stress(x):
            m2, T1 = x
            b = T1 + m2*H
            
            # 竖向力
            W = gamma_c * 0.5 * (T1 + b) * H
            U = 0.5 * gamma_w * h1 * b * 0.5
            V = W - U
            
            # 力矩
            # (简化计算，实际需详细计算)
            M = 0  # 需根据各力对底板中心力矩计算
            
            e = abs(M / V)
            
            sigma_max = V / b * (1 + 6*e/b)
            
            return sigma_allow - sigma_max
        
        # 约束
        cons = [
            {'type': 'ineq', 'fun': constraint_sliding},
            {'type': 'ineq', 'fun': constraint_overturning},
            {'type': 'ineq', 'fun': constraint_stress}
        ]
        
        # 初值
        x0 = [0.75, H*0.1]
        
        # 边界
        bounds = [(0.6, 1.0), (H*0.05, H*0.15)]
        
        # 优化
        result = minimize(objective, x0, method='SLSQP',
                        bounds=bounds, constraints=cons)
        
        if result.success:
            m2_opt, T1_opt = result.x
            V_opt = result.fun
            
            return {
                'm2': m2_opt,
                'T1': T1_opt,
                'b': T1_opt + m2_opt*H,
                'volume': V_opt
            }
        else:
            return None
    
    def monte_carlo_reliability(self, n_sim=10000):
        """
        Monte Carlo可靠度分析
        
        示例：边坡稳定
        """
        # 参数分布
        mu_c = 20  # 粘聚力均值 kPa
        sigma_c = 5
        
        mu_phi = 25  # 内摩擦角均值 度
        sigma_phi = 3
        
        failures = 0
        Kc_values = []
        
        for i in range(n_sim):
            c = np.random.normal(mu_c, sigma_c)
            phi = np.random.normal(mu_phi, sigma_phi)
            
            # 简化Bishop法计算安全系数
            # (实际需详细计算)
            Kc = c * 100 / (200 - 50*np.tan(np.radians(phi)))
            
            Kc_values.append(Kc)
            
            if Kc < 1.0:
                failures += 1
        
        pf = failures / n_sim
        beta = -np.log(pf)
        
        return {
            'pf': pf,
            'beta': beta,
            'Kc_mean': np.mean(Kc_values),
            'Kc_std': np.std(Kc_values),
            'Kc_values': Kc_values
        }
    
    def npv_analysis(self, C0, annual_benefits, n_years, discount_rate):
        """
        净现值分析
        
        参数:
            C0: 初始投资
            annual_benefits: 年净收益数组
            n_years: 项目年限
            discount_rate: 折现率
        """
        npv = -C0
        
        for t, benefit in enumerate(annual_benefits, start=1):
            npv += benefit / (1 + discount_rate)**t
        
        return npv
    
    def plot_optimization_results(self, results):
        """可视化优化结果"""
        fig, axes = plt.subplots(2, 2, figsize=(14, 10))
        
        # 1. 剖面形状
        ax1 = axes[0, 0]
        
        H = 50
        m2 = results['m2']
        T1 = results['T1']
        b = results['b']
        
        x = [0, T1, b, 0, 0]
        y = [H, H, 0, 0, H]
        
        ax1.fill(x, y, color='gray', alpha=0.5, label='坝体')
        ax1.plot(x, y, 'k-', linewidth=2)
        
        # 水位
        ax1.fill([0, 0, T1/2], [0, 45, 45],
                color='blue', alpha=0.3, label='上游水位')
        
        ax1.set_xlabel('宽度 (m)', fontsize=11)
        ax1.set_ylabel('高程 (m)', fontsize=11)
        ax1.set_title('优化剖面形状', fontweight='bold')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        ax1.axis('equal')
        
        # 2. 可靠度直方图
        ax2 = axes[0, 1]
        
        reliability_result = self.monte_carlo_reliability(n_sim=5000)
        Kc_values = reliability_result['Kc_values']
        
        ax2.hist(Kc_values, bins=50, density=True, alpha=0.7,
                color='blue', edgecolor='black')
        ax2.axvline(1.0, color='r', linestyle='--', linewidth=2,
                   label='Kc=1.0(失效)')
        ax2.axvline(np.mean(Kc_values), color='g', linestyle='--',
                   linewidth=2, label=f'均值={np.mean(Kc_values):.2f}')
        
        ax2.set_xlabel('安全系数 Kc', fontsize=11)
        ax2.set_ylabel('概率密度', fontsize=11)
        ax2.set_title('可靠度分析', fontweight='bold')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        
        # 3. NPV敏感性分析
        ax3 = axes[1, 0]
        
        C0 = 100  # 亿元
        annual_benefit_base = 15  # 亿元/年
        n_years = 30
        
        discount_rates = np.linspace(0.03, 0.10, 20)
        npvs = []
        
        for r in discount_rates:
            annual_benefits = [annual_benefit_base] * n_years
            npv = self.npv_analysis(C0, annual_benefits, n_years, r)
            npvs.append(npv)
        
        ax3.plot(discount_rates*100, npvs, 'b-', linewidth=2)
        ax3.axhline(0, color='r', linestyle='--', linewidth=1)
        
        ax3.set_xlabel('折现率 (%)', fontsize=11)
        ax3.set_ylabel('净现值 NPV (亿元)', fontsize=11)
        ax3.set_title('NPV敏感性分析', fontweight='bold')
        ax3.grid(True, alpha=0.3)
        
        # 4. 多目标优化Pareto前沿（示例）
        ax4 = axes[1, 1]
        
        # 模拟数据：造价 vs 安全性
        np.random.seed(42)
        n_points = 100
        cost = np.random.uniform(8, 12, n_points)
        safety = 1.5 - 0.05*(cost - 8) + np.random.normal(0, 0.05, n_points)
        
        # Pareto前沿
        pareto_mask = np.ones(n_points, dtype=bool)
        for i in range(n_points):
            for j in range(n_points):
                if i != j:
                    if cost[j] <= cost[i] and safety[j] >= safety[i]:
                        if cost[j] < cost[i] or safety[j] > safety[i]:
                            pareto_mask[i] = False
                            break
        
        ax4.scatter(cost[~pareto_mask], safety[~pareto_mask],
                   c='gray', alpha=0.5, label='可行解')
        ax4.scatter(cost[pareto_mask], safety[pareto_mask],
                   c='red', s=100, marker='*', label='Pareto前沿')
        
        ax4.set_xlabel('造价 (亿元)', fontsize=11)
        ax4.set_ylabel('安全系数', fontsize=11)
        ax4.set_title('多目标优化Pareto前沿', fontweight='bold')
        ax4.legend()
        ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('integrated_design_results.png', dpi=300)
        plt.show()

# 示例使用
print("="*60)
print("综合设计优化工具")
print("="*60)

idt = IntegratedDesignTool()

# 1. 重力坝剖面优化
print("\n1. 重力坝剖面优化")
H = 50  # m
h1 = 45  # m
h2 = 5  # m
tan_phi = 0.7
sigma_allow = 1000  # kPa

result = idt.optimize_gravity_dam_profile(H, h1, h2, tan_phi, sigma_allow)

if result:
    print(f"  优化结果:")
    print(f"  下游坝坡 m₂ = {result['m2']:.3f}")
    print(f"  坝顶宽度 T₁ = {result['T1']:.2f} m")
    print(f"  底板宽度 b = {result['b']:.2f} m")
    print(f"  单宽体积 V = {result['volume']:.1f} m³/m")
    
    # 可视化
    print("\n绘制优化结果...")
    idt.plot_optimization_results(result)
else:
    print("  优化失败，约束无法满足")

# 2. 可靠度分析
print("\n" + "="*60)
print("2. Monte Carlo可靠度分析")

reliability = idt.monte_carlo_reliability(n_sim=10000)

print(f"  失效概率 pf = {reliability['pf']:.4e}")
print(f"  可靠指标 β = {reliability['beta']:.2f}")
print(f"  安全系数均值 = {reliability['Kc_mean']:.2f}")
print(f"  安全系数标准差 = {reliability['Kc_std']:.2f}")

# 3. 经济评价
print("\n" + "="*60)
print("3. 经济评价")

C0 = 100  # 初始投资 亿元
annual_benefit = 15  # 年净收益 亿元
n_years = 30
discount_rate = 0.06

annual_benefits = [annual_benefit] * n_years
npv = idt.npv_analysis(C0, annual_benefits, n_years, discount_rate)

print(f"  初始投资 C₀ = {C0} 亿元")
print(f"  年净收益 = {annual_benefit} 亿元")
print(f"  项目年限 = {n_years} 年")
print(f"  折现率 = {discount_rate*100}%")
print(f"  净现值 NPV = {npv:.2f} 亿元")

if npv > 0:
    print("  ✓ 项目可行（NPV>0）")
else:
    print("  ✗ 项目不可行（NPV<0）")
```

---

## 八、工程实例

### 实例：某大型水利枢纽综合设计

**项目背景**：
- 流域面积：$A = 5000$ km²
- 多年平均径流：$W = 50$亿m³
- 设计洪峰：$Q = 15000$ m³/s

**枢纽布置**：
1. **挡水建筑物**：混凝土面板堆石坝，坝高150m
2. **泄洪建筑物**：岸边溢洪道，3孔×15m，设计流量10000m³/s
3. **引水发电系统**：引水隧洞+地下厂房，装机300MW
4. **过坝设施**：升船机

**优化成果**：
- 总投资：80亿元
- 发电量：10亿kWh/年
- 防洪效益：减少下游洪灾损失5亿元/年
- 投资回收期：12年
- NPV（i=6%）：60亿元

---

**本章重点**：
- 综合设计流程与标准
- 枢纽布置优化
- 水力与结构优化方法
- 可靠度设计理论
- 经济分析与多方案比选
- Python综合设计工具开发

**全书完成！** 🎉🎊
