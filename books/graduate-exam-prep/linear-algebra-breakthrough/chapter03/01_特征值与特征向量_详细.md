# 第3章：特征值与特征向量的快速求解

**学习时间**: 4小时  
**难度**: ⭐⭐⭐⭐⭐  
**考试权重**: 18%  
**必考题型**: ⭐⭐⭐⭐⭐

---

## 一、基本概念

### 1.1 定义

若存在数 $\lambda$ 和非零向量 $\mathbf{x}$，使得
$$A\mathbf{x} = \lambda\mathbf{x}$$

则：
- $\lambda$：**特征值**（eigenvalue）
- $\mathbf{x}$：**特征向量**（eigenvector）

### 1.2 特征方程

$$|A - \lambda I| = 0$$

这是关于 $\lambda$ 的 $n$ 次多项式方程，称为**特征方程**

**特征多项式**：
$$f(\lambda) = |A - \lambda I|$$

---

## 二、特征值与特征向量的性质

### 2.1 核心性质（必记）

1. **特征值之和** = 迹（对角线元素之和）
   $$\sum_{i=1}^{n}\lambda_i = \text{tr}(A) = \sum_{i=1}^{n}a_{ii}$$

2. **特征值之积** = 行列式
   $$\prod_{i=1}^{n}\lambda_i = |A|$$

3. **$A^k$ 的特征值** = $\lambda^k$
   
4. **$A^{-1}$ 的特征值** = $1/\lambda$

5. **$A^T$ 的特征值** = $A$ 的特征值

6. **相似矩阵特征值相同**

### 2.2 特殊矩阵的特征值

| 矩阵类型 | 特征值性质 |
|---------|-----------|
| 实对称矩阵 | 全为实数 |
| 正交矩阵 | \|λ\| = 1 |
| 正定矩阵 | 全为正数 |
| 上三角矩阵 | 主对角线元素 |

---

## 三、快速求解方法

### 3.1 二阶矩阵（直接公式）

$$A = \begin{bmatrix} a & b \\ c & d \end{bmatrix}$$

**特征方程**：
$$\lambda^2 - (a+d)\lambda + (ad-bc) = 0$$

**韦达定理**：
- $\lambda_1 + \lambda_2 = a + d$
- $\lambda_1 \lambda_2 = ad - bc$

**求根公式**：
$$\lambda = \frac{(a+d) \pm \sqrt{(a+d)^2 - 4(ad-bc)}}{2}$$

### 3.2 三阶矩阵（特征方程展开）

对于
$$A = \begin{bmatrix} a_{11} & a_{12} & a_{13} \\ a_{21} & a_{22} & a_{23} \\ a_{31} & a_{32} & a_{33} \end{bmatrix}$$

**特征方程**：
$$-\lambda^3 + (\text{tr}A)\lambda^2 - \text{[二阶主子式和]}\lambda + |A| = 0$$

### Python实现

```python
import numpy as np
import sympy as sp
from scipy.linalg import eig
import matplotlib.pyplot as plt

class EigenAnalysis:
    """
    特征值与特征向量分析
    """
    
    @staticmethod
    def eigen_2x2_formula(a, b, c, d):
        """
        二阶矩阵特征值公式法
        
        A = [[a, b],
             [c, d]]
        """
        # 韦达定理
        sum_lambda = a + d
        prod_lambda = a*d - b*c
        
        # 判别式
        discriminant = sum_lambda**2 - 4*prod_lambda
        
        if discriminant >= 0:
            lambda1 = (sum_lambda + np.sqrt(discriminant)) / 2
            lambda2 = (sum_lambda - np.sqrt(discriminant)) / 2
            eigen_type = "实特征值"
        else:
            real_part = sum_lambda / 2
            imag_part = np.sqrt(-discriminant) / 2
            lambda1 = complex(real_part, imag_part)
            lambda2 = complex(real_part, -imag_part)
            eigen_type = "复特征值"
        
        return [lambda1, lambda2], eigen_type
    
    @staticmethod
    def characteristic_equation(A):
        """
        特征方程（符号计算）
        
        参数:
            A: 矩阵（可以是符号矩阵）
        
        返回:
            特征多项式
        """
        A_sym = sp.Matrix(A)
        lambda_sym = sp.Symbol('lambda')
        
        # A - λI
        I = sp.eye(A_sym.shape[0])
        char_matrix = A_sym - lambda_sym * I
        
        # 特征多项式
        char_poly = char_matrix.det()
        
        return char_poly, lambda_sym
    
    @staticmethod
    def eigenvalues_numpy(A):
        """
        NumPy求特征值与特征向量
        
        返回:
            特征值, 特征向量矩阵
        """
        eigenvalues, eigenvectors = np.linalg.eig(A)
        
        return eigenvalues, eigenvectors
    
    @staticmethod
    def verify_eigen(A, lambda_val, x):
        """
        验证 Ax = λx
        
        参数:
            A: 矩阵
            lambda_val: 特征值
            x: 特征向量
        """
        Ax = np.dot(A, x)
        lambda_x = lambda_val * x
        
        is_valid = np.allclose(Ax, lambda_x)
        
        return is_valid, Ax, lambda_x
    
    @staticmethod
    def power_iteration(A, max_iter=100, tol=1e-6):
        """
        幂法求主特征值（模最大）
        
        参数:
            A: 矩阵
            max_iter: 最大迭代次数
            tol: 收敛容差
        """
        n = A.shape[0]
        
        # 初始向量
        x = np.random.rand(n)
        x = x / np.linalg.norm(x)
        
        lambda_old = 0
        
        for i in range(max_iter):
            # x_{k+1} = Ax_k / ||Ax_k||
            Ax = np.dot(A, x)
            x_new = Ax / np.linalg.norm(Ax)
            
            # Rayleigh商估计特征值
            lambda_new = np.dot(x_new, np.dot(A, x_new))
            
            # 收敛检查
            if abs(lambda_new - lambda_old) < tol:
                return lambda_new, x_new, i+1
            
            x = x_new
            lambda_old = lambda_new
        
        return lambda_new, x_new, max_iter
    
    @staticmethod
    def diagonalize(A):
        """
        矩阵对角化
        
        A = PDP^(-1)
        
        返回:
            P (特征向量矩阵), D (对角矩阵)
        """
        eigenvalues, eigenvectors = np.linalg.eig(A)
        
        # D: 对角矩阵
        D = np.diag(eigenvalues)
        
        # P: 特征向量矩阵
        P = eigenvectors
        
        # 验证
        P_inv = np.linalg.inv(P)
        A_reconstructed = P @ D @ P_inv
        
        is_valid = np.allclose(A, A_reconstructed)
        
        return P, D, is_valid


# 示例1：二阶矩阵
print("="*60)
print("示例1：二阶矩阵特征值（公式法）")
print("="*60)

A = np.array([
    [3, 1],
    [1, 3]
])

print("矩阵A:")
print(A)

# 公式法
eigenvalues_formula, eigen_type = EigenAnalysis.eigen_2x2_formula(3, 1, 1, 3)
print(f"\n特征值（公式法）: {eigenvalues_formula}")
print(f"类型: {eigen_type}")

# NumPy验证
eigenvalues_np, eigenvectors_np = EigenAnalysis.eigenvalues_numpy(A)
print(f"\n特征值（NumPy）: {eigenvalues_np}")
print(f"\n特征向量矩阵:")
print(eigenvectors_np)

# 验证
for i, (lambda_val, x) in enumerate(zip(eigenvalues_np, eigenvectors_np.T)):
    is_valid, Ax, lambda_x = EigenAnalysis.verify_eigen(A, lambda_val, x)
    print(f"\n特征值λ{i+1}={lambda_val:.2f}:")
    print(f"  验证Ax=λx: {is_valid}")

# 示例2：特征方程（符号）
print("\n" + "="*60)
print("示例2：特征方程（符号计算）")
print("="*60)

a = sp.Symbol('a')
A_sym = sp.Matrix([
    [a, 1, 0],
    [0, a, 1],
    [0, 0, a]
])

print("矩阵A(a):")
print(A_sym)

char_poly, lambda_sym = EigenAnalysis.characteristic_equation(A_sym)
print(f"\n特征多项式:")
print(f"f(λ) = {char_poly}")

# 因式分解
char_poly_factored = sp.factor(char_poly)
print(f"\n因式分解:")
print(f"f(λ) = {char_poly_factored}")

print(f"\n特征值: λ = a (三重根)")

# 示例3：对角化
print("\n" + "="*60)
print("示例3：矩阵对角化")
print("="*60)

A = np.array([
    [4, -2],
    [1, 1]
])

print("矩阵A:")
print(A)

P, D, is_valid = EigenAnalysis.diagonalize(A)

print(f"\n特征向量矩阵P:")
print(P)

print(f"\n对角矩阵D:")
print(D)

print(f"\n验证 A = PDP^(-1): {is_valid}")

# 应用：计算A^10
A_10 = P @ np.linalg.matrix_power(D, 10) @ np.linalg.inv(P)
print(f"\nA^10 =")
print(A_10.astype(int))

# 示例4：幂法
print("\n" + "="*60)
print("示例4：幂法求主特征值")
print("="*60)

A = np.array([
    [6, 5, 3],
    [5, 1, 4],
    [3, 4, 6]
])

print("矩阵A:")
print(A)

lambda_max, x_max, n_iter = EigenAnalysis.power_iteration(A)

print(f"\n主特征值（幂法）:")
print(f"  λ_max = {lambda_max:.6f}")
print(f"  迭代次数: {n_iter}")
print(f"  特征向量: {x_max}")

# NumPy验证
eigenvalues_all = np.linalg.eigvals(A)
print(f"\n所有特征值（NumPy）:")
print(f"  {eigenvalues_all}")
print(f"  最大: {np.max(eigenvalues_all):.6f}")
```

---

## 四、典型考题速解

### 考题1：求特征值

**【题目】**求矩阵的特征值
$$A = \begin{bmatrix} 2 & 1 & 0 \\ 0 & 2 & 0 \\ 0 & 0 & 3 \end{bmatrix}$$

**【快速解法】**

**上三角矩阵，特征值 = 主对角线元素**

**答案**：$\lambda_1 = 2$（二重），$\lambda_3 = 3$

---

### 考题2：特征值性质

**【题目】**已知矩阵 $A$ 的特征值为 1, 2, 3，求：
1. $|A|$
2. $\text{tr}(A)$
3. $|A^{-1}|$
4. $A^2$ 的特征值

**【解答】**

1. $|A| = 1 \times 2 \times 3 = 6$

2. $\text{tr}(A) = 1 + 2 + 3 = 6$

3. $|A^{-1}| = \frac{1}{|A|} = \frac{1}{6}$

4. $A^2$ 的特征值：$1^2, 2^2, 3^2$ = **1, 4, 9**

---

### 考题3：实对称矩阵

**【题目】**求矩阵的特征值和特征向量
$$A = \begin{bmatrix} 2 & 2 \\ 2 & 2 \end{bmatrix}$$

**【解答】**

**特征方程**：
$$|A - \lambda I| = \begin{vmatrix} 2-\lambda & 2 \\ 2 & 2-\lambda \end{vmatrix} = 0$$

$$(2-\lambda)^2 - 4 = 0$$

$$\lambda^2 - 4\lambda = 0$$

$$\lambda(\lambda - 4) = 0$$

**特征值**：$\lambda_1 = 4$, $\lambda_2 = 0$

**特征向量**：

对 $\lambda_1 = 4$：
$$(A - 4I)\mathbf{x} = 0$$
$$\begin{bmatrix} -2 & 2 \\ 2 & -2 \end{bmatrix}\begin{bmatrix} x_1 \\ x_2 \end{bmatrix} = 0$$

解得：$\mathbf{x}_1 = k\begin{bmatrix} 1 \\ 1 \end{bmatrix}$

对 $\lambda_2 = 0$：
$$\mathbf{x}_2 = k\begin{bmatrix} 1 \\ -1 \end{bmatrix}$$

**验证正交**：$\mathbf{x}_1^T \mathbf{x}_2 = 1 \times 1 + 1 \times (-1) = 0$ ✓

---

## 五、相似对角化

### 5.1 对角化条件

矩阵 $A$ 可对角化 ⇔ 有 $n$ 个线性无关的特征向量

**充分条件**：
1. $A$ 有 $n$ 个不同的特征值
2. $A$ 是实对称矩阵

### 5.2 对角化公式

$$A = PDP^{-1}$$

其中：
- $P$：特征向量矩阵（列向量为特征向量）
- $D$：对角矩阵（对角线为特征值）

**应用**：
$$A^k = PD^kP^{-1}$$

计算高次幂变简单！

---

## 六、应用：马尔可夫链

```python
class MarkovChain:
    """
    马尔可夫链（特征值应用）
    """
    
    @staticmethod
    def steady_state(P, method='eigen'):
        """
        稳态分布
        
        Pπ = π （特征值1对应的特征向量）
        
        参数:
            P: 转移矩阵（列随机）
            method: 'eigen'或'iteration'
        """
        if method == 'eigen':
            # 求P^T的特征值和特征向量
            eigenvalues, eigenvectors = np.linalg.eig(P.T)
            
            # 找特征值=1的特征向量
            idx = np.argmin(np.abs(eigenvalues - 1))
            pi = eigenvectors[:, idx].real
            
            # 归一化
            pi = pi / np.sum(pi)
        
        else:  # iteration
            # 迭代法：π_{k+1} = P π_k
            n = P.shape[0]
            pi = np.ones(n) / n  # 初始均匀分布
            
            for _ in range(1000):
                pi = P @ pi
                pi = pi / np.sum(pi)
        
        return pi


# 马尔可夫链示例
print("\n" + "="*60)
print("应用：马尔可夫链稳态分布")
print("="*60)

# 转移矩阵（天气模型：晴->晴0.8, 晴->雨0.2, 雨->晴0.4, 雨->雨0.6）
P = np.array([
    [0.8, 0.4],
    [0.2, 0.6]
])

print("转移矩阵P:")
print(P)

# 特征值方法
pi_eigen = MarkovChain.steady_state(P, method='eigen')
print(f"\n稳态分布（特征值法）:")
print(f"  晴天概率: {pi_eigen[0]:.4f}")
print(f"  雨天概率: {pi_eigen[1]:.4f}")

# 迭代法验证
pi_iter = MarkovChain.steady_state(P, method='iteration')
print(f"\n稳态分布（迭代法）:")
print(f"  晴天概率: {pi_iter[0]:.4f}")
print(f"  雨天概率: {pi_iter[1]:.4f}")

# 验证：Pπ = π
pi_check = P @ pi_eigen
print(f"\n验证 Pπ = π:")
print(f"  Pπ = {pi_check}")
print(f"  π  = {pi_eigen}")
print(f"  相等: {np.allclose(pi_check, pi_eigen)}")
```

---

## 七、速记口诀

> 特征方程定根源  
> 和为迹来积为行列式  
> 对称矩阵必对角化  
> 不同特征值向量正交

---

## 八、高频考点

| 考点 | 频率 | 难度 |
|------|------|------|
| 特征值计算 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| 特征向量求解 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| 对角化判定 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| 特征值性质 | ⭐⭐⭐⭐ | ⭐⭐ |
| 实对称矩阵 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ |

---

**本章重点**：
- 特征方程是核心
- 性质用于快速计算
- 实对称矩阵特殊重要
- 对角化应用广泛

**下一章**：二次型
