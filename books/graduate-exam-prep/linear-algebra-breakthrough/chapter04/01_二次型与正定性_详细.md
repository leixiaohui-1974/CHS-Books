# 第4章：二次型与正定性判别

**学习时间**: 4小时  
**难度**: ⭐⭐⭐⭐⭐  
**考试权重**: 15%  
**必考题型**: ⭐⭐⭐⭐⭐

---

## 一、二次型基本概念

### 1.1 定义

**二次型**：n个变量的二次齐次多项式

$$f(x_1, x_2, ..., x_n) = \sum_{i=1}^{n}\sum_{j=1}^{n}a_{ij}x_ix_j$$

**矩阵表示**：
$$f = \mathbf{x}^T A \mathbf{x}$$

其中 $A$ 为对称矩阵（$a_{ij} = a_{ji}$）

### 1.2 标准形

通过可逆线性变换 $\mathbf{x} = P\mathbf{y}$，化为：

$$f = \lambda_1 y_1^2 + \lambda_2 y_2^2 + \cdots + \lambda_n y_n^2$$

**规范形**：系数只为 1, -1, 0

$$f = y_1^2 + \cdots + y_p^2 - y_{p+1}^2 - \cdots - y_{p+q}^2$$

**惯性定理**：正负项数（p, q）唯一确定，称为**惯性指数**

---

## 二、二次型化标准形

### 2.1 配方法

**步骤**：
1. 若有平方项，配方
2. 若无平方项，先做变换产生平方项
3. 逐步消去交叉项

**示例**：
$$f = x_1^2 + 2x_1x_2 + 4x_2^2$$

配方：
$$= (x_1 + x_2)^2 - x_2^2 + 4x_2^2$$
$$= (x_1 + x_2)^2 + 3x_2^2$$

令 $y_1 = x_1 + x_2$，$y_2 = x_2$

得：$f = y_1^2 + 3y_2^2$

### 2.2 正交变换法

**步骤**：
1. 求矩阵 $A$ 的特征值 $\lambda_i$
2. 求对应的特征向量并正交化、单位化
3. 构造正交矩阵 $P$
4. $f = \lambda_1 y_1^2 + \lambda_2 y_2^2 + \cdots$

### Python实现

```python
import numpy as np
import sympy as sp
from scipy.linalg import eig
import matplotlib.pyplot as plt

class QuadraticForm:
    """
    二次型分析
    """
    
    def __init__(self, A):
        """
        参数:
            A: 对称矩阵
        """
        self.A = np.array(A)
        
        # 确保对称
        if not np.allclose(self.A, self.A.T):
            print("警告: 矩阵不对称，取对称部分")
            self.A = (self.A + self.A.T) / 2
        
        self.n = self.A.shape[0]
    
    def orthogonal_transformation(self):
        """
        正交变换法化标准形
        
        返回:
            特征值, 正交矩阵P
        """
        # 求特征值和特征向量
        eigenvalues, eigenvectors = np.linalg.eig(self.A)
        
        # 排序（从大到小）
        idx = eigenvalues.argsort()[::-1]
        eigenvalues = eigenvalues[idx]
        eigenvectors = eigenvectors[:, idx]
        
        # 正交矩阵
        P = eigenvectors
        
        # 验证：P^T A P = Λ
        D = P.T @ self.A @ P
        
        return eigenvalues, P, D
    
    def canonical_form(self, eigenvalues):
        """
        规范形
        
        返回:
            正惯性指数p, 负惯性指数q
        """
        p = np.sum(eigenvalues > 1e-10)  # 正特征值个数
        q = np.sum(eigenvalues < -1e-10)  # 负特征值个数
        
        return p, q
    
    def definiteness(self, eigenvalues):
        """
        正定性判别
        
        返回:
            定性类型
        """
        positive = np.all(eigenvalues > 1e-10)
        negative = np.all(eigenvalues < -1e-10)
        non_negative = np.all(eigenvalues >= -1e-10)
        non_positive = np.all(eigenvalues <= 1e-10)
        
        if positive:
            return "正定"
        elif negative:
            return "负定"
        elif non_negative and not positive:
            return "半正定"
        elif non_positive and not negative:
            return "半负定"
        else:
            return "不定"
    
    def leading_principal_minors(self):
        """
        顺序主子式
        
        返回:
            主子式列表
        """
        minors = []
        
        for k in range(1, self.n + 1):
            submatrix = self.A[:k, :k]
            minor = np.linalg.det(submatrix)
            minors.append(minor)
        
        return minors
    
    def sylvester_criterion(self):
        """
        Sylvester判别法（正定性）
        
        返回:
            是否正定
        """
        minors = self.leading_principal_minors()
        
        # 正定：所有顺序主子式 > 0
        is_positive_definite = all(m > 1e-10 for m in minors)
        
        return is_positive_definite, minors
    
    def plot_quadratic_surface_2d(self, x_range=(-3, 3)):
        """
        绘制二次型曲面（2变量）
        """
        if self.n != 2:
            print("仅支持2维二次型可视化")
            return
        
        x = np.linspace(x_range[0], x_range[1], 100)
        y = np.linspace(x_range[0], x_range[1], 100)
        X, Y = np.meshgrid(x, y)
        
        # 计算二次型值
        Z = np.zeros_like(X)
        for i in range(X.shape[0]):
            for j in range(X.shape[1]):
                vec = np.array([X[i, j], Y[i, j]])
                Z[i, j] = vec @ self.A @ vec
        
        # 绘图
        fig = plt.figure(figsize=(14, 5))
        
        # 3D曲面
        ax1 = fig.add_subplot(121, projection='3d')
        surf = ax1.plot_surface(X, Y, Z, cmap='viridis', alpha=0.8)
        ax1.set_xlabel('$x_1$')
        ax1.set_ylabel('$x_2$')
        ax1.set_zlabel('$f(x_1, x_2)$')
        ax1.set_title('二次型曲面')
        plt.colorbar(surf, ax=ax1, shrink=0.5)
        
        # 等高线
        ax2 = fig.add_subplot(122)
        contour = ax2.contour(X, Y, Z, levels=20)
        ax2.clabel(contour, inline=True, fontsize=8)
        ax2.set_xlabel('$x_1$')
        ax2.set_ylabel('$x_2$')
        ax2.set_title('等高线图')
        ax2.grid(True, alpha=0.3)
        ax2.axis('equal')
        
        plt.tight_layout()
        plt.savefig('quadratic_form_surface.png', dpi=300, bbox_inches='tight')
        plt.show()


# 示例1：正交变换法
print("="*60)
print("示例1：正交变换法化标准形")
print("="*60)

A = np.array([
    [2, -2, 0],
    [-2, 5, -2],
    [0, -2, 2]
])

qf = QuadraticForm(A)

print("矩阵A:")
print(A)

# 正交变换
eigenvalues, P, D = qf.orthogonal_transformation()

print(f"\n特征值: {eigenvalues}")
print(f"\n正交矩阵P:")
print(P)

print(f"\n对角矩阵D = P^T A P:")
print(np.diag(eigenvalues))

# 标准形
print(f"\n标准形:")
print(f"f = {eigenvalues[0]:.4f}y₁² + {eigenvalues[1]:.4f}y₂² + {eigenvalues[2]:.4f}y₃²")

# 规范形
p, q = qf.canonical_form(eigenvalues)
print(f"\n规范形:")
print(f"f = y₁² + ... + y_{p}² - y_{p+1}² - ... - y_{p+q}²")
print(f"正惯性指数: p = {p}")
print(f"负惯性指数: q = {q}")

# 正定性
definiteness = qf.definiteness(eigenvalues)
print(f"\n正定性: {definiteness}")

# 示例2：Sylvester判别法
print("\n" + "="*60)
print("示例2：Sylvester判别法")
print("="*60)

A2 = np.array([
    [2, 1],
    [1, 3]
])

qf2 = QuadraticForm(A2)

print("矩阵A:")
print(A2)

is_pd, minors = qf2.sylvester_criterion()

print("\n顺序主子式:")
for k, minor in enumerate(minors, 1):
    print(f"  D_{k} = {minor:.4f}")

print(f"\n判别结果: {'正定' if is_pd else '不是正定'}")

# 验证
eigenvalues2, _, _ = qf2.orthogonal_transformation()
print(f"特征值验证: {eigenvalues2}")

# 可视化
qf2.plot_quadratic_surface_2d()

# 示例3：配方法（符号计算）
print("\n" + "="*60)
print("示例3：配方法")
print("="*60)

x1, x2 = sp.symbols('x1 x2')

f = x1**2 + 2*x1*x2 + 4*x2**2

print(f"二次型: f = {f}")

# 配方
f_completed = (x1 + x2)**2 + 3*x2**2

print(f"配方后: f = {f_completed}")

# 验证
f_expanded = sp.expand(f_completed)
print(f"展开验证: {f_expanded}")
print(f"相等: {sp.simplify(f - f_expanded) == 0}")

# 变换
print("\n线性变换:")
print("  y₁ = x₁ + x₂")
print("  y₂ = x₂")
print("\n标准形: f = y₁² + 3y₂²")
```

---

## 三、正定性判别

### 3.1 定义

**正定**：对任意非零向量 $\mathbf{x}$，有 $\mathbf{x}^T A \mathbf{x} > 0$

**负定**：$\mathbf{x}^T A \mathbf{x} < 0$

**半正定**：$\mathbf{x}^T A \mathbf{x} \geq 0$

### 3.2 判别方法

| 方法 | 正定条件 |
|------|---------|
| **特征值法** | 所有特征值 > 0 |
| **顺序主子式法** | 所有顺序主子式 > 0 |
| **惯性指数法** | p = n, q = 0 |

**Sylvester判别法**（最常用）：

矩阵 $A$ 正定 ⇔ 所有顺序主子式 > 0

即：
$$D_1 = a_{11} > 0$$
$$D_2 = \begin{vmatrix} a_{11} & a_{12} \\ a_{21} & a_{22} \end{vmatrix} > 0$$
$$\vdots$$
$$D_n = |A| > 0$$

---

## 四、典型考题

### 考题1：化标准形

**【题目】**用正交变换化二次型为标准形
$$f = x_1^2 + 2x_2^2 + 2x_3^2 + 2x_1x_2 - 2x_2x_3$$

**【解答】**

矩阵：
$$A = \begin{bmatrix} 1 & 1 & 0 \\ 1 & 2 & -1 \\ 0 & -1 & 2 \end{bmatrix}$$

特征方程：$|A - \lambda I| = 0$

特征值：$\lambda_1 = 3$，$\lambda_2 = 2$，$\lambda_3 = 0$

**标准形**：$f = 3y_1^2 + 2y_2^2$

---

### 考题2：判别正定性

**【题目】**判别矩阵正定性
$$A = \begin{bmatrix} 2 & -1 & 0 \\ -1 & 2 & -1 \\ 0 & -1 & 2 \end{bmatrix}$$

**【解答】**

顺序主子式：
- $D_1 = 2 > 0$ ✓
- $D_2 = \begin{vmatrix} 2 & -1 \\ -1 & 2 \end{vmatrix} = 3 > 0$ ✓
- $D_3 = |A| = 4 > 0$ ✓

**结论**：**正定矩阵**

---

### 考题3：求参数范围

**【题目】**求 $a$ 的取值范围，使
$$A = \begin{bmatrix} 1 & a & 0 \\ a & 2 & 0 \\ 0 & 0 & 3 \end{bmatrix}$$
正定

**【解答】**

顺序主子式：
- $D_1 = 1 > 0$ ✓
- $D_2 = 2 - a^2 > 0$ ⇒ $-\sqrt{2} < a < \sqrt{2}$
- $D_3 = 3(2 - a^2) > 0$ ⇒ $-\sqrt{2} < a < \sqrt{2}$

**答案**：$-\sqrt{2} < a < \sqrt{2}$

---

## 五、速记口诀

> 二次型化标准形两法  
> 配方法快但要技巧  
> 正交变换最稳妥  
> 正定判别看主子式

---

## 六、应用：最优化

```python
class QuadraticOptimization:
    """
    二次型优化应用
    """
    
    @staticmethod
    def constrained_minimum(A, constraint_type='unit_sphere'):
        """
        约束条件下的二次型极值
        
        min x^T A x, s.t. ||x|| = 1
        
        解：最小特征值
        """
        eigenvalues, eigenvectors = np.linalg.eig(A)
        
        min_idx = np.argmin(eigenvalues)
        min_value = eigenvalues[min_idx]
        min_vector = eigenvectors[:, min_idx]
        
        return min_value, min_vector


# 优化示例
print("\n" + "="*60)
print("应用：约束优化")
print("="*60)

A_opt = np.array([
    [5, 2],
    [2, 2]
])

optimizer = QuadraticOptimization()
min_val, min_vec = optimizer.constrained_minimum(A_opt)

print(f"最小化 x^T A x, s.t. ||x|| = 1")
print(f"\n矩阵A:")
print(A_opt)
print(f"\n最小值: {min_val:.4f}")
print(f"最优解: {min_vec}")

# 验证
print(f"\n验证: x^T A x = {min_vec @ A_opt @ min_vec:.4f}")
print(f"验证: ||x|| = {np.linalg.norm(min_vec):.4f}")
```

---

**本章重点**：
- 正交变换化标准形
- Sylvester判别正定
- 惯性指数应用
- 配方法技巧

**下一章**：向量空间与线性变换
