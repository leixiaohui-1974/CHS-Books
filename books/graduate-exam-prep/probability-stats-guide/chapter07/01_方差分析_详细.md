# 第7章：方差分析

**学习时间**: 4小时  
**考试频率**: ⭐⭐⭐⭐  
**难度**: ⭐⭐⭐⭐⭐

---

## 一、方差分析基本原理

### 1.1 问题提出

**多组比较**：比较$k$个总体均值是否相等

$$H_0: \mu_1 = \mu_2 = \cdots = \mu_k$$

**为何不用多次t检验**：
- 增大第一类错误概率
- 若做$\binom{k}{2}$次检验，总错误率$\gg \alpha$

### 1.2 基本思想

**平方和分解**：

$$SS_T = SS_A + SS_E$$

- $SS_T$：总平方和（总变异）
- $SS_A$：组间平方和（因素引起）
- $SS_E$：组内平方和（随机误差）

**F统计量**：

$$F = \frac{MS_A}{MS_E} = \frac{SS_A/(k-1)}{SS_E/(n-k)}$$

若$H_0$成立，$F \sim F(k-1, n-k)$

---

## 二、单因素方差分析

### 2.1 数学模型

**数据结构**：

| 组别 | 1 | 2 | $\cdots$ | $k$ |
|------|---|---|----------|-----|
| 数据 | $X_{11}, X_{12}, \ldots, X_{1n_1}$ | $X_{21}, \ldots, X_{2n_2}$ | $\cdots$ | $X_{k1}, \ldots, X_{kn_k}$ |

**模型**：

$$X_{ij} = \mu + \alpha_i + \varepsilon_{ij}$$

- $\mu$：总均值
- $\alpha_i$：第$i$组效应
- $\varepsilon_{ij} \sim N(0, \sigma^2)$

### 2.2 平方和计算

**(1) 总平方和**：

$$SS_T = \sum_{i=1}^k \sum_{j=1}^{n_i} (X_{ij} - \bar{X})^2$$

**(2) 组间平方和**：

$$SS_A = \sum_{i=1}^k n_i (\bar{X}_i - \bar{X})^2$$

**(3) 组内平方和**：

$$SS_E = \sum_{i=1}^k \sum_{j=1}^{n_i} (X_{ij} - \bar{X}_i)^2$$

**简化公式**：

$$SS_T = \sum_{i,j} X_{ij}^2 - \frac{T^2}{n}$$

$$SS_A = \sum_{i=1}^k \frac{T_i^2}{n_i} - \frac{T^2}{n}$$

$$SS_E = SS_T - SS_A$$

其中$T = \sum_{i,j} X_{ij}$，$T_i = \sum_j X_{ij}$

### 2.3 方差分析表

| 来源 | 平方和 | 自由度 | 均方 | F值 |
|------|--------|--------|------|-----|
| 组间（因素A） | $SS_A$ | $k-1$ | $MS_A = \frac{SS_A}{k-1}$ | $F = \frac{MS_A}{MS_E}$ |
| 组内（误差） | $SS_E$ | $n-k$ | $MS_E = \frac{SS_E}{n-k}$ | - |
| 总计 | $SS_T$ | $n-1$ | - | - |

**判断**：若$F > F_\alpha(k-1, n-k)$，拒绝$H_0$

---

## 三、双因素方差分析

### 3.1 无交互作用

**数据结构**（每格一个观测）：

| 因素B \ 因素A | $A_1$ | $A_2$ | $\cdots$ | $A_r$ |
|---------------|-------|-------|----------|-------|
| $B_1$ | $X_{11}$ | $X_{12}$ | $\cdots$ | $X_{1r}$ |
| $B_2$ | $X_{21}$ | $X_{22}$ | $\cdots$ | $X_{2r}$ |
| $\vdots$ | $\vdots$ | $\vdots$ | $\ddots$ | $\vdots$ |
| $B_s$ | $X_{s1}$ | $X_{s2}$ | $\cdots$ | $X_{sr}$ |

**模型**：

$$X_{ij} = \mu + \alpha_i + \beta_j + \varepsilon_{ij}$$

**平方和分解**：

$$SS_T = SS_A + SS_B + SS_E$$

- $SS_A$：因素A平方和
- $SS_B$：因素B平方和
- $SS_E$：误差平方和

**计算**：

$$SS_A = s \sum_{i=1}^r (\bar{X}_{i.} - \bar{X})^2 = \frac{1}{s}\sum_{i=1}^r T_{i.}^2 - \frac{T^2}{rs}$$

$$SS_B = r \sum_{j=1}^s (\bar{X}_{.j} - \bar{X})^2 = \frac{1}{r}\sum_{j=1}^s T_{.j}^2 - \frac{T^2}{rs}$$

### 3.2 有交互作用

**数据结构**（每格$m$个观测）

**模型**：

$$X_{ijk} = \mu + \alpha_i + \beta_j + (\alpha\beta)_{ij} + \varepsilon_{ijk}$$

**平方和分解**：

$$SS_T = SS_A + SS_B + SS_{A×B} + SS_E$$

- $SS_{A×B}$：交互作用平方和

---

## 四、Python实现

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
import pandas as pd

class ANOVA:
    """方差分析"""
    
    def __init__(self, alpha=0.05):
        self.alpha = alpha
    
    def one_way_anova(self, *groups):
        """
        单因素方差分析
        
        参数:
            *groups: 多组数据（每组为一个数组）
        """
        k = len(groups)  # 组数
        n_i = [len(group) for group in groups]
        n = sum(n_i)  # 总样本量
        
        # 总均值
        all_data = np.concatenate(groups)
        grand_mean = np.mean(all_data)
        
        # 各组均值
        group_means = [np.mean(group) for group in groups]
        
        # 总平方和
        SS_T = np.sum((all_data - grand_mean)**2)
        
        # 组间平方和
        SS_A = sum(n_i[i] * (group_means[i] - grand_mean)**2 for i in range(k))
        
        # 组内平方和
        SS_E = SS_T - SS_A
        
        # 自由度
        df_A = k - 1
        df_E = n - k
        df_T = n - 1
        
        # 均方
        MS_A = SS_A / df_A
        MS_E = SS_E / df_E
        
        # F统计量
        F = MS_A / MS_E
        
        # p值
        p_value = 1 - stats.f.cdf(F, df_A, df_E)
        
        # 临界值
        F_critical = stats.f.ppf(1 - self.alpha, df_A, df_E)
        
        # 判断
        reject_H0 = F > F_critical
        
        # 方差分析表
        anova_table = pd.DataFrame({
            '来源': ['组间（因素）', '组内（误差）', '总计'],
            '平方和': [SS_A, SS_E, SS_T],
            '自由度': [df_A, df_E, df_T],
            '均方': [MS_A, MS_E, np.nan],
            'F值': [F, np.nan, np.nan],
            'p值': [p_value, np.nan, np.nan]
        })
        
        return {
            'F_statistic': F,
            'p_value': p_value,
            'F_critical': F_critical,
            'reject_H0': reject_H0,
            'anova_table': anova_table,
            'SS_A': SS_A,
            'SS_E': SS_E,
            'SS_T': SS_T,
            'group_means': group_means,
            'grand_mean': grand_mean
        }
    
    def two_way_anova_no_interaction(self, data):
        """
        双因素方差分析（无交互作用）
        
        参数:
            data: 二维数组，shape=(s, r)
                 行表示因素B的水平，列表示因素A的水平
        """
        data = np.array(data)
        s, r = data.shape  # s行r列
        n = s * r
        
        # 总均值
        grand_mean = np.mean(data)
        
        # 行均值（因素B）
        row_means = np.mean(data, axis=1)
        
        # 列均值（因素A）
        col_means = np.mean(data, axis=0)
        
        # 总平方和
        SS_T = np.sum((data - grand_mean)**2)
        
        # 因素A平方和
        SS_A = s * np.sum((col_means - grand_mean)**2)
        
        # 因素B平方和
        SS_B = r * np.sum((row_means - grand_mean)**2)
        
        # 误差平方和
        SS_E = SS_T - SS_A - SS_B
        
        # 自由度
        df_A = r - 1
        df_B = s - 1
        df_E = (r - 1) * (s - 1)
        df_T = n - 1
        
        # 均方
        MS_A = SS_A / df_A
        MS_B = SS_B / df_B
        MS_E = SS_E / df_E
        
        # F统计量
        F_A = MS_A / MS_E
        F_B = MS_B / MS_E
        
        # p值
        p_A = 1 - stats.f.cdf(F_A, df_A, df_E)
        p_B = 1 - stats.f.cdf(F_B, df_B, df_E)
        
        # 方差分析表
        anova_table = pd.DataFrame({
            '来源': ['因素A', '因素B', '误差', '总计'],
            '平方和': [SS_A, SS_B, SS_E, SS_T],
            '自由度': [df_A, df_B, df_E, df_T],
            '均方': [MS_A, MS_B, MS_E, np.nan],
            'F值': [F_A, F_B, np.nan, np.nan],
            'p值': [p_A, p_B, np.nan, np.nan]
        })
        
        return {
            'F_A': F_A,
            'F_B': F_B,
            'p_A': p_A,
            'p_B': p_B,
            'anova_table': anova_table
        }
    
    def plot_anova_visualization(self, *groups):
        """绘制方差分析可视化"""
        fig, axes = plt.subplots(2, 2, figsize=(16, 12))
        
        # 1. 各组数据分布
        ax1 = axes[0, 0]
        
        positions = range(1, len(groups) + 1)
        bp = ax1.boxplot(groups, positions=positions, widths=0.6,
                         patch_artist=True, showmeans=True)
        
        # 美化箱线图
        colors = plt.cm.Set3(np.linspace(0, 1, len(groups)))
        for patch, color in zip(bp['boxes'], colors):
            patch.set_facecolor(color)
        
        # 添加散点
        for i, group in enumerate(groups):
            x = np.random.normal(i + 1, 0.04, size=len(group))
            ax1.scatter(x, group, alpha=0.5, s=30, color='black')
        
        ax1.set_xlabel('组别', fontsize=11)
        ax1.set_ylabel('数值', fontsize=11)
        ax1.set_title('各组数据分布', fontsize=13, fontweight='bold')
        ax1.set_xticklabels([f'组{i+1}' for i in range(len(groups))])
        ax1.grid(True, alpha=0.3, axis='y')
        
        # 2. 组内、组间变异示意
        ax2 = axes[0, 1]
        
        # 示例数据
        group1 = np.array([8, 9, 10, 11, 12])
        group2 = np.array([12, 13, 14, 15, 16])
        group3 = np.array([16, 17, 18, 19, 20])
        
        all_groups = [group1, group2, group3]
        
        for i, group in enumerate(all_groups):
            x = np.ones(len(group)) * (i + 1)
            ax2.scatter(x, group, s=100, alpha=0.7, label=f'组{i+1}')
            
            # 组均值
            group_mean = np.mean(group)
            ax2.plot([i + 0.8, i + 1.2], [group_mean, group_mean],
                    'r-', linewidth=3)
            
            # 组内变异（垂直线）
            for val in group:
                ax2.plot([i + 1, i + 1], [val, group_mean],
                        'b--', alpha=0.3, linewidth=1.5)
        
        # 总均值
        grand_mean = np.mean(np.concatenate(all_groups))
        ax2.axhline(grand_mean, color='green', linestyle='-',
                   linewidth=2.5, label='总均值', alpha=0.7)
        
        # 组间变异（水平箭头）
        for i, group in enumerate(all_groups):
            group_mean = np.mean(group)
            ax2.annotate('', xy=(i + 1.3, grand_mean),
                        xytext=(i + 1.3, group_mean),
                        arrowprops=dict(arrowstyle='<->', color='red', lw=2))
        
        ax2.text(3.7, (np.mean(group3) + grand_mean) / 2,
                '组间\n变异', fontsize=10, color='red', weight='bold')
        ax2.text(1.5, np.mean(group1) + 0.5,
                '组内变异', fontsize=10, color='blue', weight='bold')
        
        ax2.set_xlabel('组别', fontsize=11)
        ax2.set_ylabel('数值', fontsize=11)
        ax2.set_title('组内变异 vs 组间变异', fontsize=13, fontweight='bold')
        ax2.set_xlim([0.5, 4])
        ax2.legend()
        ax2.grid(True, alpha=0.3, axis='y')
        
        # 3. F分布与拒绝域
        ax3 = axes[1, 0]
        
        df1, df2 = 3, 20
        x_f = np.linspace(0, 6, 1000)
        y_f = stats.f.pdf(x_f, df1, df2)
        
        ax3.plot(x_f, y_f, 'b-', linewidth=2.5, label=f'F({df1}, {df2})')
        
        # 临界值
        F_crit = stats.f.ppf(1 - 0.05, df1, df2)
        
        # 拒绝域
        x_reject = x_f[x_f > F_crit]
        ax3.fill_between(x_reject, 0, stats.f.pdf(x_reject, df1, df2),
                        alpha=0.3, color='red', label=f'拒绝域（α=0.05）')
        
        ax3.axvline(F_crit, color='r', linestyle='--', linewidth=2,
                   label=f'临界值={F_crit:.2f}')
        
        ax3.set_xlabel('F值', fontsize=11)
        ax3.set_ylabel('概率密度', fontsize=11)
        ax3.set_title(f'F分布拒绝域', fontsize=13, fontweight='bold')
        ax3.legend()
        ax3.grid(True, alpha=0.3)
        
        # 4. 多重比较示意
        ax4 = axes[1, 1]
        
        # 示例：LSD多重比较
        group_names = ['A', 'B', 'C', 'D']
        means = [10, 12, 15, 18]
        se = 0.8  # 标准误
        lsd = 2.5  # LSD临界值
        
        # 绘制均值和误差棒
        x_pos = np.arange(len(group_names))
        bars = ax4.bar(x_pos, means, alpha=0.7, color=colors[:len(means)],
                      edgecolor='black', linewidth=2)
        ax4.errorbar(x_pos, means, yerr=se*1.96, fmt='none',
                    ecolor='black', capsize=5, linewidth=2)
        
        # 添加显著性标记
        # AB不显著，AC显著，AD显著
        pairs = [(0, 1, 'ns'), (0, 2, '*'), (0, 3, '**')]
        y_max = max(means) + se * 2
        
        for i, (idx1, idx2, sig) in enumerate(pairs):
            y = y_max + i * 1.5
            ax4.plot([idx1, idx2], [y, y], 'k-', linewidth=1.5)
            ax4.text((idx1 + idx2) / 2, y + 0.3, sig,
                    ha='center', fontsize=14, weight='bold')
        
        ax4.set_xticks(x_pos)
        ax4.set_xticklabels(group_names)
        ax4.set_xlabel('组别', fontsize=11)
        ax4.set_ylabel('均值', fontsize=11)
        ax4.set_title('多重比较结果\nns: 不显著, *: p<0.05, **: p<0.01',
                     fontsize=13, fontweight='bold')
        ax4.grid(True, alpha=0.3, axis='y')
        
        plt.tight_layout()
        plt.savefig('anova_visualization.png', dpi=300)
        plt.show()

# 示例计算
print("="*60)
print("方差分析")
print("="*60)

anova = ANOVA(alpha=0.05)

# 1. 单因素方差分析
print("1. 单因素方差分析:")
print("  比较三种饲料对猪增重的影响（kg）\n")

feed_A = np.array([25, 28, 30, 27, 29])
feed_B = np.array([30, 32, 35, 33, 31])
feed_C = np.array([22, 24, 26, 23, 25])

print(f"  饲料A: {feed_A}")
print(f"  饲料B: {feed_B}")
print(f"  饲料C: {feed_C}")

result_oneway = anova.one_way_anova(feed_A, feed_B, feed_C)

print(f"\n方差分析表:")
print(result_oneway['anova_table'].to_string(index=False))

print(f"\nF统计量 = {result_oneway['F_statistic']:.3f}")
print(f"p值 = {result_oneway['p_value']:.4f}")
print(f"临界值 F₀.₀₅({result_oneway['anova_table']['自由度'][0]}, "
      f"{result_oneway['anova_table']['自由度'][1]}) = {result_oneway['F_critical']:.3f}")
print(f"结论: {'拒绝H₀' if result_oneway['reject_H0'] else '接受H₀'}")

if result_oneway['reject_H0']:
    print("  → 三种饲料效果有显著差异")
else:
    print("  → 三种饲料效果无显著差异")

# 2. 双因素方差分析
print("\n" + "="*60)
print("2. 双因素方差分析（无交互作用）:")
print("  研究品种（因素A）和地块（因素B）对小麦产量的影响\n")

# 数据：行=地块，列=品种
data_2way = np.array([
    [28, 30, 32],  # 地块1
    [26, 29, 31],  # 地块2
    [30, 32, 35],  # 地块3
    [27, 31, 33]   # 地块4
])

print("产量数据（行=地块，列=品种）:")
print(pd.DataFrame(data_2way, 
                  index=['地块1', '地块2', '地块3', '地块4'],
                  columns=['品种1', '品种2', '品种3']))

result_twoway = anova.two_way_anova_no_interaction(data_2way)

print(f"\n方差分析表:")
print(result_twoway['anova_table'].to_string(index=False))

print(f"\n因素A（品种）:")
print(f"  F_A = {result_twoway['F_A']:.3f}")
print(f"  p_A = {result_twoway['p_A']:.4f}")
if result_twoway['p_A'] < 0.05:
    print("  → 品种对产量有显著影响 ✓")
else:
    print("  → 品种对产量无显著影响")

print(f"\n因素B（地块）:")
print(f"  F_B = {result_twoway['F_B']:.3f}")
print(f"  p_B = {result_twoway['p_B']:.4f}")
if result_twoway['p_B'] < 0.05:
    print("  → 地块对产量有显著影响 ✓")
else:
    print("  → 地块对产量无显著影响")

# 绘图
print("\n绘制方差分析可视化图...")
anova.plot_anova_visualization(feed_A, feed_B, feed_C)
```

---

## 五、典型考题

### 【例题1】单因素方差分析（15分）

**题目**：三种机器生产零件，抽检产量（件）：
- 机器1：25, 28, 30, 27
- 机器2：30, 32, 35, 33
- 机器3：22, 24, 26, 23

$\alpha=0.05$，检验产量是否有差异。

**【解答】**

$n_1=n_2=n_3=4$，$n=12$

总和：$T = 335$

$$\bar{X}_1 = 27.5, \bar{X}_2 = 32.5, \bar{X}_3 = 23.75$$

$$\bar{X} = \frac{335}{12} = 27.92$$

$$SS_A = 4[(27.5-27.92)^2 + (32.5-27.92)^2 + (23.75-27.92)^2] = 154.08$$

$$SS_T = (25-27.92)^2 + \cdots + (23-27.92)^2 = 207.92$$

$$SS_E = 207.92 - 154.08 = 53.84$$

$$MS_A = \frac{154.08}{2} = 77.04, \quad MS_E = \frac{53.84}{9} = 5.98$$

$$F = \frac{77.04}{5.98} = 12.88$$

$F_{0.05}(2,9) = 4.26$

$F = 12.88 > 4.26$，拒绝$H_0$

**结论**：三种机器产量有显著差异

---

**本章重点**：
- 方差分析原理
- 平方和分解
- 方差分析表
- 双因素方差分析

**下一章**：回归分析
