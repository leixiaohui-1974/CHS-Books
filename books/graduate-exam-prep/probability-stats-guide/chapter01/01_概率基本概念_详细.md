# 第1章：概率基本概念与计算技巧

**学习时间**: 4小时  
**难度**: ⭐⭐⭐  
**考试权重**: 15%  
**必考题型**: ⭐⭐⭐⭐⭐

---

## 一、随机事件与概率

### 1.1 基本概念

**样本空间** $\Omega$：所有可能结果的集合

**随机事件** $A$：样本空间的子集

**概率** $P(A)$：事件A发生的可能性

**性质**：
1. $0 \leq P(A) \leq 1$
2. $P(\Omega) = 1$，$P(\emptyset) = 0$
3. **加法公式**：$P(A \cup B) = P(A) + P(B) - P(A \cap B)$

### 1.2 古典概型

**等可能性**：每个基本事件等可能发生

$$P(A) = \frac{A包含的基本事件数}{基本事件总数} = \frac{m}{n}$$

**排列组合**：
- 排列：$A_n^m = \frac{n!}{(n-m)!}$
- 组合：$C_n^m = \binom{n}{m} = \frac{n!}{m!(n-m)!}$

---

## 二、条件概率与独立性

### 2.1 条件概率

**定义**：在B发生的条件下A发生的概率

$$P(A|B) = \frac{P(AB)}{P(B)}, \quad P(B) > 0$$

### 2.2 乘法公式

$$P(AB) = P(B) \cdot P(A|B) = P(A) \cdot P(B|A)$$

**推广**：
$$P(A_1A_2...A_n) = P(A_1)P(A_2|A_1)P(A_3|A_1A_2)...$$

### 2.3 全概率公式

**条件**：$B_1, B_2, ..., B_n$ 为样本空间的一个划分

$$P(A) = \sum_{i=1}^{n}P(B_i)P(A|B_i)$$

### 2.4 贝叶斯公式

$$P(B_i|A) = \frac{P(B_i)P(A|B_i)}{\sum_{j=1}^{n}P(B_j)P(A|B_j)}$$

**意义**：由"果"推"因"

### 2.5 事件独立性

**定义**：$P(AB) = P(A)P(B)$

**等价条件**：
- $P(A|B) = P(A)$
- $P(B|A) = P(B)$

### Python实现

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.special import comb
from itertools import combinations, permutations

class ProbabilityCalculator:
    """
    概率计算工具
    """
    
    @staticmethod
    def classical_probability(favorable, total):
        """
        古典概型
        
        P = m/n
        """
        return favorable / total
    
    @staticmethod
    def permutation(n, m):
        """
        排列数 A_n^m
        """
        if m > n or m < 0:
            return 0
        
        result = 1
        for i in range(n, n-m, -1):
            result *= i
        
        return result
    
    @staticmethod
    def combination(n, m):
        """
        组合数 C_n^m
        """
        return comb(n, m, exact=True)
    
    @staticmethod
    def conditional_probability(P_AB, P_B):
        """
        条件概率 P(A|B) = P(AB)/P(B)
        """
        if P_B == 0:
            raise ValueError("P(B)不能为0")
        
        return P_AB / P_B
    
    @staticmethod
    def total_probability(P_B_list, P_A_given_B_list):
        """
        全概率公式
        
        P(A) = Σ P(Bi)P(A|Bi)
        
        参数:
            P_B_list: [P(B1), P(B2), ...]
            P_A_given_B_list: [P(A|B1), P(A|B2), ...]
        """
        P_A = sum(p_b * p_a_b for p_b, p_a_b 
                 in zip(P_B_list, P_A_given_B_list))
        
        return P_A
    
    @staticmethod
    def bayes_formula(P_Bi, P_A_given_Bi, P_B_list, P_A_given_B_list):
        """
        贝叶斯公式
        
        P(Bi|A) = P(Bi)P(A|Bi) / Σ P(Bj)P(A|Bj)
        
        参数:
            P_Bi: P(Bi)
            P_A_given_Bi: P(A|Bi)
            P_B_list, P_A_given_B_list: 所有划分的概率
        """
        numerator = P_Bi * P_A_given_Bi
        
        denominator = sum(p_b * p_a_b for p_b, p_a_b 
                         in zip(P_B_list, P_A_given_B_list))
        
        return numerator / denominator
    
    @staticmethod
    def simulate_classical(n_trials, n_outcomes, favorable_outcomes):
        """
        蒙特卡洛模拟古典概型
        
        参数:
            n_trials: 试验次数
            n_outcomes: 可能结果数
            favorable_outcomes: 有利结果集合
        
        返回:
            模拟概率
        """
        count = 0
        
        for _ in range(n_trials):
            outcome = np.random.randint(1, n_outcomes + 1)
            if outcome in favorable_outcomes:
                count += 1
        
        return count / n_trials


# 示例1：古典概型
print("="*60)
print("示例1：古典概型 - 掷骰子")
print("="*60)

# 投两个骰子，点数之和为7的概率
favorable = 6  # (1,6), (2,5), (3,4), (4,3), (5,2), (6,1)
total = 36     # 6×6

P_sum7 = ProbabilityCalculator.classical_probability(favorable, total)

print(f"两个骰子点数和为7的概率:")
print(f"  理论: {P_sum7:.4f} = {favorable}/{total}")

# 蒙特卡洛验证
n_simulations = 100000
count = 0

for _ in range(n_simulations):
    dice1 = np.random.randint(1, 7)
    dice2 = np.random.randint(1, 7)
    if dice1 + dice2 == 7:
        count += 1

P_sim = count / n_simulations
print(f"  模拟: {P_sim:.4f}")

# 示例2：排列组合
print("\n" + "="*60)
print("示例2：排列组合")
print("="*60)

n, m = 10, 3

A_nm = ProbabilityCalculator.permutation(n, m)
C_nm = ProbabilityCalculator.combination(n, m)

print(f"从{n}个不同元素中:")
print(f"  取{m}个排列: A_{n}^{m} = {A_nm}")
print(f"  取{m}个组合: C_{n}^{m} = {C_nm}")

# 验证：A = C × m!
import math
print(f"\n验证: A_{n}^{m} = C_{n}^{m} × {m}! = {C_nm} × {math.factorial(m)} = {C_nm * math.factorial(m)}")

# 示例3：全概率公式
print("\n" + "="*60)
print("示例3：全概率公式")
print("="*60)

# 某产品由三个工厂生产
# 工厂A: 产量50%，次品率2%
# 工厂B: 产量30%，次品率3%
# 工厂C: 产量20%，次品率4%

P_A = 0.50
P_B = 0.30
P_C = 0.20

P_D_given_A = 0.02  # P(次品|A)
P_D_given_B = 0.03
P_D_given_C = 0.04

P_B_list = [P_A, P_B, P_C]
P_D_given_B_list = [P_D_given_A, P_D_given_B, P_D_given_C]

# 任取一件产品为次品的概率
P_D = ProbabilityCalculator.total_probability(P_B_list, P_D_given_B_list)

print(f"产品来源:")
print(f"  工厂A: 产量{P_A*100}%, 次品率{P_D_given_A*100}%")
print(f"  工厂B: 产量{P_B*100}%, 次品率{P_D_given_B*100}%")
print(f"  工厂C: 产量{P_C*100}%, 次品率{P_D_given_C*100}%")

print(f"\n全概率公式:")
print(f"P(次品) = Σ P(工厂i)·P(次品|工厂i)")
print(f"        = {P_A}×{P_D_given_A} + {P_B}×{P_D_given_B} + {P_C}×{P_D_given_C}")
print(f"        = {P_D:.4f} = {P_D*100:.2f}%")

# 示例4：贝叶斯公式
print("\n" + "="*60)
print("示例4：贝叶斯公式")
print("="*60)

# 若取到次品，它来自工厂A的概率
P_A_given_D = ProbabilityCalculator.bayes_formula(
    P_A, P_D_given_A, P_B_list, P_D_given_B_list
)

P_B_given_D = ProbabilityCalculator.bayes_formula(
    P_B, P_D_given_B, P_B_list, P_D_given_B_list
)

P_C_given_D = ProbabilityCalculator.bayes_formula(
    P_C, P_D_given_C, P_B_list, P_D_given_B_list
)

print(f"若取到次品，它来自各工厂的概率:")
print(f"  P(工厂A|次品) = {P_A_given_D:.4f} = {P_A_given_D*100:.2f}%")
print(f"  P(工厂B|次品) = {P_B_given_D:.4f} = {P_B_given_D*100:.2f}%")
print(f"  P(工厂C|次品) = {P_C_given_D:.4f} = {P_C_given_D*100:.2f}%")

print(f"\n验证: {P_A_given_D + P_B_given_D + P_C_given_D:.4f} = 1.0000")

# 可视化
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# 左图：产量分布
factories = ['工厂A', '工厂B', '工厂C']
production = [P_A, P_B, P_C]

axes[0].bar(factories, production, color=['blue', 'green', 'orange'], alpha=0.7)
axes[0].set_ylabel('产量比例', fontsize=12)
axes[0].set_title('产量分布（先验概率）', fontsize=14)
axes[0].set_ylim([0, 0.6])

for i, (f, p) in enumerate(zip(factories, production)):
    axes[0].text(i, p + 0.02, f'{p*100:.0f}%', ha='center', fontsize=11)

axes[0].grid(True, alpha=0.3, axis='y')

# 右图：后验概率
posterior = [P_A_given_D, P_B_given_D, P_C_given_D]

axes[1].bar(factories, posterior, color=['blue', 'green', 'orange'], alpha=0.7)
axes[1].set_ylabel('概率', fontsize=12)
axes[1].set_title('次品来源概率（后验概率）', fontsize=14)
axes[1].set_ylim([0, 0.5])

for i, (f, p) in enumerate(zip(factories, posterior)):
    axes[1].text(i, p + 0.01, f'{p*100:.1f}%', ha='center', fontsize=11)

axes[1].grid(True, alpha=0.3, axis='y')

plt.tight_layout()
plt.savefig('bayes_example.png', dpi=300, bbox_inches='tight')
plt.show()
```

---

## 三、典型考题

### 考题1：古典概型

**【题目】**从52张扑克牌中抽5张，恰有3张A的概率？

**【解答】**

有利情况：
- 从4张A中选3张：$C_4^3 = 4$
- 从48张非A中选2张：$C_{48}^2 = 1128$
- 有利情况数：$4 \times 1128 = 4512$

总情况数：$C_{52}^5 = 2,598,960$

$$P = \frac{4512}{2,598,960} \approx 0.00174$$

---

### 考题2：全概率与贝叶斯

**【题目】**某疾病发病率1%，检验准确率：患病者阳性95%，健康者阳性5%。

求：检验阳性时，真患病的概率？

**【解答】**

设A=患病，B=阳性

已知：
- $P(A) = 0.01$，$P(\bar{A}) = 0.99$
- $P(B|A) = 0.95$，$P(B|\bar{A}) = 0.05$

**全概率**：
$$P(B) = P(A)P(B|A) + P(\bar{A})P(B|\bar{A})$$
$$= 0.01 \times 0.95 + 0.99 \times 0.05 = 0.059$$

**贝叶斯**：
$$P(A|B) = \frac{P(A)P(B|A)}{P(B)} = \frac{0.01 \times 0.95}{0.059} \approx 0.161$$

**答案**：**16.1%**

---

## 四、速记口诀

> 古典概型算比值  
> 条件概率用定义  
> 全概率公式分情况  
> 贝叶斯公式由果推因

---

**本章重点**：
- 古典概型与排列组合
- 条件概率公式
- 全概率公式应用
- 贝叶斯公式（必考）

**下一章**：随机变量及其分布
