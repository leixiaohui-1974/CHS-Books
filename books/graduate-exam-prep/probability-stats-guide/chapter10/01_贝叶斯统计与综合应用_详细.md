# 第10章：贝叶斯统计与综合应用

**学习时间**: 5小时  
**考试频率**: ⭐⭐⭐⭐⭐  
**难度**: ⭐⭐⭐⭐⭐

---

## 一、贝叶斯统计基础

### 1.1 频率派 vs 贝叶斯派

**频率派（经典统计）**：
- 参数是固定未知常数
- 概率是长期频率
- 基于大样本理论

**贝叶斯派**：
- 参数是随机变量，有分布
- 概率是主观置信度
- 利用先验信息
- 可处理小样本

### 1.2 贝叶斯公式

**基础形式**：
$$P(A|B) = \frac{P(B|A)P(A)}{P(B)}$$

**统计推断形式**：
$$P(\theta | X) = \frac{P(X|\theta)P(\theta)}{P(X)}$$

**记号**：
- $P(\theta)$：先验分布（prior）
- $P(X|\theta)$：似然函数（likelihood）
- $P(\theta|X)$：后验分布（posterior）
- $P(X) = \int P(X|\theta)P(\theta)d\theta$：边缘分布

**例题1**：某疾病患病率为0.1%。检测准确率：阳性正确率95%，阴性正确率99%。
某人检测阳性，求实际患病概率。

**解**：
记$D$：患病，$T^+$：检测阳性

已知：
- $P(D) = 0.001$
- $P(T^+|D) = 0.95$（灵敏度）
- $P(T^-|\bar{D}) = 0.99$（特异度）
- $P(T^+|\bar{D}) = 0.01$

$$P(D|T^+) = \frac{P(T^+|D)P(D)}{P(T^+)}$$

$$P(T^+) = P(T^+|D)P(D) + P(T^+|\bar{D})P(\bar{D})$$
$$= 0.95 \times 0.001 + 0.01 \times 0.999$$
$$= 0.00095 + 0.00999 = 0.01094$$

$$P(D|T^+) = \frac{0.95 \times 0.001}{0.01094} = \frac{0.00095}{0.01094} \approx 0.0868$$

**结论**：检测阳性后，实际患病概率仅8.68%

---

## 二、共轭先验

### 2.1 常见共轭对

| 似然 | 先验 | 后验 |
|------|------|------|
| 二项 $B(n,p)$ | Beta $\text{Beta}(\alpha,\beta)$ | Beta |
| 泊松 $P(\lambda)$ | Gamma $\text{Gamma}(\alpha,\beta)$ | Gamma |
| 正态 $N(\mu,\sigma^2)$（已知$\sigma^2$） | 正态 $N(\mu_0,\sigma_0^2)$ | 正态 |
| 正态 $N(\mu,\sigma^2)$（已知$\mu$） | 逆Gamma | 逆Gamma |

### 2.2 Beta-二项共轭

**模型**：
- 先验：$p \sim \text{Beta}(\alpha, \beta)$
- 似然：$X \sim B(n, p)$，观测到$x$次成功
- 后验：$p|X \sim \text{Beta}(\alpha+x, \beta+n-x)$

**例题2**：投硬币，先验认为正面概率$p \sim \text{Beta}(2,2)$。
投10次，得到7次正面。求后验分布和均值。

**解**：
先验：$p \sim \text{Beta}(2, 2)$

观测：$n=10, x=7$

后验：$p|X \sim \text{Beta}(2+7, 2+10-7) = \text{Beta}(9, 5)$

后验均值：
$$E[p|X] = \frac{9}{9+5} = \frac{9}{14} \approx 0.643$$

（相比MLE：$\hat{p}_{MLE} = 7/10 = 0.7$，贝叶斯估计向先验均值0.5收缩）

---

### 2.3 Gamma-泊松共轭

**模型**：
- 先验：$\lambda \sim \text{Gamma}(\alpha, \beta)$
- 似然：$X_i \sim P(\lambda)$，观测$n$个数据，和为$s = \sum x_i$
- 后验：$\lambda|X \sim \text{Gamma}(\alpha+s, \beta+n)$

**例题3**：某设备故障率$\lambda \sim \text{Gamma}(2, 1)$（每天）。
观测10天，共发生8次故障。求后验分布。

**解**：
先验：$\lambda \sim \text{Gamma}(2, 1)$

$$E[\lambda] = \frac{\alpha}{\beta} = \frac{2}{1} = 2$$

观测：$n=10$天，$s=8$次

后验：$\lambda|X \sim \text{Gamma}(2+8, 1+10) = \text{Gamma}(10, 11)$

后验均值：
$$E[\lambda|X] = \frac{10}{11} \approx 0.909$$

（远小于先验均值2，数据主导）

---

## 三、贝叶斯估计

### 3.1 点估计

**后验均值（Bayes估计）**：
$$\hat{\theta}_{Bayes} = E[\theta|X] = \int \theta \cdot p(\theta|X) d\theta$$

**最大后验估计（MAP）**：
$$\hat{\theta}_{MAP} = \arg\max_\theta p(\theta|X)$$

### 3.2 区间估计

**可信区间（Credible Interval）**：
$$P(\theta_L \leq \theta \leq \theta_U | X) = 1-\alpha$$

与频率派置信区间的区别：
- 可信区间：参数在此区间内的**概率**为$1-\alpha$
- 置信区间：**过程**覆盖真值的频率为$1-\alpha$

---

## 四、贝叶斯假设检验

### 4.1 贝叶斯因子

**定义**：
$$BF_{01} = \frac{P(X|H_0)}{P(X|H_1)}$$

**解释**：
- $BF_{01} > 1$：数据支持$H_0$
- $BF_{01} < 1$：数据支持$H_1$

**Kass & Raftery标准**：

| $BF_{01}$ | 证据强度 |
|-----------|----------|
| 1-3 | 不值一提 |
| 3-10 | 实质性证据 |
| 10-30 | 强证据 |
| 30-100 | 很强证据 |
| >100 | 决定性证据 |

**例题4**：两个模型预测数据的似然为：
$P(X|M_1) = 0.02$，$P(X|M_2) = 0.001$。
先验相同，计算贝叶斯因子。

**解**：
$$BF_{12} = \frac{P(X|M_1)}{P(X|M_2)} = \frac{0.02}{0.001} = 20$$

**结论**：$M_1$有"强证据"优于$M_2$

---

## 五、马尔可夫链蒙特卡洛（MCMC）

### 5.1 MCMC原理

**目的**：从复杂后验分布$p(\theta|X)$中抽样

**核心思想**：
构造马尔可夫链，使其平稳分布为目标分布

### 5.2 Metropolis-Hastings算法

**步骤**：
1. 初始化$\theta^{(0)}$
2. 在第$t$步：
   - 从提议分布$q(\theta^*|\theta^{(t)})$生成候选$\theta^*$
   - 计算接受率：
   $$\alpha = \min\left(1, \frac{p(\theta^*|X) q(\theta^{(t)}|\theta^*)}{p(\theta^{(t)}|X) q(\theta^*|\theta^{(t)})}\right)$$
   - 以概率$\alpha$接受$\theta^{(t+1)} = \theta^*$，否则$\theta^{(t+1)} = \theta^{(t)}$
3. 重复至收敛

**例题5**：用MH算法从$N(0,1)$中抽样（演示）

**解**：见下方Python代码

---

### 5.3 Gibbs抽样

**适用**：多参数模型，各参数的**条件分布**已知

**步骤**：
对参数$(\theta_1, \theta_2, \ldots, \theta_p)$，在第$t$步：
1. $\theta_1^{(t+1)} \sim p(\theta_1 | \theta_2^{(t)}, \ldots, \theta_p^{(t)}, X)$
2. $\theta_2^{(t+1)} \sim p(\theta_2 | \theta_1^{(t+1)}, \theta_3^{(t)}, \ldots, \theta_p^{(t)}, X)$
3. ...
4. $\theta_p^{(t+1)} \sim p(\theta_p | \theta_1^{(t+1)}, \ldots, \theta_{p-1}^{(t+1)}, X)$

---

## 六、综合应用案例

### 案例1：水文频率分析的贝叶斯方法

**背景**：洪峰流量$Q \sim P\text{-III}(\alpha, \beta, a_0)$

**贝叶斯框架**：
- 先验：基于区域经验
- 似然：观测洪峰序列
- 后验：更新参数分布
- 预测：百年一遇洪水的可信区间

### 案例2：水质监测的贝叶斯更新

**问题**：河流某污染物浓度$\mu$未知

**数据**：
- 先验：历史数据$\mu \sim N(2.0, 0.5^2)$ mg/L
- 新采样：10次测量，$\bar{x} = 2.5$ mg/L，$s = 0.3$ mg/L

**后验计算**：
$$\mu|X \sim N\left(\frac{\frac{\mu_0}{\sigma_0^2} + \frac{n\bar{x}}{\sigma^2}}{\frac{1}{\sigma_0^2} + \frac{n}{\sigma^2}}, \left(\frac{1}{\sigma_0^2} + \frac{n}{\sigma^2}\right)^{-1}\right)$$

---

## 七、Python实现

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import beta, gamma, norm, uniform
from scipy.special import comb

class BayesianStatistics:
    """贝叶斯统计工具"""
    
    @staticmethod
    def bayesian_disease_test(prior_prob, sensitivity, specificity):
        """
        贝叶斯疾病检测
        
        参数:
            prior_prob: 先验患病率P(D)
            sensitivity: 灵敏度P(T+|D)
            specificity: 特异度P(T-|~D)
        
        返回:
            posterior_prob: 后验患病概率P(D|T+)
        """
        # P(T+)
        p_test_pos = (sensitivity * prior_prob + 
                      (1 - specificity) * (1 - prior_prob))
        
        # P(D|T+)
        posterior = (sensitivity * prior_prob) / p_test_pos
        
        return posterior
    
    @staticmethod
    def beta_binomial_conjugate(alpha_prior, beta_prior, n_trials, n_success):
        """
        Beta-二项共轭
        
        参数:
            alpha_prior, beta_prior: 先验Beta参数
            n_trials: 试验次数
            n_success: 成功次数
        
        返回:
            alpha_post, beta_post: 后验Beta参数
        """
        alpha_post = alpha_prior + n_success
        beta_post = beta_prior + n_trials - n_success
        
        return alpha_post, beta_post
    
    @staticmethod
    def gamma_poisson_conjugate(alpha_prior, beta_prior, n_obs, sum_data):
        """
        Gamma-泊松共轭
        
        参数:
            alpha_prior, beta_prior: 先验Gamma参数
            n_obs: 观测次数
            sum_data: 数据总和
        
        返回:
            alpha_post, beta_post: 后验Gamma参数
        """
        alpha_post = alpha_prior + sum_data
        beta_post = beta_prior + n_obs
        
        return alpha_post, beta_post
    
    @staticmethod
    def metropolis_hastings(target_pdf, proposal_std, n_samples, burn_in=1000):
        """
        Metropolis-Hastings算法
        
        参数:
            target_pdf: 目标分布的pdf函数
            proposal_std: 提议分布的标准差（正态分布）
            n_samples: 样本数
            burn_in: burn-in期
        
        返回:
            samples: MCMC样本
            acceptance_rate: 接受率
        """
        # 初始化
        theta_current = 0
        samples = []
        n_accept = 0
        
        for i in range(n_samples + burn_in):
            # 提议新值（对称提议）
            theta_proposed = theta_current + np.random.normal(0, proposal_std)
            
            # 计算接受率
            alpha = min(1, target_pdf(theta_proposed) / target_pdf(theta_current))
            
            # 接受/拒绝
            if np.random.rand() < alpha:
                theta_current = theta_proposed
                n_accept += 1
            
            # 去除burn-in
            if i >= burn_in:
                samples.append(theta_current)
        
        acceptance_rate = n_accept / (n_samples + burn_in)
        
        return np.array(samples), acceptance_rate
    
    @staticmethod
    def plot_bayesian_update():
        """可视化贝叶斯更新"""
        fig, axes = plt.subplots(2, 2, figsize=(14, 10))
        
        # 1. 疾病检测
        ax1 = axes[0, 0]
        
        prior_probs = np.linspace(0.0001, 0.01, 100)
        posteriors = [BayesianStatistics.bayesian_disease_test(p, 0.95, 0.99)
                     for p in prior_probs]
        
        ax1.plot(prior_probs * 100, np.array(posteriors) * 100,
                linewidth=2, color='darkblue')
        ax1.axhline(5, color='red', linestyle='--', linewidth=1.5,
                   label='5%决策阈值')
        ax1.set_xlabel('先验患病率 (%)', fontsize=11)
        ax1.set_ylabel('后验患病率（检测阳性后） (%)', fontsize=11)
        ax1.set_title('贝叶斯疾病检测', fontsize=12, fontweight='bold')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # 2. Beta-二项共轭
        ax2 = axes[0, 1]
        
        p = np.linspace(0, 1, 1000)
        
        # 先验
        prior = beta.pdf(p, 2, 2)
        ax2.plot(p, prior, label='先验 Beta(2,2)', linewidth=2,
                color='blue', linestyle='--')
        
        # 后验（7/10次成功）
        posterior = beta.pdf(p, 9, 5)
        ax2.plot(p, posterior, label='后验 Beta(9,5)', linewidth=2,
                color='red')
        
        # MLE
        ax2.axvline(0.7, color='green', linestyle=':', linewidth=2,
                   label='MLE = 0.7')
        
        # 后验均值
        post_mean = 9 / 14
        ax2.axvline(post_mean, color='orange', linestyle=':', linewidth=2,
                   label=f'后验均值 = {post_mean:.3f}')
        
        ax2.fill_between(p, posterior, alpha=0.3, color='red')
        
        ax2.set_xlabel('概率 p', fontsize=11)
        ax2.set_ylabel('密度', fontsize=11)
        ax2.set_title('Beta-二项共轭更新', fontsize=12, fontweight='bold')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        
        # 3. Gamma-泊松共轭
        ax3 = axes[1, 0]
        
        lam = np.linspace(0, 5, 1000)
        
        # 先验
        prior_gamma = gamma.pdf(lam, 2, scale=1)
        ax3.plot(lam, prior_gamma, label='先验 Gamma(2,1)', linewidth=2,
                color='blue', linestyle='--')
        
        # 后验（10天8次）
        posterior_gamma = gamma.pdf(lam, 10, scale=1/11)
        ax3.plot(lam, posterior_gamma, label='后验 Gamma(10,11)', linewidth=2,
                color='red')
        
        # MLE
        mle = 8 / 10
        ax3.axvline(mle, color='green', linestyle=':', linewidth=2,
                   label=f'MLE = {mle:.2f}')
        
        # 后验均值
        post_mean_gamma = 10 / 11
        ax3.axvline(post_mean_gamma, color='orange', linestyle=':', linewidth=2,
                   label=f'后验均值 = {post_mean_gamma:.3f}')
        
        ax3.fill_between(lam, posterior_gamma, alpha=0.3, color='red')
        
        ax3.set_xlabel('速率 λ (次/天)', fontsize=11)
        ax3.set_ylabel('密度', fontsize=11)
        ax3.set_title('Gamma-泊松共轭更新', fontsize=12, fontweight='bold')
        ax3.legend()
        ax3.grid(True, alpha=0.3)
        
        # 4. MCMC抽样
        ax4 = axes[1, 1]
        
        # 目标：标准正态分布
        target_pdf = lambda x: norm.pdf(x, 0, 1)
        
        samples, acc_rate = BayesianStatistics.metropolis_hastings(
            target_pdf, proposal_std=2.0, n_samples=10000, burn_in=1000
        )
        
        # 绘制样本直方图
        ax4.hist(samples, bins=50, density=True, alpha=0.6,
                edgecolor='black', label=f'MCMC样本\n接受率={acc_rate:.2f}')
        
        # 叠加真实分布
        x_true = np.linspace(-4, 4, 1000)
        ax4.plot(x_true, norm.pdf(x_true, 0, 1), 'r-', linewidth=2,
                label='真实分布 N(0,1)')
        
        ax4.set_xlabel('θ', fontsize=11)
        ax4.set_ylabel('密度', fontsize=11)
        ax4.set_title('Metropolis-Hastings抽样', fontsize=12, fontweight='bold')
        ax4.legend()
        ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('bayesian_statistics.png', dpi=300)
        plt.show()
    
    @staticmethod
    def plot_mcmc_trace():
        """MCMC轨迹图"""
        fig, axes = plt.subplots(2, 1, figsize=(12, 8))
        
        target_pdf = lambda x: norm.pdf(x, 0, 1)
        samples, _ = BayesianStatistics.metropolis_hastings(
            target_pdf, proposal_std=2.0, n_samples=2000, burn_in=500
        )
        
        # 轨迹图
        ax1 = axes[0]
        ax1.plot(samples, linewidth=0.8, alpha=0.7, color='darkblue')
        ax1.axhline(0, color='red', linestyle='--', linewidth=1.5)
        ax1.set_xlabel('迭代次数', fontsize=11)
        ax1.set_ylabel('θ', fontsize=11)
        ax1.set_title('MCMC轨迹图（Trace Plot）', fontsize=12, fontweight='bold')
        ax1.grid(True, alpha=0.3)
        
        # 自相关图
        ax2 = axes[1]
        
        lags = np.arange(0, 100)
        acf = [np.corrcoef(samples[:-lag or None], samples[lag:])[0, 1]
               if lag > 0 else 1.0 for lag in lags]
        
        ax2.stem(lags, acf, linefmt='b-', markerfmt='bo', basefmt='r-')
        ax2.axhline(0, color='black', linewidth=1)
        ax2.axhline(0.05, color='red', linestyle='--', linewidth=1, alpha=0.5)
        ax2.axhline(-0.05, color='red', linestyle='--', linewidth=1, alpha=0.5)
        ax2.set_xlabel('滞后 (Lag)', fontsize=11)
        ax2.set_ylabel('自相关系数', fontsize=11)
        ax2.set_title('自相关函数（ACF）', fontsize=12, fontweight='bold')
        ax2.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('mcmc_diagnostics.png', dpi=300)
        plt.show()

# 示例使用
print("="*60)
print("贝叶斯统计与综合应用")
print("="*60)

bs = BayesianStatistics()

# 1. 疾病检测
print("\n1. 贝叶斯疾病检测")
prior = 0.001
sensitivity = 0.95
specificity = 0.99

posterior = bs.bayesian_disease_test(prior, sensitivity, specificity)

print(f"  先验患病率: {prior*100:.2f}%")
print(f"  灵敏度: {sensitivity*100:.0f}%")
print(f"  特异度: {specificity*100:.0f}%")
print(f"  检测阳性后患病概率: {posterior*100:.2f}%")

# 2. Beta-二项共轭
print("\n" + "="*60)
print("2. Beta-二项共轭更新")

alpha_prior, beta_prior = 2, 2
n_trials, n_success = 10, 7

alpha_post, beta_post = bs.beta_binomial_conjugate(
    alpha_prior, beta_prior, n_trials, n_success
)

prior_mean = alpha_prior / (alpha_prior + beta_prior)
post_mean = alpha_post / (alpha_post + beta_post)
mle = n_success / n_trials

print(f"  先验: Beta({alpha_prior},{beta_prior})，均值={prior_mean:.3f}")
print(f"  观测: {n_success}/{n_trials}次成功")
print(f"  后验: Beta({alpha_post},{beta_post})，均值={post_mean:.3f}")
print(f"  MLE: {mle:.3f}")

# 3. Gamma-泊松共轭
print("\n" + "="*60)
print("3. Gamma-泊松共轭更新")

alpha_prior, beta_prior = 2, 1
n_obs, sum_data = 10, 8

alpha_post, beta_post = bs.gamma_poisson_conjugate(
    alpha_prior, beta_prior, n_obs, sum_data
)

prior_mean_gamma = alpha_prior / beta_prior
post_mean_gamma = alpha_post / beta_post
mle_gamma = sum_data / n_obs

print(f"  先验: Gamma({alpha_prior},{beta_prior})，均值={prior_mean_gamma:.3f}")
print(f"  观测: {n_obs}天，共{sum_data}次")
print(f"  后验: Gamma({alpha_post},{beta_post})，均值={post_mean_gamma:.3f}")
print(f"  MLE: {mle_gamma:.3f}")

# 4. MCMC抽样
print("\n" + "="*60)
print("4. Metropolis-Hastings抽样")

target_pdf = lambda x: norm.pdf(x, 0, 1)
samples, acc_rate = bs.metropolis_hastings(
    target_pdf, proposal_std=2.0, n_samples=10000, burn_in=1000
)

print(f"  目标分布: N(0,1)")
print(f"  样本数: {len(samples)}")
print(f"  接受率: {acc_rate:.3f}")
print(f"  样本均值: {np.mean(samples):.4f}")
print(f"  样本标准差: {np.std(samples):.4f}")

# 5. 水质监测案例
print("\n" + "="*60)
print("5. 水质监测的贝叶斯更新")

mu0, sigma0 = 2.0, 0.5  # 先验
n_new = 10
xbar_new = 2.5
sigma = 0.3  # 假设已知

# 正态-正态共轭
precision0 = 1 / sigma0**2
precision_data = n_new / sigma**2

precision_post = precision0 + precision_data
mu_post = (precision0 * mu0 + precision_data * xbar_new) / precision_post
sigma_post = np.sqrt(1 / precision_post)

print(f"  先验: N({mu0},{sigma0**2:.2f})，均值={mu0:.2f} mg/L")
print(f"  新数据: n={n_new}, 均值={xbar_new:.2f} mg/L, σ={sigma:.2f}")
print(f"  后验: N({mu_post:.3f},{sigma_post**2:.4f})，均值={mu_post:.3f} mg/L")
print(f"  95%可信区间: [{mu_post - 1.96*sigma_post:.3f}, {mu_post + 1.96*sigma_post:.3f}]")

# 可视化
print("\n绘制贝叶斯统计可视化...")
bs.plot_bayesian_update()
print("\n绘制MCMC诊断图...")
bs.plot_mcmc_trace()
```

---

## 八、贝叶斯 vs 频率派对比

| 方面 | 频率派 | 贝叶斯派 |
|------|--------|----------|
| **参数** | 固定未知常数 | 随机变量 |
| **概率解释** | 长期频率 | 主观置信度 |
| **推断** | 点估计+置信区间 | 后验分布+可信区间 |
| **先验信息** | 不使用 | 明确纳入 |
| **小样本** | 需渐近理论 | 可精确推断 |
| **计算** | 相对简单 | 常需MCMC |

---

## 九、本章要点

### 核心公式总结

1. **贝叶斯公式**：
   $$P(\theta|X) = \frac{P(X|\theta)P(\theta)}{P(X)}$$

2. **共轭先验**：
   - Beta-二项：$\text{Beta}(\alpha+x, \beta+n-x)$
   - Gamma-泊松：$\text{Gamma}(\alpha+s, \beta+n)$

3. **贝叶斯因子**：
   $$BF_{01} = \frac{P(X|H_0)}{P(X|H_1)}$$

4. **Metropolis-Hastings接受率**：
   $$\alpha = \min\left(1, \frac{p(\theta^*)q(\theta|\theta^*)}{p(\theta)q(\theta^*|\theta)}\right)$$

### 考试要点

1. **贝叶斯公式**的应用（疾病检测、产品质量）
2. **共轭先验**的后验计算
3. **点估计**：后验均值vs MAP vs MLE
4. **区间估计**：可信区间vs置信区间
5. **MCMC**：基本原理和收敛诊断

---

**本章重点**：
- 贝叶斯统计的基本思想和公式
- 共轭先验（Beta-二项，Gamma-泊松）
- 贝叶斯估计和假设检验
- MCMC方法（Metropolis-Hastings）
- 水文/水质监测的贝叶斯应用

**课程总结**：本书系统介绍了概率统计从基础到进阶的全部内容，涵盖参数估计、假设检验、方差分析、回归、非参数方法和贝叶斯统计，为考研和实际应用奠定坚实基础。
