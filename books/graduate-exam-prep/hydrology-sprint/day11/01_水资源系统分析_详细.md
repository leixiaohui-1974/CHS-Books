# Day 11：水资源系统分析

**学习时间**: 4小时  
**难度**: ⭐⭐⭐⭐⭐  
**重要性**: ⭐⭐⭐⭐⭐

---

## 一、系统分析基本概念

### 1.1 水资源系统

**组成要素**：
- **水源**：地表水、地下水、再生水
- **用户**：农业、工业、生活、生态
- **工程**：水库、渠道、泵站
- **管理**：调度、分配、保护

### 1.2 系统特性

- **多目标性**：供水、防洪、发电、生态
- **不确定性**：径流随机、需水变化
- **约束性**：资源有限、容量约束
- **动态性**：时空变化、滚动调整

---

## 二、水资源优化配置

### 2.1 线性规划模型

**目标函数**（最大化供水效益）：
$$\max Z = \sum_{i=1}^{m}\sum_{j=1}^{n} c_{ij}x_{ij}$$

**约束条件**：
1. **水源约束**：
   $$\sum_{j=1}^{n}x_{ij} \leq W_i \quad (i=1,2,...,m)$$

2. **需水约束**：
   $$\sum_{i=1}^{m}x_{ij} \geq D_j \quad (j=1,2,...,n)$$

3. **非负约束**：
   $$x_{ij} \geq 0$$

其中：
- $x_{ij}$：水源i供给用户j的水量
- $c_{ij}$：单位效益
- $W_i$：水源i可供水量
- $D_j$：用户j需水量

### Python实现

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import linprog, minimize
import pandas as pd

class WaterResourcesOptimization:
    """
    水资源优化配置
    """
    
    def __init__(self, supply_capacity, demand, benefit_matrix):
        """
        参数:
            supply_capacity: 水源供水能力 (m, ) 数组
            demand: 用户需水量 (n, ) 数组
            benefit_matrix: 效益矩阵 (m, n)
        """
        self.supply = np.array(supply_capacity)
        self.demand = np.array(demand)
        self.benefit = np.array(benefit_matrix)
        
        self.m = len(supply_capacity)  # 水源数
        self.n = len(demand)           # 用户数
    
    def linear_programming(self):
        """
        线性规划求解
        
        返回:
            优化结果, 配置方案
        """
        # 决策变量：x[i*n + j] 表示水源i供给用户j
        # 目标函数系数（取负，因为linprog求最小）
        c = -self.benefit.flatten()
        
        # 不等式约束 A_ub @ x <= b_ub
        # 水源约束：Σ_j x_ij <= W_i
        A_supply = np.zeros((self.m, self.m * self.n))
        for i in range(self.m):
            A_supply[i, i*self.n:(i+1)*self.n] = 1
        
        b_supply = self.supply
        
        # 需水约束转换为 -Σ_i x_ij <= -D_j
        A_demand = np.zeros((self.n, self.m * self.n))
        for j in range(self.n):
            for i in range(self.m):
                A_demand[j, i*self.n + j] = -1
        
        b_demand = -self.demand
        
        # 合并约束
        A_ub = np.vstack([A_supply, A_demand])
        b_ub = np.hstack([b_supply, b_demand])
        
        # 求解
        result = linprog(c, A_ub=A_ub, b_ub=b_ub, 
                        bounds=(0, None), method='highs')
        
        # 重塑为配置矩阵
        allocation = result.x.reshape((self.m, self.n))
        
        return result, allocation
    
    def water_balance_check(self, allocation):
        """
        水量平衡检查
        
        返回:
            供水平衡, 需水满足率
        """
        # 各水源供水量
        supply_actual = allocation.sum(axis=1)
        
        # 各用户得水量
        demand_actual = allocation.sum(axis=0)
        
        # 满足率
        satisfaction = demand_actual / self.demand * 100
        
        return supply_actual, demand_actual, satisfaction
    
    def plot_allocation(self, allocation):
        """
        可视化配置方案
        """
        fig, axes = plt.subplots(2, 2, figsize=(14, 10))
        
        # 1. 配置矩阵热图
        im = axes[0, 0].imshow(allocation, cmap='Blues', aspect='auto')
        axes[0, 0].set_xlabel('用户', fontsize=12)
        axes[0, 0].set_ylabel('水源', fontsize=12)
        axes[0, 0].set_title('水资源配置方案', fontsize=14)
        
        # 标注数值
        for i in range(self.m):
            for j in range(self.n):
                text = axes[0, 0].text(j, i, f'{allocation[i, j]:.1f}',
                                      ha='center', va='center', 
                                      color='black', fontsize=10)
        
        axes[0, 0].set_xticks(range(self.n))
        axes[0, 0].set_xticklabels([f'用户{j+1}' for j in range(self.n)])
        axes[0, 0].set_yticks(range(self.m))
        axes[0, 0].set_yticklabels([f'水源{i+1}' for i in range(self.m)])
        plt.colorbar(im, ax=axes[0, 0], label='供水量')
        
        # 2. 水源供水对比
        supply_actual, demand_actual, satisfaction = self.water_balance_check(allocation)
        
        x = np.arange(self.m)
        width = 0.35
        
        bars1 = axes[0, 1].bar(x - width/2, self.supply, width, 
                              label='供水能力', alpha=0.7, color='blue')
        bars2 = axes[0, 1].bar(x + width/2, supply_actual, width,
                              label='实际供水', alpha=0.7, color='green')
        
        axes[0, 1].set_xlabel('水源', fontsize=12)
        axes[0, 1].set_ylabel('水量 (万m³)', fontsize=12)
        axes[0, 1].set_title('水源供水对比', fontsize=14)
        axes[0, 1].set_xticks(x)
        axes[0, 1].set_xticklabels([f'水源{i+1}' for i in range(self.m)])
        axes[0, 1].legend()
        axes[0, 1].grid(True, alpha=0.3, axis='y')
        
        # 3. 用户需水满足
        x2 = np.arange(self.n)
        
        bars3 = axes[1, 0].bar(x2 - width/2, self.demand, width,
                              label='需水量', alpha=0.7, color='orange')
        bars4 = axes[1, 0].bar(x2 + width/2, demand_actual, width,
                              label='实际供水', alpha=0.7, color='green')
        
        axes[1, 0].set_xlabel('用户', fontsize=12)
        axes[1, 0].set_ylabel('水量 (万m³)', fontsize=12)
        axes[1, 0].set_title('用户需水满足', fontsize=14)
        axes[1, 0].set_xticks(x2)
        axes[1, 0].set_xticklabels([f'用户{j+1}' for j in range(self.n)])
        axes[1, 0].legend()
        axes[1, 0].grid(True, alpha=0.3, axis='y')
        
        # 4. 满足率
        bars5 = axes[1, 1].bar(x2, satisfaction, color='purple', alpha=0.7)
        axes[1, 1].axhline(100, color='r', linestyle='--', 
                          label='100%满足')
        axes[1, 1].set_xlabel('用户', fontsize=12)
        axes[1, 1].set_ylabel('满足率 (%)', fontsize=12)
        axes[1, 1].set_title('需水满足率', fontsize=14)
        axes[1, 1].set_xticks(x2)
        axes[1, 1].set_xticklabels([f'用户{j+1}' for j in range(self.n)])
        axes[1, 1].set_ylim([0, 110])
        axes[1, 1].legend()
        axes[1, 1].grid(True, alpha=0.3, axis='y')
        
        # 标注满足率
        for i, bar in enumerate(bars5):
            height = bar.get_height()
            axes[1, 1].text(bar.get_x() + bar.get_width()/2., height,
                           f'{satisfaction[i]:.1f}%',
                           ha='center', va='bottom', fontsize=10)
        
        plt.tight_layout()
        plt.savefig('water_allocation.png', dpi=300, bbox_inches='tight')
        plt.show()


# 使用示例
print("="*60)
print("水资源优化配置")
print("="*60)

# 系统参数
supply_capacity = [500, 300, 200]  # 3个水源 (万m³)
demand = [400, 350, 200]           # 3个用户 (万m³)

# 效益矩阵（元/m³）
benefit_matrix = [
    [10, 12, 8],   # 水源1
    [15, 10, 9],   # 水源2
    [8, 14, 12]    # 水源3
]

print("系统参数:")
print(f"  水源供水能力: {supply_capacity} 万m³")
print(f"  用户需水量: {demand} 万m³")
print(f"  总供水能力: {sum(supply_capacity)} 万m³")
print(f"  总需水量: {sum(demand)} 万m³")

# 创建优化对象
optimizer = WaterResourcesOptimization(
    supply_capacity, demand, benefit_matrix
)

# 线性规划求解
result, allocation = optimizer.linear_programming()

print(f"\n优化结果:")
print(f"  求解成功: {result.success}")
print(f"  最大效益: {-result.fun:.2f} 万元")

print(f"\n配置方案 (万m³):")
print(pd.DataFrame(
    allocation,
    columns=[f'用户{j+1}' for j in range(optimizer.n)],
    index=[f'水源{i+1}' for i in range(optimizer.m)]
))

# 水量平衡
supply_actual, demand_actual, satisfaction = optimizer.water_balance_check(allocation)

print(f"\n水量平衡:")
for i in range(optimizer.m):
    print(f"  水源{i+1}: 能力{supply_capacity[i]:.0f}, "
          f"实际{supply_actual[i]:.1f}, "
          f"利用率{supply_actual[i]/supply_capacity[i]*100:.1f}%")

print(f"\n需水满足:")
for j in range(optimizer.n):
    print(f"  用户{j+1}: 需求{demand[j]:.0f}, "
          f"供给{demand_actual[j]:.1f}, "
          f"满足率{satisfaction[j]:.1f}%")

# 可视化
optimizer.plot_allocation(allocation)
```

---

## 三、水库优化调度

### 3.1 动态规划模型

**状态方程**：
$$V_{t+1} = V_t + I_t - R_t - E_t$$

其中：
- $V_t$：时段t初蓄水量
- $I_t$：入流量
- $R_t$：放水量
- $E_t$：损失（蒸发、渗漏）

**目标函数**（最大化发电效益）：
$$\max \sum_{t=1}^{T} P_t = \sum_{t=1}^{T} k \cdot Q_t \cdot H_t$$

**约束**：
- 库容约束：$V_{min} \leq V_t \leq V_{max}$
- 出流约束：$Q_{min} \leq Q_t \leq Q_{max}$
- 水位约束：$Z_{min} \leq Z_t \leq Z_{max}$

### 3.2 Python实现

```python
class ReservoirOptimization:
    """
    水库优化调度（动态规划）
    """
    
    def __init__(self, V_min, V_max, inflow):
        """
        参数:
            V_min, V_max: 库容范围 (亿m³)
            inflow: 入流序列 (亿m³)
        """
        self.V_min = V_min
        self.V_max = V_max
        self.inflow = np.array(inflow)
        self.T = len(inflow)
    
    def power_generation(self, Q, H, k=8.5):
        """
        发电量计算
        
        P = k·Q·H (万kW)
        
        参数:
            Q: 发电流量 (m³/s)
            H: 水头 (m)
            k: 出力系数
        """
        P = k * Q * H / 10000  # 万kW
        return P
    
    def dynamic_programming(self, V_init, H_avg=50):
        """
        动态规划求解最优调度
        
        简化：假设水头恒定
        
        返回:
            最优路径（蓄水量）, 发电量序列
        """
        # 离散化状态空间
        V_states = np.linspace(self.V_min, self.V_max, 20)
        n_states = len(V_states)
        
        # 初始化
        f = np.zeros((self.T + 1, n_states))  # 效益函数
        policy = np.zeros((self.T, n_states), dtype=int)  # 决策路径
        
        # 初始状态
        V0_idx = np.argmin(np.abs(V_states - V_init))
        
        # 逆推
        for t in range(self.T - 1, -1, -1):
            for i, V_t in enumerate(V_states):
                max_benefit = -np.inf
                best_j = 0
                
                for j, V_t1 in enumerate(V_states):
                    # 水量平衡
                    R_t = V_t + self.inflow[t] - V_t1
                    
                    # 可行性检查
                    if R_t < 0 or R_t > self.V_max:
                        continue
                    
                    # 发电效益（简化）
                    Q_t = R_t * 1e8 / (30 * 86400)  # 转m³/s
                    benefit = self.power_generation(Q_t, H_avg) + f[t+1, j]
                    
                    if benefit > max_benefit:
                        max_benefit = benefit
                        best_j = j
                
                f[t, i] = max_benefit
                policy[t, i] = best_j
        
        # 正推求最优路径
        V_path = np.zeros(self.T + 1)
        V_path[0] = V_init
        
        current_idx = V0_idx
        
        for t in range(self.T):
            next_idx = policy[t, current_idx]
            V_path[t+1] = V_states[next_idx]
            current_idx = next_idx
        
        # 计算发电量
        power = []
        for t in range(self.T):
            R_t = V_path[t] + self.inflow[t] - V_path[t+1]
            Q_t = R_t * 1e8 / (30 * 86400)
            P_t = self.power_generation(Q_t, H_avg)
            power.append(P_t)
        
        return V_path, np.array(power)


# 水库调度示例
print("\n" + "="*60)
print("水库优化调度")
print("="*60)

# 水库参数
V_min = 5   # 死库容 (亿m³)
V_max = 30  # 总库容 (亿m³)

# 入流序列（12个月）
inflow = [8, 10, 15, 20, 25, 18, 12, 8, 6, 5, 6, 7]

reservoir = ReservoirOptimization(V_min, V_max, inflow)

# 优化
V_init = 15  # 初始蓄水
V_path, power = reservoir.dynamic_programming(V_init)

print(f"优化结果:")
print(f"  初始蓄水: {V_init:.1f} 亿m³")
print(f"  总发电量: {power.sum():.1f} 万kW")

# 可视化
fig, axes = plt.subplots(2, 1, figsize=(12, 8))

months = np.arange(1, 13)

# 蓄水过程
axes[0].plot(months, V_path[:-1], 'b-o', linewidth=2, 
            markersize=6, label='蓄水量')
axes[0].axhline(V_max, color='r', linestyle='--', label='总库容')
axes[0].axhline(V_min, color='orange', linestyle='--', label='死库容')
axes[0].fill_between(months, V_min, V_path[:-1], alpha=0.3)
axes[0].set_xlabel('月份', fontsize=12)
axes[0].set_ylabel('蓄水量 (亿m³)', fontsize=12)
axes[0].set_title('水库蓄水过程', fontsize=14)
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# 发电量
bars = axes[1].bar(months, power, color='green', alpha=0.7)
axes[1].set_xlabel('月份', fontsize=12)
axes[1].set_ylabel('发电量 (万kW)', fontsize=12)
axes[1].set_title('月发电量', fontsize=14)
axes[1].grid(True, alpha=0.3, axis='y')

plt.tight_layout()
plt.savefig('reservoir_optimization.png', dpi=300, bbox_inches='tight')
plt.show()
```

---

## 四、典型考题

### 考题：水资源配置

**【题目】**（35分）

某区域3个水源，4个用户，求最优配置。

给定：供水能力、需水量、单位效益

求：配置方案和最大效益

**【解答】**

建立线性规划模型，使用单纯形法求解。

---

## 五、高频考点

| 考点 | 方法 | 难度 |
|------|------|------|
| 水资源配置 | 线性规划 | ⭐⭐⭐⭐ |
| 水库调度 | 动态规划 | ⭐⭐⭐⭐⭐ |
| 多目标优化 | 帕累托前沿 | ⭐⭐⭐⭐ |

---

**明日预告**: Day 12 - 防洪规划与风险分析

**本日重点**：
- 线性规划模型（必考）
- 动态规划调度
- 系统分析思想
