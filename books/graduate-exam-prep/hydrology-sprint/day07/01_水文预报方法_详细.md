# Day 7：水文预报方法

**学习时间**: 4小时  
**难度**: ⭐⭐⭐⭐  
**重要性**: ⭐⭐⭐⭐

---

## 一、流域汇流预报

### 1.1 单位线法预报

**步骤**：
1. 雨量站实测降雨
2. 扣损得净雨
3. 单位线卷积得流量

### 1.2 瞬时单位线

**S曲线法推求**

### 1.3 Python实现

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import convolve

class HydrologicalForecasting:
    """
    水文预报系统
    """
    
    def __init__(self, basin_area):
        """
        参数:
            basin_area: 流域面积 (km²)
        """
        self.area = basin_area
        self.unit_hydrograph = None
    
    def set_unit_hydrograph(self, time, discharge):
        """
        设置单位线
        
        参数:
            time: 时间序列 (h)
            discharge: 流量序列 (m³/s/mm)
        """
        self.time = np.array(time)
        self.unit_hydrograph = np.array(discharge)
        self.dt = time[1] - time[0] if len(time) > 1 else 1
    
    def loss_model_constant(self, rainfall, fc=5):
        """
        损失模型（常定损失率法）
        
        参数:
            rainfall: 降雨序列 (mm)
            fc: 下渗率 (mm/h)
        
        返回:
            净雨序列
        """
        net_rainfall = np.maximum(rainfall - fc * self.dt, 0)
        return net_rainfall
    
    def loss_model_phi_index(self, rainfall, runoff_depth, method='iteration'):
        """
        损失模型（φ指数法）
        
        参数:
            rainfall: 降雨序列 (mm)
            runoff_depth: 实测径流深 (mm)
            method: 求解方法
        
        返回:
            φ指数, 净雨序列
        """
        if method == 'iteration':
            # 迭代求解φ指数
            def objective(phi):
                net_rain = np.maximum(rainfall - phi * self.dt, 0)
                return np.sum(net_rain) - runoff_depth
            
            from scipy.optimize import fsolve
            phi = fsolve(objective, 5)[0]
        else:
            # 简化估算
            phi = (np.sum(rainfall) - runoff_depth) / (len(rainfall) * self.dt)
        
        net_rainfall = np.maximum(rainfall - phi * self.dt, 0)
        
        return phi, net_rainfall
    
    def unit_hydrograph_convolution(self, net_rainfall):
        """
        单位线卷积预报
        
        参数:
            net_rainfall: 净雨序列 (mm)
        
        返回:
            流量过程 (m³/s)
        """
        if self.unit_hydrograph is None:
            raise ValueError("请先设置单位线")
        
        # 卷积
        Q = convolve(net_rainfall, self.unit_hydrograph, mode='full')
        
        # 时间序列
        n_total = len(Q)
        time_Q = np.arange(n_total) * self.dt
        
        return time_Q, Q
    
    def nash_sutcliffe_efficiency(self, Q_obs, Q_sim):
        """
        Nash-Sutcliffe效率系数
        
        NSE = 1 - Σ(Q_obs - Q_sim)² / Σ(Q_obs - Q̄_obs)²
        """
        Q_obs = np.array(Q_obs)
        Q_sim = np.array(Q_sim)
        
        # 确保长度一致
        n = min(len(Q_obs), len(Q_sim))
        Q_obs = Q_obs[:n]
        Q_sim = Q_sim[:n]
        
        Q_mean = np.mean(Q_obs)
        
        numerator = np.sum((Q_obs - Q_sim)**2)
        denominator = np.sum((Q_obs - Q_mean)**2)
        
        NSE = 1 - (numerator / denominator)
        
        return NSE
    
    def plot_forecast_result(self, time_obs, Q_obs, time_sim, Q_sim):
        """
        绘制预报结果对比
        """
        fig, axes = plt.subplots(2, 1, figsize=(12, 8))
        
        # 流量过程对比
        axes[0].plot(time_obs, Q_obs, 'b-o', linewidth=2, 
                    markersize=6, label='实测')
        axes[0].plot(time_sim, Q_sim, 'r--s', linewidth=2,
                    markersize=5, label='预报')
        
        axes[0].set_xlabel('时间 (h)', fontsize=12)
        axes[0].set_ylabel('流量 (m³/s)', fontsize=12)
        axes[0].set_title('流量过程预报对比', fontsize=14)
        axes[0].legend()
        axes[0].grid(True, alpha=0.3)
        
        # 误差分析
        n = min(len(Q_obs), len(Q_sim))
        errors = Q_sim[:n] - Q_obs[:n]
        
        axes[1].bar(time_obs[:n], errors, width=0.8, 
                   color=['r' if e > 0 else 'b' for e in errors],
                   alpha=0.6)
        axes[1].axhline(0, color='k', linewidth=1)
        axes[1].set_xlabel('时间 (h)', fontsize=12)
        axes[1].set_ylabel('误差 (m³/s)', fontsize=12)
        axes[1].set_title('预报误差', fontsize=14)
        axes[1].grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('hydrological_forecast.png', dpi=300, bbox_inches='tight')
        plt.show()


# 使用示例
print("="*60)
print("水文预报示例")
print("="*60)

# 创建预报系统
forecast = HydrologicalForecasting(basin_area=500)

# 设置单位线（简化三角形）
time_uh = np.array([0, 2, 4, 6, 8, 10, 12])
uh = np.array([0, 1.5, 3.0, 2.5, 1.5, 0.8, 0])
forecast.set_unit_hydrograph(time_uh, uh)

# 降雨过程
rainfall = np.array([5, 15, 25, 20, 10, 5])  # mm

# 损失计算（常定损失率）
net_rain = forecast.loss_model_constant(rainfall, fc=5)

print(f"降雨过程: {rainfall} mm")
print(f"净雨过程: {net_rain} mm")
print(f"总降雨: {np.sum(rainfall):.1f} mm")
print(f"总净雨: {np.sum(net_rain):.1f} mm")
print(f"损失: {np.sum(rainfall - net_rain):.1f} mm")

# 单位线预报
time_Q, Q_forecast = forecast.unit_hydrograph_convolution(net_rain)

print(f"\n预报洪峰: {np.max(Q_forecast):.1f} m³/s")
print(f"洪峰时间: {time_Q[np.argmax(Q_forecast)]:.0f} h")

# 绘图
fig, axes = plt.subplots(3, 1, figsize=(10, 10))

# 降雨
axes[0].bar(np.arange(len(rainfall)) * forecast.dt, rainfall, 
           width=forecast.dt*0.8, color='blue', alpha=0.6, label='总雨')
axes[0].bar(np.arange(len(net_rain)) * forecast.dt, net_rain,
           width=forecast.dt*0.8, color='red', alpha=0.8, label='净雨')
axes[0].set_ylabel('降雨 (mm)')
axes[0].set_title('降雨过程')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# 单位线
axes[1].plot(time_uh, uh, 'g-o', linewidth=2, markersize=6)
axes[1].fill_between(time_uh, uh, alpha=0.3, color='green')
axes[1].set_ylabel('流量 (m³/s/mm)')
axes[1].set_title('单位线')
axes[1].grid(True, alpha=0.3)

# 预报流量
axes[2].plot(time_Q, Q_forecast, 'r-', linewidth=2)
axes[2].fill_between(time_Q, Q_forecast, alpha=0.3, color='red')
axes[2].set_xlabel('时间 (h)')
axes[2].set_ylabel('流量 (m³/s)')
axes[2].set_title('预报流量过程')
axes[2].grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('forecast_example.png', dpi=300, bbox_inches='tight')
plt.show()
```

---

## 二、河道洪水演算

### 2.1 马斯京根法

**基本方程**：
$$\frac{dS}{dt} = I - Q$$

$$S = K[xI + (1-x)Q]$$

其中：
- K：蓄量常数（演进时间）
- x：蓄量权重系数（0-0.5）

**递推公式**：
$$Q_{j+1} = C_0 I_{j+1} + C_1 I_j + C_2 Q_j$$

系数：
$$C_0 = \frac{-Kx + 0.5\Delta t}{K - Kx + 0.5\Delta t}$$

$$C_1 = \frac{Kx + 0.5\Delta t}{K - Kx + 0.5\Delta t}$$

$$C_2 = \frac{K - Kx - 0.5\Delta t}{K - Kx + 0.5\Delta t}$$

**约束**：$C_0 + C_1 + C_2 = 1$

### 2.2 Python实现

```python
class MuskingumRouting:
    """
    马斯京根河道演算
    """
    
    def __init__(self, K, x, dt):
        """
        参数:
            K: 蓄量常数 (h)
            x: 权重系数 (0-0.5)
            dt: 时段 (h)
        """
        self.K = K
        self.x = x
        self.dt = dt
        
        # 计算系数
        self.C0 = (-K*x + 0.5*dt) / (K - K*x + 0.5*dt)
        self.C1 = (K*x + 0.5*dt) / (K - K*x + 0.5*dt)
        self.C2 = (K - K*x - 0.5*dt) / (K - K*x + 0.5*dt)
        
        # 验证
        sum_C = self.C0 + self.C1 + self.C2
        if abs(sum_C - 1.0) > 1e-6:
            print(f"警告: C0+C1+C2={sum_C:.6f} ≠ 1")
    
    def route(self, inflow):
        """
        河道演算
        
        参数:
            inflow: 上游入流过程 (m³/s)
        
        返回:
            下游出流过程
        """
        n = len(inflow)
        outflow = np.zeros(n)
        
        # 初始条件
        outflow[0] = inflow[0]
        
        # 递推计算
        for j in range(n-1):
            outflow[j+1] = (self.C0 * inflow[j+1] +
                           self.C1 * inflow[j] +
                           self.C2 * outflow[j])
        
        return outflow


# 马斯京根演算示例
print("\n" + "="*60)
print("马斯京根河道演算")
print("="*60)

# 上游入流（设计洪水）
t = np.array([0, 6, 12, 18, 24, 30, 36, 42, 48])
I = np.array([500, 1500, 3000, 3500, 2800, 2000, 1200, 700, 500])

# 演算参数
K = 8  # h
x = 0.2
dt = 6  # h

routing = MuskingumRouting(K, x, dt)

print(f"参数: K={K}h, x={x}, Δt={dt}h")
print(f"系数: C0={routing.C0:.4f}, C1={routing.C1:.4f}, C2={routing.C2:.4f}")
print(f"验证: C0+C1+C2={routing.C0+routing.C1+routing.C2:.6f}")

# 演算
Q = routing.route(I)

print(f"\n演算结果:")
print(f"  入流洪峰: {np.max(I):.0f} m³/s")
print(f"  出流洪峰: {np.max(Q):.0f} m³/s")
print(f"  削峰: {(np.max(I)-np.max(Q))/np.max(I)*100:.1f}%")
print(f"  峰现时间差: {(np.argmax(Q)-np.argmax(I))*dt:.0f} h")

# 绘图
plt.figure(figsize=(10, 6))
plt.plot(t, I, 'b-o', linewidth=2, markersize=8, label='上游入流')
plt.plot(t, Q, 'r-s', linewidth=2, markersize=6, label='下游出流')
plt.xlabel('时间 (h)', fontsize=12)
plt.ylabel('流量 (m³/s)', fontsize=12)
plt.title('马斯京根河道演算', fontsize=14)
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.savefig('muskingum_routing.png', dpi=300, bbox_inches='tight')
plt.show()
```

---

## 三、典型考题

### 考题1：单位线预报

**【题目】**（30分）

流域面积500km²，单位线如下，净雨[12, 20, 15]mm。

求预报流量过程和洪峰。

---

## 四、高频考点

| 考点 | 关键方法 |
|------|---------|
| 流域汇流 | 单位线法 |
| 损失计算 | φ指数法 |
| 河道演算 | 马斯京根法 |
| 预报精度 | NSE系数 |

---

**明日预告**: Day 8 - 水资源评价与管理

**本日重点**：
- 单位线预报（必考）
- 马斯京根法（高频）
- 损失计算（重要）
