# 第6章：特征值问题数值解法

**学习时间**: 4小时  
**考试频率**: ⭐⭐⭐⭐  
**难度**: ⭐⭐⭐⭐

---

## 一、特征值问题基础

### 1.1 基本概念

**特征值问题**：
$$Ax = \lambda x$$

其中$A \in \mathbb{R}^{n \times n}$，$\lambda$为特征值，$x$为特征向量

**特征多项式**：
$$\det(A - \lambda I) = 0$$

**性质**：
- $\sum \lambda_i = \text{tr}(A)$（迹）
- $\prod \lambda_i = \det(A)$
- 对称矩阵特征值全为实数

---

## 二、幂法及其改进

### 2.1 幂法（Power Method）

**目标**：求模最大特征值$\lambda_1$及对应特征向量

**算法步骤**：
1. 取初值$x^{(0)}$（非零）
2. 迭代：$y^{(k)} = Ax^{(k-1)}$
3. 归一化：$x^{(k)} = \frac{y^{(k)}}{\|y^{(k)}\|_\infty}$
4. 估计特征值：$\lambda^{(k)} = \frac{(x^{(k)})^T Ax^{(k)}}{(x^{(k)})^T x^{(k)}}$（Rayleigh商）

**收敛条件**：
$$|\lambda_1| > |\lambda_2| \geq \cdots \geq |\lambda_n|$$

**收敛速度**：
$$\|x^{(k)} - x_1\| = O\left(\left|\frac{\lambda_2}{\lambda_1}\right|^k\right)$$

**例题1**：用幂法求$A = \begin{bmatrix} 4 & 1 \\ 1 & 3 \end{bmatrix}$的最大特征值

**解**：
取$x^{(0)} = [1, 1]^T$

第1次迭代：
$$y^{(1)} = \begin{bmatrix} 4 & 1 \\ 1 & 3 \end{bmatrix}\begin{bmatrix} 1 \\ 1 \end{bmatrix} = \begin{bmatrix} 5 \\ 4 \end{bmatrix}$$

$$x^{(1)} = \frac{1}{5}\begin{bmatrix} 5 \\ 4 \end{bmatrix} = \begin{bmatrix} 1 \\ 0.8 \end{bmatrix}$$

$$\lambda^{(1)} = \frac{[1, 0.8]\begin{bmatrix} 5 \\ 4 \end{bmatrix}}{[1, 0.8]\begin{bmatrix} 1 \\ 0.8 \end{bmatrix}} = \frac{8.2}{1.64} = 5$$

继续迭代至收敛...

理论值：$\lambda_1 = 5$（精确）

---

### 2.2 反幂法（Inverse Power Method）

**目标**：求模最小特征值或离$\mu$最近的特征值

**算法**：
1. 求解$(A - \mu I)y^{(k)} = x^{(k-1)}$
2. 归一化：$x^{(k)} = \frac{y^{(k)}}{\|y^{(k)}\|_\infty}$

**特点**：
- $\mu=0$：求模最小特征值
- $\mu \neq 0$：求离$\mu$最近的特征值（位移反幂法）

**收敛速度**：比幂法快很多

---

### 2.3 Rayleigh商加速

**Rayleigh商**：
$$R(x) = \frac{x^T Ax}{x^T x}$$

**性质**：
- $\lambda_{min} \leq R(x) \leq \lambda_{max}$
- 若$x$为特征向量，则$R(x) = \lambda$

**Rayleigh商迭代**：
1. 计算$\mu^{(k)} = R(x^{(k)})$
2. 用反幂法求$(A - \mu^{(k)}I)y^{(k+1)} = x^{(k)}$

**收敛**：三次收敛（比牛顿法还快）

---

## 三、Jacobi方法（对称矩阵）

### 3.1 基本思想

**目标**：通过正交变换将对称矩阵$A$对角化

$$A = Q\Lambda Q^T$$

**Jacobi旋转**：
$$J_{pq}(\theta) = \begin{bmatrix}
1 & \cdots & 0 & \cdots & 0 & \cdots & 0 \\
\vdots & \ddots & \vdots & & \vdots & & \vdots \\
0 & \cdots & \cos\theta & \cdots & -\sin\theta & \cdots & 0 \\
\vdots & & \vdots & \ddots & \vdots & & \vdots \\
0 & \cdots & \sin\theta & \cdots & \cos\theta & \cdots & 0 \\
\vdots & & \vdots & & \vdots & \ddots & \vdots \\
0 & \cdots & 0 & \cdots & 0 & \cdots & 1
\end{bmatrix}$$

### 3.2 算法步骤

1. 选择最大非对角元$a_{pq}$
2. 计算旋转角：
   $$\tan 2\theta = \frac{2a_{pq}}{a_{pp} - a_{qq}}$$
3. 旋转：$A^{(k+1)} = J_{pq}^T A^{(k)} J_{pq}$
4. 重复直到非对角元充分小

**收敛判据**：
$$\sum_{i \neq j} (a_{ij}^{(k)})^2 < \epsilon$$

---

## 四、QR算法

### 4.1 QR分解

**定理**：任意矩阵$A$可分解为
$$A = QR$$
其中$Q$为正交矩阵，$R$为上三角矩阵

**方法**：
- Gram-Schmidt正交化
- Householder变换
- Givens旋转

### 4.2 QR迭代算法

**基本QR算法**：
1. 初始化：$A^{(0)} = A$
2. QR分解：$A^{(k)} = Q^{(k)}R^{(k)}$
3. 更新：$A^{(k+1)} = R^{(k)}Q^{(k)}$

**性质**：
- $A^{(k)}$相似于$A$（特征值不变）
- $A^{(k)} \to \Lambda$（上三角，对角线为特征值）

**加速策略**：
- 位移QR：$A^{(k)} - \mu_k I = Q^{(k)}R^{(k)}$
- Hessenberg化：先将$A$化为上Hessenberg形式

---

## 五、Householder变换

### 5.1 Householder矩阵

**定义**：
$$H = I - 2\frac{ww^T}{w^Tw}$$

**性质**：
- 对称：$H^T = H$
- 正交：$H^T H = I$
- 对合：$H^2 = I$

### 5.2 向量反射

**目标**：构造$H$使得$Hx = \alpha e_1$

**构造方法**：
$$w = x - \alpha e_1, \quad \alpha = \pm \|x\|$$

（取符号使$w_1$与$x_1$同号，避免相减误差）

### 5.3 应用：QR分解

**步骤**：
1. 第1列：$H_1 A = \begin{bmatrix} * & * & \cdots \\ 0 & * & \cdots \\ \vdots & \vdots & \ddots \end{bmatrix}$
2. 第2列：$H_2 H_1 A = \begin{bmatrix} * & * & * & \cdots \\ 0 & * & * & \cdots \\ 0 & 0 & * & \cdots \\ \vdots & \vdots & \vdots & \ddots \end{bmatrix}$
3. ...
4. $R = H_{n-1} \cdots H_1 A$，$Q = H_1 \cdots H_{n-1}$

---

## 六、Python实现

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import qr, eig

class EigenvalueSolver:
    """特征值问题求解器"""
    
    @staticmethod
    def power_method(A, x0=None, tol=1e-6, max_iter=1000):
        """
        幂法求最大特征值
        
        参数:
            A: 矩阵
            x0: 初始向量
            tol: 容差
            max_iter: 最大迭代次数
        
        返回:
            lambda_max: 最大特征值
            x: 对应特征向量
            history: 迭代历史
        """
        n = A.shape[0]
        
        if x0 is None:
            x0 = np.ones(n)
        
        x = x0 / np.linalg.norm(x0)
        history = []
        
        for k in range(max_iter):
            # 迭代
            y = A @ x
            
            # Rayleigh商
            lambda_k = (x.T @ y) / (x.T @ x)
            
            # 归一化
            x_new = y / np.linalg.norm(y, np.inf)
            
            history.append(lambda_k)
            
            # 收敛判断
            if np.linalg.norm(x_new - x) < tol:
                print(f"幂法收敛于第{k+1}次迭代")
                break
            
            x = x_new
        
        lambda_max = (x.T @ A @ x) / (x.T @ x)
        
        return lambda_max, x, history
    
    @staticmethod
    def inverse_power_method(A, mu=0, x0=None, tol=1e-6, max_iter=1000):
        """
        反幂法
        
        参数:
            A: 矩阵
            mu: 位移参数
            x0: 初始向量
        
        返回:
            lambda_nearest: 离mu最近的特征值
            x: 对应特征向量
        """
        n = A.shape[0]
        
        if x0 is None:
            x0 = np.ones(n)
        
        x = x0 / np.linalg.norm(x0)
        
        # 构造位移矩阵
        A_shifted = A - mu * np.eye(n)
        
        for k in range(max_iter):
            # 求解线性方程组
            y = np.linalg.solve(A_shifted, x)
            
            # Rayleigh商
            lambda_k = (x.T @ A @ x) / (x.T @ x)
            
            # 归一化
            x_new = y / np.linalg.norm(y, np.inf)
            
            # 收敛判断
            if np.linalg.norm(x_new - x) < tol:
                print(f"反幂法收敛于第{k+1}次迭代")
                break
            
            x = x_new
        
        lambda_nearest = (x.T @ A @ x) / (x.T @ x)
        
        return lambda_nearest, x
    
    @staticmethod
    def jacobi_method(A, tol=1e-10, max_iter=1000):
        """
        Jacobi方法求对称矩阵所有特征值
        
        参数:
            A: 对称矩阵
        
        返回:
            eigenvalues: 特征值数组
            eigenvectors: 特征向量矩阵（列向量）
        """
        n = A.shape[0]
        A_k = A.copy()
        V = np.eye(n)  # 累积旋转矩阵
        
        for iteration in range(max_iter):
            # 找最大非对角元
            max_val = 0
            p, q = 0, 1
            
            for i in range(n):
                for j in range(i+1, n):
                    if abs(A_k[i,j]) > max_val:
                        max_val = abs(A_k[i,j])
                        p, q = i, j
            
            # 收敛判断
            off_diag_norm = np.sqrt(np.sum(A_k**2) - np.sum(np.diag(A_k)**2))
            if off_diag_norm < tol:
                print(f"Jacobi方法收敛于第{iteration+1}次迭代")
                break
            
            # 计算旋转角
            if A_k[p,p] == A_k[q,q]:
                theta = np.pi / 4
            else:
                theta = 0.5 * np.arctan(2*A_k[p,q] / (A_k[p,p] - A_k[q,q]))
            
            c, s = np.cos(theta), np.sin(theta)
            
            # 构造Jacobi旋转矩阵
            J = np.eye(n)
            J[p,p] = c
            J[q,q] = c
            J[p,q] = -s
            J[q,p] = s
            
            # 旋转
            A_k = J.T @ A_k @ J
            V = V @ J
        
        eigenvalues = np.diag(A_k)
        eigenvectors = V
        
        # 排序
        idx = np.argsort(eigenvalues)[::-1]
        eigenvalues = eigenvalues[idx]
        eigenvectors = eigenvectors[:, idx]
        
        return eigenvalues, eigenvectors
    
    @staticmethod
    def qr_algorithm(A, tol=1e-10, max_iter=1000):
        """
        QR算法
        
        参数:
            A: 矩阵
        
        返回:
            eigenvalues: 特征值数组
        """
        n = A.shape[0]
        A_k = A.copy()
        
        for k in range(max_iter):
            # QR分解
            Q, R = qr(A_k)
            
            # 更新
            A_k_new = R @ Q
            
            # 收敛判断（下三角元素充分小）
            lower_tri = A_k_new - np.triu(A_k_new)
            if np.linalg.norm(lower_tri) < tol:
                print(f"QR算法收敛于第{k+1}次迭代")
                break
            
            A_k = A_k_new
        
        eigenvalues = np.diag(A_k)
        return eigenvalues
    
    @staticmethod
    def plot_convergence(history, true_value=None, title='特征值迭代收敛过程'):
        """绘制收敛曲线"""
        fig, axes = plt.subplots(1, 2, figsize=(14, 5))
        
        iterations = range(1, len(history)+1)
        
        # 特征值估计值
        ax1 = axes[0]
        ax1.plot(iterations, history, 'b-o', linewidth=2, markersize=5)
        
        if true_value is not None:
            ax1.axhline(true_value, color='r', linestyle='--',
                       linewidth=2, label=f'真实值 = {true_value:.6f}')
            ax1.legend()
        
        ax1.set_xlabel('迭代次数', fontsize=11)
        ax1.set_ylabel('特征值估计', fontsize=11)
        ax1.set_title('特征值收敛曲线', fontweight='bold')
        ax1.grid(True, alpha=0.3)
        
        # 相对误差（对数坐标）
        if true_value is not None:
            ax2 = axes[1]
            
            errors = [abs(h - true_value) / abs(true_value) 
                     for h in history]
            
            ax2.semilogy(iterations, errors, 'r-s', linewidth=2,
                        markersize=5)
            ax2.set_xlabel('迭代次数', fontsize=11)
            ax2.set_ylabel('相对误差', fontsize=11)
            ax2.set_title('误差收敛曲线（对数坐标）', fontweight='bold')
            ax2.grid(True, alpha=0.3, which='both')
        
        plt.tight_layout()
        plt.savefig('eigenvalue_convergence.png', dpi=300)
        plt.show()

# 示例使用
print("="*60)
print("特征值问题求解器")
print("="*60)

es = EigenvalueSolver()

# 测试矩阵
A = np.array([[4, 1, 0],
              [1, 3, 1],
              [0, 1, 2]], dtype=float)

print("\n测试矩阵A:")
print(A)

# 真实特征值
true_eigenvalues, true_eigenvectors = np.linalg.eig(A)
true_eigenvalues = np.sort(true_eigenvalues)[::-1]

print("\n真实特征值:")
print(true_eigenvalues)

# 1. 幂法
print("\n" + "="*60)
print("1. 幂法求最大特征值")
print("="*60)

lambda_max, x_max, history_power = es.power_method(A)

print(f"  最大特征值 = {lambda_max:.10f}")
print(f"  真实值 = {true_eigenvalues[0]:.10f}")
print(f"  误差 = {abs(lambda_max - true_eigenvalues[0]):.2e}")
print(f"  特征向量 = {x_max}")

es.plot_convergence(history_power, true_eigenvalues[0],
                   '幂法收敛过程')

# 2. 反幂法
print("\n" + "="*60)
print("2. 反幂法求最小特征值")
print("="*60)

lambda_min, x_min = es.inverse_power_method(A, mu=0)

print(f"  最小特征值 = {lambda_min:.10f}")
print(f"  真实值 = {true_eigenvalues[-1]:.10f}")
print(f"  误差 = {abs(lambda_min - true_eigenvalues[-1]):.2e}")

# 3. Jacobi方法
print("\n" + "="*60)
print("3. Jacobi方法求所有特征值")
print("="*60)

eigenvalues_jacobi, eigenvectors_jacobi = es.jacobi_method(A)

print("  计算特征值:")
print(f"  {eigenvalues_jacobi}")
print("  真实特征值:")
print(f"  {true_eigenvalues}")
print(f"  最大误差 = {np.max(np.abs(eigenvalues_jacobi - true_eigenvalues)):.2e}")

# 4. QR算法
print("\n" + "="*60)
print("4. QR算法")
print("="*60)

eigenvalues_qr = es.qr_algorithm(A)
eigenvalues_qr_sorted = np.sort(eigenvalues_qr)[::-1]

print("  计算特征值:")
print(f"  {eigenvalues_qr_sorted}")
print("  真实特征值:")
print(f"  {true_eigenvalues}")
print(f"  最大误差 = {np.max(np.abs(eigenvalues_qr_sorted - true_eigenvalues)):.2e}")
```

---

## 七、方法对比

| 方法 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| 幂法 | 简单易实现 | 只能求最大特征值，收敛慢 | 稀疏矩阵、主特征值 |
| 反幂法 | 收敛快 | 需求解线性方程组 | 求特定特征值 |
| Jacobi | 精度高，全部特征值 | 计算量大 | 对称矩阵、中小规模 |
| QR | 稳定、全部特征值 | 计算量大 | 一般矩阵 |

---

## 八、典型例题

### 例题2：幂法收敛速度

**题**：矩阵$A$的特征值为$\lambda_1=10, \lambda_2=5, \lambda_3=1$，
问幂法迭代多少次相对误差<$10^{-6}$？

**解**：
收敛速度：$\left|\frac{\lambda_2}{\lambda_1}\right|^k = 0.5^k$

要求：$0.5^k < 10^{-6}$

$$k\log 0.5 < -6 \Rightarrow k > \frac{6}{\log_{10} 2} \approx 20$$

需约20次迭代。

---

**本章重点**：
- 幂法及其改进（反幂法、Rayleigh商）
- Jacobi方法求对称矩阵特征值
- QR算法原理
- Householder变换

**下一章**：非线性方程组
