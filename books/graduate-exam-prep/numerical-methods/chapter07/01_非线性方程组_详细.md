# 第7章：非线性方程组数值解法

**学习时间**: 4小时  
**考试频率**: ⭐⭐⭐⭐  
**难度**: ⭐⭐⭐⭐⭐

---

## 一、非线性方程组基础

### 1.1 问题描述

**一般形式**：
$$\begin{cases}
f_1(x_1, x_2, \ldots, x_n) = 0 \\
f_2(x_1, x_2, \ldots, x_n) = 0 \\
\vdots \\
f_n(x_1, x_2, \ldots, x_n) = 0
\end{cases}$$

**向量形式**：
$$F(x) = 0, \quad F: \mathbb{R}^n \to \mathbb{R}^n$$

**例子**：
$$\begin{cases}
x^2 + y^2 = 1 \\
x - y = 0.5
\end{cases}$$

**解析解**：两圆交点，可能有0、1、2个解

**数值解**：迭代法求近似解

---

## 二、不动点迭代法

### 2.1 基本思想

**等价变形**：
$$F(x) = 0 \Rightarrow x = G(x)$$

**迭代格式**：
$$x^{(k+1)} = G(x^{(k)})$$

### 2.2 收敛性

**定理**（不动点定理）：
若$G: D \to D$，且存在$0 < L < 1$使得
$$\|G(x) - G(y)\| \leq L\|x - y\|, \quad \forall x, y \in D$$

则迭代收敛于唯一不动点。

**收敛速度**：
线性收敛，$\|x^{(k+1)} - x^*\| \leq L\|x^{(k)} - x^*\|$

### 2.3 示例

**例题1**：求解$\begin{cases} x^2 + y^2 = 1 \\ xy = 0.2 \end{cases}$

**变形1**：
$$\begin{cases}
x = \sqrt{1 - y^2} \\
y = \frac{0.2}{x}
\end{cases}$$

**迭代**：
$$\begin{cases}
x^{(k+1)} = \sqrt{1 - (y^{(k)})^2} \\
y^{(k+1)} = \frac{0.2}{x^{(k)}}
\end{cases}$$

取$x^{(0)} = 0.5, y^{(0)} = 0.5$：
- 第1次：$x^{(1)} = \sqrt{1-0.25} = 0.866$，$y^{(1)} = 0.4$
- 第2次：$x^{(2)} = \sqrt{1-0.16} = 0.917$，$y^{(2)} = 0.231$
- ...

---

## 三、牛顿法（Newton-Raphson Method）

### 3.1 基本原理

**泰勒展开**：
$$F(x^{(k)} + \Delta x) \approx F(x^{(k)}) + J(x^{(k)})\Delta x = 0$$

其中$J$为雅可比矩阵：
$$J = \begin{bmatrix}
\frac{\partial f_1}{\partial x_1} & \cdots & \frac{\partial f_1}{\partial x_n} \\
\vdots & \ddots & \vdots \\
\frac{\partial f_n}{\partial x_1} & \cdots & \frac{\partial f_n}{\partial x_n}
\end{bmatrix}$$

**牛顿迭代**：
$$x^{(k+1)} = x^{(k)} - J^{-1}(x^{(k)})F(x^{(k)})$$

或求解线性方程组：
$$J(x^{(k)})\Delta x^{(k)} = -F(x^{(k)})$$
$$x^{(k+1)} = x^{(k)} + \Delta x^{(k)}$$

### 3.2 收敛性

**局部二次收敛**：
若初值$x^{(0)}$充分接近$x^*$，且$J(x^*)$非奇异，则
$$\|x^{(k+1)} - x^*\| = O(\|x^{(k)} - x^*\|^2)$$

**优点**：收敛快
**缺点**：
- 需计算雅可比矩阵
- 需求解线性方程组
- 对初值敏感

### 3.3 示例

**例题2**：用牛顿法求解$\begin{cases} x^2 + y^2 - 1 = 0 \\ x - y - 0.5 = 0 \end{cases}$

**解**：
$$F(x,y) = \begin{bmatrix} x^2+y^2-1 \\ x-y-0.5 \end{bmatrix}$$

雅可比矩阵：
$$J(x,y) = \begin{bmatrix} 2x & 2y \\ 1 & -1 \end{bmatrix}$$

取初值$(x^{(0)}, y^{(0)}) = (0.8, 0.5)$：

第1次迭代：
$$F(0.8, 0.5) = \begin{bmatrix} 0.89 - 1 \\ 0.3 \end{bmatrix} = \begin{bmatrix} -0.11 \\ 0.3 \end{bmatrix}$$

$$J(0.8, 0.5) = \begin{bmatrix} 1.6 & 1.0 \\ 1 & -1 \end{bmatrix}$$

求解：
$$\begin{bmatrix} 1.6 & 1.0 \\ 1 & -1 \end{bmatrix}\begin{bmatrix} \Delta x \\ \Delta y \end{bmatrix} = -\begin{bmatrix} -0.11 \\ 0.3 \end{bmatrix}$$

$$\Delta x = 0.044, \quad \Delta y = 0.256$$

$$x^{(1)} = 0.844, \quad y^{(1)} = 0.756$$

继续迭代至收敛...

---

## 四、拟牛顿法

### 4.1 动机

**牛顿法缺点**：
- 每步需计算雅可比矩阵（$O(n^2)$）
- 需求解线性方程组（$O(n^3)$）

**拟牛顿思想**：
用近似矩阵$B_k \approx J(x^{(k)})$代替雅可比矩阵

### 4.2 割线条件

**要求**：
$$B_{k+1}(x^{(k+1)} - x^{(k)}) = F(x^{(k+1)}) - F(x^{(k)})$$

记$s_k = x^{(k+1)} - x^{(k)}$，$y_k = F(x^{(k+1)}) - F(x^{(k)})$

$$B_{k+1} s_k = y_k$$

### 4.3 Broyden方法

**秩1更新**：
$$B_{k+1} = B_k + \frac{(y_k - B_k s_k)s_k^T}{s_k^T s_k}$$

**迭代公式**：
$$x^{(k+1)} = x^{(k)} - B_k^{-1} F(x^{(k)})$$

**Sherman-Morrison公式**（避免矩阵求逆）：
$$(B_k + uv^T)^{-1} = B_k^{-1} - \frac{B_k^{-1}uv^T B_k^{-1}}{1 + v^T B_k^{-1}u}$$

**收敛**：超线性收敛（介于线性与二次之间）

---

## 五、同伦延拓法

### 5.1 基本思想

**构造同伦**：
$$H(x, t) = tF(x) + (1-t)(x - x^{(0)}), \quad t \in [0,1]$$

**性质**：
- $t=0$：$H(x,0) = x - x^{(0)} = 0$，解为$x^{(0)}$（已知）
- $t=1$：$H(x,1) = F(x) = 0$，解为$x^*$（未知）

**策略**：
从$t=0$逐步增加到$t=1$，跟踪解曲线

### 5.2 算法步骤

1. 初始化：$t_0 = 0$，$x_0 = x^{(0)}$
2. 离散化：$t_k = k\Delta t$，$\Delta t = 1/N$
3. 在每个$t_k$，用牛顿法求解$H(x, t_k) = 0$
   初值取$x_{k-1}$
4. 输出$x_N$

---

## 六、Python实现

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import fsolve

class NonlinearSystemSolver:
    """非线性方程组求解器"""
    
    @staticmethod
    def fixed_point_iteration(G, x0, tol=1e-6, max_iter=1000):
        """
        不动点迭代法
        
        参数:
            G: 迭代函数x = G(x)
            x0: 初值
            tol: 容差
            max_iter: 最大迭代次数
        
        返回:
            x: 解
            history: 迭代历史
        """
        x = x0.copy()
        history = [x0.copy()]
        
        for k in range(max_iter):
            x_new = G(x)
            history.append(x_new.copy())
            
            # 收敛判断
            if np.linalg.norm(x_new - x) < tol:
                print(f"不动点迭代收敛于第{k+1}次")
                return x_new, np.array(history)
            
            x = x_new
        
        print("不动点迭代未收敛")
        return x, np.array(history)
    
    @staticmethod
    def newton_method(F, J, x0, tol=1e-10, max_iter=100):
        """
        牛顿法
        
        参数:
            F: 方程组F(x) = 0
            J: 雅可比矩阵J(x)
            x0: 初值
        
        返回:
            x: 解
            history: 迭代历史
        """
        x = x0.copy()
        history = [x0.copy()]
        
        for k in range(max_iter):
            Fx = F(x)
            Jx = J(x)
            
            # 求解线性方程组
            try:
                delta_x = np.linalg.solve(Jx, -Fx)
            except np.linalg.LinAlgError:
                print("雅可比矩阵奇异")
                return x, np.array(history)
            
            x_new = x + delta_x
            history.append(x_new.copy())
            
            # 收敛判断
            if np.linalg.norm(delta_x) < tol:
                print(f"牛顿法收敛于第{k+1}次迭代")
                return x_new, np.array(history)
            
            x = x_new
        
        print("牛顿法未收敛")
        return x, np.array(history)
    
    @staticmethod
    def broyden_method(F, x0, tol=1e-10, max_iter=100):
        """
        Broyden方法（拟牛顿法）
        
        参数:
            F: 方程组F(x) = 0
            x0: 初值
        
        返回:
            x: 解
            history: 迭代历史
        """
        n = len(x0)
        x = x0.copy()
        history = [x0.copy()]
        
        # 初始化B（可用有限差分近似雅可比）
        h = 1e-7
        B = np.zeros((n, n))
        Fx = F(x)
        
        for i in range(n):
            ei = np.zeros(n)
            ei[i] = 1
            B[:, i] = (F(x + h*ei) - Fx) / h
        
        B_inv = np.linalg.inv(B)
        
        for k in range(max_iter):
            # 计算搜索方向
            delta_x = -B_inv @ Fx
            
            # 线搜索（简化版，固定步长）
            alpha = 1.0
            x_new = x + alpha * delta_x
            Fx_new = F(x_new)
            
            history.append(x_new.copy())
            
            # 收敛判断
            if np.linalg.norm(Fx_new) < tol:
                print(f"Broyden方法收敛于第{k+1}次迭代")
                return x_new, np.array(history)
            
            # Broyden更新
            s = x_new - x
            y = Fx_new - Fx
            
            # Sherman-Morrison公式更新B_inv
            B_inv_s = B_inv @ s
            denominator = s.T @ B_inv_s
            
            if abs(denominator) > 1e-12:
                B_inv = B_inv + np.outer((s - B_inv @ y), B_inv_s) / denominator
            
            x = x_new
            Fx = Fx_new
        
        print("Broyden方法未收敛")
        return x, np.array(history)
    
    @staticmethod
    def plot_iterations_2d(history, F=None, title='迭代过程可视化'):
        """
        绘制二维问题的迭代过程
        
        参数:
            history: 迭代历史(N×2)
            F: 方程组（可选，用于绘制等值线）
        """
        fig, axes = plt.subplots(1, 2, figsize=(14, 6))
        
        # 迭代轨迹
        ax1 = axes[0]
        
        if F is not None:
            # 绘制等值线
            x_range = [history[:,0].min()-0.5, history[:,0].max()+0.5]
            y_range = [history[:,1].min()-0.5, history[:,1].max()+0.5]
            
            x = np.linspace(x_range[0], x_range[1], 100)
            y = np.linspace(y_range[0], y_range[1], 100)
            X, Y = np.meshgrid(x, y)
            
            Z1 = np.zeros_like(X)
            Z2 = np.zeros_like(X)
            
            for i in range(X.shape[0]):
                for j in range(X.shape[1]):
                    Fxy = F(np.array([X[i,j], Y[i,j]]))
                    Z1[i,j] = Fxy[0]
                    Z2[i,j] = Fxy[1]
            
            ax1.contour(X, Y, Z1, levels=[0], colors='blue', linewidths=2,
                       linestyles='--', label='F₁=0')
            ax1.contour(X, Y, Z2, levels=[0], colors='red', linewidths=2,
                       linestyles='--', label='F₂=0')
        
        # 迭代点
        ax1.plot(history[:,0], history[:,1], 'ko-', linewidth=1.5,
                markersize=6, label='迭代轨迹')
        ax1.plot(history[0,0], history[0,1], 'gs', markersize=12,
                label='初值')
        ax1.plot(history[-1,0], history[-1,1], 'r*', markersize=15,
                label='终值')
        
        # 添加箭头
        for i in range(len(history)-1):
            ax1.annotate('', xy=history[i+1], xytext=history[i],
                        arrowprops=dict(arrowstyle='->', color='gray',
                                       lw=0.8, alpha=0.5))
        
        ax1.set_xlabel('x₁', fontsize=11)
        ax1.set_ylabel('x₂', fontsize=11)
        ax1.set_title('迭代轨迹', fontweight='bold')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # 残差范数
        ax2 = axes[1]
        
        if F is not None:
            residuals = [np.linalg.norm(F(h)) for h in history]
            
            ax2.semilogy(range(len(residuals)), residuals, 'b-o',
                        linewidth=2, markersize=5)
            ax2.set_xlabel('迭代次数', fontsize=11)
            ax2.set_ylabel('‖F(x)‖', fontsize=11)
            ax2.set_title('残差收敛曲线', fontweight='bold')
            ax2.grid(True, alpha=0.3, which='both')
        
        plt.tight_layout()
        plt.savefig('nonlinear_system_iterations.png', dpi=300)
        plt.show()

# 示例使用
print("="*60)
print("非线性方程组求解器")
print("="*60)

nls = NonlinearSystemSolver()

# 定义方程组：x² + y² = 1, x - y = 0.5
def F_example(x):
    return np.array([x[0]**2 + x[1]**2 - 1,
                     x[0] - x[1] - 0.5])

def J_example(x):
    return np.array([[2*x[0], 2*x[1]],
                     [1, -1]])

# 理论解
x_true = fsolve(F_example, [0.8, 0.3])
print("\n理论解（scipy.optimize.fsolve）:")
print(f"  x = [{x_true[0]:.10f}, {x_true[1]:.10f}]")
print(f"  验证F(x) = {F_example(x_true)}")

# 1. 不动点迭代
print("\n" + "="*60)
print("1. 不动点迭代")
print("="*60)

def G_example(x):
    # x = sqrt(1 - y²), y = x - 0.5
    return np.array([np.sqrt(abs(1 - x[1]**2)),
                     x[0] - 0.5])

x0_fp = np.array([0.8, 0.3])
try:
    x_fp, history_fp = nls.fixed_point_iteration(G_example, x0_fp)
    print(f"  解 = [{x_fp[0]:.10f}, {x_fp[1]:.10f}]")
    print(f"  误差 = {np.linalg.norm(x_fp - x_true):.2e}")
except:
    print("  不动点迭代发散或失败")

# 2. 牛顿法
print("\n" + "="*60)
print("2. 牛顿法")
print("="*60)

x0_newton = np.array([0.8, 0.3])
x_newton, history_newton = nls.newton_method(F_example, J_example, x0_newton)

print(f"  解 = [{x_newton[0]:.10f}, {x_newton[1]:.10f}]")
print(f"  误差 = {np.linalg.norm(x_newton - x_true):.2e}")
print(f"  ‖F(x)‖ = {np.linalg.norm(F_example(x_newton)):.2e}")

# 可视化
nls.plot_iterations_2d(history_newton, F_example, '牛顿法迭代过程')

# 3. Broyden方法
print("\n" + "="*60)
print("3. Broyden方法（拟牛顿法）")
print("="*60)

x0_broyden = np.array([0.8, 0.3])
x_broyden, history_broyden = nls.broyden_method(F_example, x0_broyden)

print(f"  解 = [{x_broyden[0]:.10f}, {x_broyden[1]:.10f}]")
print(f"  误差 = {np.linalg.norm(x_broyden - x_true):.2e}")
print(f"  ‖F(x)‖ = {np.linalg.norm(F_example(x_broyden)):.2e}")

# 对比
print("\n" + "="*60)
print("方法对比")
print("="*60)
print(f"{'方法':<15} {'迭代次数':<10} {'最终误差':<15}")
print("-"*40)
print(f"{'牛顿法':<15} {len(history_newton)-1:<10} {np.linalg.norm(x_newton - x_true):.2e}")
print(f"{'Broyden方法':<15} {len(history_broyden)-1:<10} {np.linalg.norm(x_broyden - x_true):.2e}")
```

---

## 七、方法对比

| 方法 | 收敛阶 | 每步计算量 | 优点 | 缺点 |
|------|--------|------------|------|------|
| 不动点迭代 | 线性 | $O(n)$ | 简单 | 收敛慢、可能发散 |
| 牛顿法 | 二次 | $O(n^3)$ | 收敛快 | 需雅可比、对初值敏感 |
| Broyden | 超线性 | $O(n^2)$ | 不需雅可比 | 收敛略慢于牛顿 |
| 同伦延拓 | - | 大 | 全局收敛 | 计算量大 |

---

**本章重点**：
- 不动点迭代与收敛性
- 牛顿法及其二次收敛
- 拟牛顿法（Broyden）
- 雅可比矩阵计算

**下一章**：优化方法
