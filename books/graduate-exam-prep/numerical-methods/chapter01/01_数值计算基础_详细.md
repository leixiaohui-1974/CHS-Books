# 第1章：数值计算基础

**学科**: 数值分析  
**工具**: Python + NumPy + SciPy

---

## 一、数值误差

### 1.1 误差来源

1. **模型误差**：数学模型简化
2. **观测误差**：测量不准
3. **截断误差**：无穷级数有限项
4. **舍入误差**：计算机有限精度

### 1.2 误差分类

**绝对误差**：
$$e = x^* - x$$

**相对误差**：
$$e_r = \frac{|e|}{|x|}$$

**有效数字**：
若$|x^* - x| \leq 0.5 \times 10^{-n}$，则$x^*$有$n$位有效数字

---

## 二、数值稳定性

### 2.1 条件数

$$\text{cond}(A) = \|A\| \cdot \|A^{-1}\|$$

- cond(A) ≈ 1：良态
- cond(A) >> 1：病态

### 2.2 算法稳定性

**例**：计算$\sqrt{x+1} - \sqrt{x}$（$x$很大）

**不稳定算法**（相消）：
```python
import math
x = 1e10
result = math.sqrt(x+1) - math.sqrt(x)  # 精度损失
```

**稳定算法**（变形）：
```python
result = 1 / (math.sqrt(x+1) + math.sqrt(x))  # 精确
```

---

## 三、非线性方程求根

### 3.1 二分法

**原理**：区间对分

**伪代码**：
```
while |b - a| > tol:
    c = (a + b) / 2
    if f(a) * f(c) < 0:
        b = c
    else:
        a = c
```

**收敛速度**：线性收敛

### 3.2 牛顿法

**迭代公式**：
$$x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$$

**收敛速度**：二阶收敛（快！）

**Python实现**：

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import fsolve, newton

class NumericalMethods:
    """数值计算方法"""
    
    @staticmethod
    def bisection(f, a, b, tol=1e-6, max_iter=100):
        """
        二分法求根
        
        参数:
            f: 函数
            a, b: 初始区间 [a, b]
            tol: 容许误差
            max_iter: 最大迭代次数
        
        返回:
            根, 迭代次数
        """
        if f(a) * f(b) > 0:
            raise ValueError("f(a)和f(b)必须异号")
        
        for i in range(max_iter):
            c = (a + b) / 2
            
            if abs(f(c)) < tol or abs(b - a) < tol:
                return c, i+1
            
            if f(a) * f(c) < 0:
                b = c
            else:
                a = c
        
        return c, max_iter
    
    @staticmethod
    def newton_method(f, df, x0, tol=1e-6, max_iter=100):
        """
        牛顿法求根
        
        参数:
            f: 函数
            df: 导数
            x0: 初值
            tol: 容许误差
            max_iter: 最大迭代次数
        
        返回:
            根, 迭代次数
        """
        x = x0
        
        for i in range(max_iter):
            fx = f(x)
            
            if abs(fx) < tol:
                return x, i+1
            
            dfx = df(x)
            if abs(dfx) < 1e-12:
                raise ValueError("导数接近零")
            
            x = x - fx / dfx
        
        return x, max_iter
    
    @staticmethod
    def secant_method(f, x0, x1, tol=1e-6, max_iter=100):
        """
        割线法（不需要导数）
        
        x_{n+1} = x_n - f(x_n) * (x_n - x_{n-1}) / (f(x_n) - f(x_{n-1}))
        """
        for i in range(max_iter):
            fx0 = f(x0)
            fx1 = f(x1)
            
            if abs(fx1) < tol:
                return x1, i+1
            
            if abs(fx1 - fx0) < 1e-12:
                raise ValueError("分母接近零")
            
            x_new = x1 - fx1 * (x1 - x0) / (fx1 - fx0)
            
            x0, x1 = x1, x_new
        
        return x1, max_iter
    
    @staticmethod
    def plot_convergence(f, root, x0, method='newton'):
        """绘制收敛过程"""
        x = np.linspace(root - 2, root + 2, 200)
        y = [f(xi) for xi in x]
        
        fig, ax = plt.subplots(figsize=(10, 6))
        
        # 绘制函数
        ax.plot(x, y, 'b-', linewidth=2, label='f(x)')
        ax.axhline(0, color='k', linestyle='--', linewidth=0.5)
        ax.axvline(root, color='r', linestyle='--', 
                  linewidth=1, label=f'根≈{root:.4f}')
        
        # 迭代过程
        if method == 'newton':
            xi = x0
            df = lambda x: (f(x+1e-7) - f(x)) / 1e-7  # 数值导数
            
            for i in range(5):
                fxi = f(xi)
                dfxi = df(xi)
                
                # 切线
                x_tangent = np.array([xi - 0.5, xi + 0.5])
                y_tangent = fxi + dfxi * (x_tangent - xi)
                ax.plot(x_tangent, y_tangent, 'g--', alpha=0.5)
                
                # 标记点
                ax.plot(xi, fxi, 'go', markersize=8)
                
                # 下一个点
                xi = xi - fxi / dfxi
        
        ax.set_xlabel('x', fontsize=12)
        ax.set_ylabel('f(x)', fontsize=12)
        ax.set_title(f'{method.capitalize()}法收敛过程', fontsize=14)
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('convergence.png', dpi=300)
        plt.show()

# 示例
print("="*60)
print("非线性方程求根")
print("="*60)

# 定义方程: x³ - x - 2 = 0
f = lambda x: x**3 - x - 2
df = lambda x: 3*x**2 - 1

print("方程: x³ - x - 2 = 0")

# 方法1：二分法
print("\n【方法1：二分法】")
root1, iter1 = NumericalMethods.bisection(f, 1, 2)
print(f"根: {root1:.8f}")
print(f"迭代次数: {iter1}")
print(f"验证: f({root1:.8f}) = {f(root1):.2e}")

# 方法2：牛顿法
print("\n【方法2：牛顿法】")
root2, iter2 = NumericalMethods.newton_method(f, df, 1.5)
print(f"根: {root2:.8f}")
print(f"迭代次数: {iter2}")
print(f"验证: f({root2:.8f}) = {f(root2):.2e}")

# 方法3：割线法
print("\n【方法3：割线法】")
root3, iter3 = NumericalMethods.secant_method(f, 1, 2)
print(f"根: {root3:.8f}")
print(f"迭代次数: {iter3}")

# 方法4：SciPy内置
print("\n【方法4：SciPy fsolve】")
root4 = fsolve(f, 1.5)[0]
print(f"根: {root4:.8f}")

# 对比
print("\n【方法对比】")
print(f"{'方法':<15s} {'根':<12s} {'迭代次数':<10s}")
print("-" * 40)
print(f"{'二分法':<15s} {root1:<12.8f} {iter1:<10d}")
print(f"{'牛顿法':<15s} {root2:<12.8f} {iter2:<10d}")
print(f"{'割线法':<15s} {root3:<12.8f} {iter3:<10d}")

# 可视化
NumericalMethods.plot_convergence(f, root2, 1.5, method='newton')
```

---

## 四、线性方程组

### 4.1 高斯消元法

**步骤**：
1. 前向消元：化为上三角
2. 回代求解

**复杂度**：$O(n^3)$

### 4.2 LU分解

$$\mathbf{A} = \mathbf{L}\mathbf{U}$$

**优点**：多个右端向量时高效

```python
from scipy.linalg import lu

A = np.array([[4, 3], [6, 3]])
P, L, U = lu(A)

print("L矩阵:\n", L)
print("U矩阵:\n", U)
```

---

## 五、数值积分

### 5.1 梯形公式

$$\int_a^b f(x)dx \approx \frac{b-a}{2}[f(a) + f(b)]$$

### 5.2 辛普森公式

$$\int_a^b f(x)dx \approx \frac{b-a}{6}\left[f(a) + 4f\left(\frac{a+b}{2}\right) + f(b)\right]$$

**精度**：辛普森 > 梯形

---

## 六、常微分方程

### 6.1 欧拉法

$$y_{n+1} = y_n + h \cdot f(x_n, y_n)$$

### 6.2 龙格-库塔法（RK4）

**四阶精度**，最常用！

```python
from scipy.integrate import odeint

# dy/dx = -2xy, y(0)=1
def dydt(y, x):
    return -2 * x * y

x = np.linspace(0, 2, 100)
y = odeint(dydt, 1.0, x)

plt.plot(x, y, 'b-', label='数值解')
plt.plot(x, np.exp(-x**2), 'r--', label='精确解')
plt.legend()
plt.show()
```

---

**本章重点**：
- 误差分析
- 牛顿法求根
- 数值积分
- 常微分方程求解
