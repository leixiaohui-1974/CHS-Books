# 第3章：常微分方程数值解法

**应用范围**: 动力学、热传导、水文预报  
**难度**: ⭐⭐⭐⭐

---

## 一、初值问题

### 1.1 标准形式

**一阶ODE初值问题**：
$$\frac{dy}{dx} = f(x, y), \quad y(x_0) = y_0$$

**目标**：求解$y(x)$在离散点$x_i$上的近似值$y_i$

### 1.2 离散化

取步长$h$，离散点$x_i = x_0 + ih$

**数值解**：$\{(x_0, y_0), (x_1, y_1), \ldots, (x_n, y_n)\}$

---

## 二、Euler方法

### 2.1 显式Euler法

**基本思想**：泰勒展开到一阶

$$y_{i+1} = y_i + h \cdot f(x_i, y_i)$$

**几何意义**：沿切线方向前进一步

**截断误差**：$O(h^2)$（局部），$O(h)$（全局）

**稳定性**：条件稳定，需满足$h < h_{crit}$

### 2.2 改进Euler法（预测-校正）

**预测**：
$$\tilde{y}_{i+1} = y_i + h \cdot f(x_i, y_i)$$

**校正**：
$$y_{i+1} = y_i + \frac{h}{2}[f(x_i, y_i) + f(x_{i+1}, \tilde{y}_{i+1})]$$

**截断误差**：$O(h^3)$（局部），$O(h^2)$（全局）

### Python实现

```python
import numpy as np
import matplotlib.pyplot as plt

class ODESolver:
    """常微分方程数值解法"""
    
    @staticmethod
    def euler_explicit(f, x0, y0, h, n):
        """
        显式Euler法
        
        y_{i+1} = y_i + h·f(x_i, y_i)
        
        参数:
            f: 函数 dy/dx = f(x, y)
            x0: 初值 x
            y0: 初值 y
            h: 步长
            n: 步数
        
        返回:
            x: x数组
            y: y数组
        """
        x = np.zeros(n+1)
        y = np.zeros(n+1)
        
        x[0] = x0
        y[0] = y0
        
        for i in range(n):
            y[i+1] = y[i] + h * f(x[i], y[i])
            x[i+1] = x[i] + h
        
        return x, y
    
    @staticmethod
    def euler_improved(f, x0, y0, h, n):
        """
        改进Euler法（预测-校正）
        
        预测: ỹ_{i+1} = y_i + h·f(x_i, y_i)
        校正: y_{i+1} = y_i + (h/2)·[f(x_i,y_i) + f(x_{i+1},ỹ_{i+1})]
        """
        x = np.zeros(n+1)
        y = np.zeros(n+1)
        
        x[0] = x0
        y[0] = y0
        
        for i in range(n):
            # 预测
            y_pred = y[i] + h * f(x[i], y[i])
            
            # 校正
            y[i+1] = y[i] + 0.5 * h * (f(x[i], y[i]) + 
                                       f(x[i] + h, y_pred))
            x[i+1] = x[i] + h
        
        return x, y
    
    @staticmethod
    def runge_kutta_4(f, x0, y0, h, n):
        """
        四阶Runge-Kutta法（RK4）
        
        k₁ = f(xᵢ, yᵢ)
        k₂ = f(xᵢ+h/2, yᵢ+hk₁/2)
        k₃ = f(xᵢ+h/2, yᵢ+hk₂/2)
        k₄ = f(xᵢ+h, yᵢ+hk₃)
        
        y_{i+1} = yᵢ + (h/6)(k₁ + 2k₂ + 2k₃ + k₄)
        """
        x = np.zeros(n+1)
        y = np.zeros(n+1)
        
        x[0] = x0
        y[0] = y0
        
        for i in range(n):
            k1 = f(x[i], y[i])
            k2 = f(x[i] + 0.5*h, y[i] + 0.5*h*k1)
            k3 = f(x[i] + 0.5*h, y[i] + 0.5*h*k2)
            k4 = f(x[i] + h, y[i] + h*k3)
            
            y[i+1] = y[i] + (h/6) * (k1 + 2*k2 + 2*k3 + k4)
            x[i+1] = x[i] + h
        
        return x, y
    
    @staticmethod
    def adams_bashforth_2(f, x0, y0, h, n):
        """
        Adams-Bashforth二步法
        
        y_{i+1} = yᵢ + (h/2)(3f(xᵢ,yᵢ) - f(xᵢ₋₁,yᵢ₋₁))
        
        需要用RK4提供初始值
        """
        x = np.zeros(n+1)
        y = np.zeros(n+1)
        
        x[0] = x0
        y[0] = y0
        
        # 用RK4计算第一步
        k1 = f(x[0], y[0])
        k2 = f(x[0] + 0.5*h, y[0] + 0.5*h*k1)
        k3 = f(x[0] + 0.5*h, y[0] + 0.5*h*k2)
        k4 = f(x[0] + h, y[0] + h*k3)
        
        y[1] = y[0] + (h/6) * (k1 + 2*k2 + 2*k3 + k4)
        x[1] = x[0] + h
        
        # Adams-Bashforth二步法
        for i in range(1, n):
            y[i+1] = y[i] + 0.5*h * (3*f(x[i], y[i]) - 
                                     f(x[i-1], y[i-1]))
            x[i+1] = x[i] + h
        
        return x, y
    
    @staticmethod
    def compare_methods(f, y_exact, x0, y0, x_end, h_values):
        """
        比较不同方法的精度
        
        参数:
            f: dy/dx = f(x,y)
            y_exact: 精确解函数
            x0, y0: 初值
            x_end: 终点
            h_values: 步长列表
        """
        methods = {
            'Euler': ODESolver.euler_explicit,
            'Improved Euler': ODESolver.euler_improved,
            'RK4': ODESolver.runge_kutta_4,
            'Adams-Bashforth-2': ODESolver.adams_bashforth_2
        }
        
        results = {}
        
        for method_name, method_func in methods.items():
            errors = []
            
            for h in h_values:
                n = int((x_end - x0) / h)
                x, y = method_func(f, x0, y0, h, n)
                
                # 计算最大误差
                y_true = y_exact(x)
                max_error = np.max(np.abs(y - y_true))
                
                errors.append(max_error)
            
            results[method_name] = errors
        
        return results
    
    @staticmethod
    def plot_convergence(h_values, results):
        """绘制收敛性曲线"""
        fig, ax = plt.subplots(figsize=(10, 7))
        
        for method_name, errors in results.items():
            ax.loglog(h_values, errors, '-o', linewidth=2,
                     markersize=8, label=method_name)
        
        # 参考线
        h_ref = np.array(h_values)
        ax.loglog(h_ref, h_ref, 'k--', alpha=0.5, label='O(h)')
        ax.loglog(h_ref, h_ref**2, 'k:', alpha=0.5, label='O(h²)')
        ax.loglog(h_ref, h_ref**4, 'k-.', alpha=0.5, label='O(h⁴)')
        
        ax.set_xlabel('步长 h', fontsize=12)
        ax.set_ylabel('最大误差', fontsize=12)
        ax.set_title('数值方法收敛性比较', fontsize=14)
        ax.legend(loc='best')
        ax.grid(True, which='both', alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('ode_convergence.png', dpi=300)
        plt.show()

# 示例1：简单ODE
print("="*60)
print("示例1：dy/dx = -2y, y(0)=1")
print("="*60)

# 定义问题
def f1(x, y):
    return -2 * y

def y1_exact(x):
    return np.exp(-2 * x)

x0, y0 = 0, 1
h = 0.1
n = 10

solver = ODESolver()

# Euler法
x_euler, y_euler = solver.euler_explicit(f1, x0, y0, h, n)

# 改进Euler法
x_improved, y_improved = solver.euler_improved(f1, x0, y0, h, n)

# RK4法
x_rk4, y_rk4 = solver.runge_kutta_4(f1, x0, y0, h, n)

# 精确解
y_exact = y1_exact(x_rk4)

# 比较结果
print(f"步长 h = {h}, 步数 n = {n}")
print(f"\n{'x':>6s} {'精确':>10s} {'Euler':>10s} {'改进Euler':>12s} {'RK4':>10s}")
print("-" * 60)

for i in range(0, n+1, 2):
    print(f"{x_rk4[i]:6.2f} {y_exact[i]:10.6f} {y_euler[i]:10.6f} "
          f"{y_improved[i]:12.6f} {y_rk4[i]:10.6f}")

# 误差分析
error_euler = np.abs(y_euler - y_exact)
error_improved = np.abs(y_improved - y_exact)
error_rk4 = np.abs(y_rk4 - y_exact)

print(f"\n最大误差:")
print(f"  Euler: {np.max(error_euler):.2e}")
print(f"  改进Euler: {np.max(error_improved):.2e}")
print(f"  RK4: {np.max(error_rk4):.2e}")

# 可视化
fig, axes = plt.subplots(1, 2, figsize=(16, 6))

# (a) 解曲线
axes[0].plot(x_rk4, y_exact, 'k-', linewidth=3, label='精确解')
axes[0].plot(x_euler, y_euler, 'r--o', linewidth=2, 
            markersize=6, label='Euler')
axes[0].plot(x_improved, y_improved, 'g--s', linewidth=2,
            markersize=6, label='改进Euler')
axes[0].plot(x_rk4, y_rk4, 'b--^', linewidth=2,
            markersize=6, label='RK4')

axes[0].set_xlabel('x', fontsize=12)
axes[0].set_ylabel('y', fontsize=12)
axes[0].set_title('数值解与精确解对比', fontsize=14)
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# (b) 误差
axes[1].semilogy(x_euler, error_euler, 'r-o', linewidth=2,
                markersize=6, label='Euler')
axes[1].semilogy(x_improved, error_improved, 'g-s', linewidth=2,
                markersize=6, label='改进Euler')
axes[1].semilogy(x_rk4, error_rk4, 'b-^', linewidth=2,
                markersize=6, label='RK4')

axes[1].set_xlabel('x', fontsize=12)
axes[1].set_ylabel('绝对误差', fontsize=12)
axes[1].set_title('误差曲线', fontsize=14)
axes[1].legend()
axes[1].grid(True, which='both', alpha=0.3)

plt.tight_layout()
plt.savefig('ode_solution_comparison.png', dpi=300)
plt.show()

# 示例2：收敛性分析
print("\n" + "="*60)
print("示例2：收敛性分析")
print("="*60)

h_values = [0.2, 0.1, 0.05, 0.025, 0.0125]
x_end = 1.0

results = solver.compare_methods(f1, y1_exact, x0, y0, x_end, h_values)

print(f"{'步长h':>10s}", end='')
for method in results.keys():
    print(f"{method:>15s}", end='')
print()
print("-" * 80)

for i, h in enumerate(h_values):
    print(f"{h:10.4f}", end='')
    for errors in results.values():
        print(f"{errors[i]:15.2e}", end='')
    print()

solver.plot_convergence(h_values, results)

# 示例3：实际应用 - 洪水演进
print("\n" + "="*60)
print("示例3：洪水演进模拟（简化St.Venant方程）")
print("="*60)

def flood_routing(t, Q):
    """
    简化洪水演进方程
    dQ/dt = I(t) - Q/K
    
    K: 河段调蓄常数
    I(t): 入流
    """
    K = 3.0  # 小时
    
    # 入流过程（三角形洪水）
    if t < 10:
        I = 100 * t  # 上升段
    elif t < 20:
        I = 1000 - 100 * (t - 10)  # 下降段
    else:
        I = 0
    
    return (I - Q) / K

# 求解
t0, Q0 = 0, 0
h_flood = 0.5  # 小时
n_flood = 80

t_rk4, Q_rk4 = solver.runge_kutta_4(flood_routing, t0, Q0, h_flood, n_flood)

# 入流过程
I_values = []
for t in t_rk4:
    if t < 10:
        I = 100 * t
    elif t < 20:
        I = 1000 - 100 * (t - 10)
    else:
        I = 0
    I_values.append(I)

# 绘制
fig, ax = plt.subplots(figsize=(12, 7))

ax.plot(t_rk4, I_values, 'r-', linewidth=2.5, label='入流 I(t)')
ax.plot(t_rk4, Q_rk4, 'b-', linewidth=2.5, label='出流 Q(t)')

ax.fill_between(t_rk4, 0, I_values, alpha=0.2, color='red')
ax.fill_between(t_rk4, 0, Q_rk4, alpha=0.2, color='blue')

ax.set_xlabel('时间 (小时)', fontsize=12)
ax.set_ylabel('流量 (m³/s)', fontsize=12)
ax.set_title('洪水演进过程', fontsize=14)
ax.legend(loc='upper right')
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('flood_routing.png', dpi=300)
plt.show()

print(f"洪水特征:")
print(f"  入流洪峰: {max(I_values):.0f} m³/s, 峰现时间: {t_rk4[I_values.index(max(I_values))]:.1f}小时")
print(f"  出流洪峰: {max(Q_rk4):.0f} m³/s, 峰现时间: {t_rk4[np.argmax(Q_rk4)]:.1f}小时")
print(f"  削峰: {(max(I_values)-max(Q_rk4))/max(I_values)*100:.1f}%")
print(f"  滞时: {t_rk4[np.argmax(Q_rk4)] - 10:.1f}小时")
```

---

## 三、Runge-Kutta方法

### 3.1 四阶RK法（RK4）

**经典四阶公式**：

$$k_1 = f(x_i, y_i)$$
$$k_2 = f(x_i + \frac{h}{2}, y_i + \frac{h}{2}k_1)$$
$$k_3 = f(x_i + \frac{h}{2}, y_i + \frac{h}{2}k_2)$$
$$k_4 = f(x_i + h, y_i + hk_3)$$

$$y_{i+1} = y_i + \frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$

**截断误差**：$O(h^5)$（局部），$O(h^4)$（全局）

---

## 四、典型考题

### 【例题】ODE数值解

**题目**（20分）

用Euler法求解$\frac{dy}{dx} = x + y$，$y(0)=1$，取$h=0.1$，求$y(0.2)$

**【解答】**

$x_0=0$，$y_0=1$

**第1步**：$x_1 = 0.1$
$$y_1 = y_0 + h \cdot f(x_0, y_0) = 1 + 0.1 \times (0 + 1) = 1.1$$

**第2步**：$x_2 = 0.2$
$$y_2 = y_1 + h \cdot f(x_1, y_1) = 1.1 + 0.1 \times (0.1 + 1.1) = 1.22$$

**答**：$y(0.2) \approx 1.22$

---

**本章重点**：
- Euler法（显式、改进）
- RK4方法（最常用）
- 精度与收敛性
- 实际应用（洪水演进）
