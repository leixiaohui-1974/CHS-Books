# 第10章：数值计算综合案例

**学习时间**: 6小时  
**考试频率**: ⭐⭐⭐⭐⭐  
**难度**: ⭐⭐⭐⭐⭐

---

## 一、水库优化调度综合案例

### 1.1 问题描述

**目标**：最大化水库发电量

**约束条件**：
1. 水量平衡：$V_{t+1} = V_t + Q_{in,t} - Q_{out,t} - E_t$
2. 库容限制：$V_{\min} \leq V_t \leq V_{\max}$
3. 出流限制：$Q_{\min} \leq Q_{out,t} \leq Q_{\max}$
4. 水位-库容关系：$Z_t = f(V_t)$（非线性）
5. 发电量计算：$P_t = \eta \rho g Q_{out,t} H_t$

---

### 1.2 完整Python实现

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize, differential_evolution
from scipy.interpolate import interp1d


class ReservoirOptimization:
    """水库优化调度综合系统"""
    
    def __init__(self, V_data, Z_data, V_min, V_max, Q_min, Q_max,
                 H_tail=50, eta=0.9, rho=1000, g=9.81):
        """
        参数:
            V_data: 库容数据点 (m^3)
            Z_data: 对应水位数据点 (m)
            V_min, V_max: 库容上下限
            Q_min, Q_max: 出流上下限 (m^3/s)
            H_tail: 尾水位 (m)
            eta: 发电效率
            rho: 水密度 (kg/m^3)
            g: 重力加速度 (m/s^2)
        """
        self.V_min = V_min
        self.V_max = V_max
        self.Q_min = Q_min
        self.Q_max = Q_max
        self.H_tail = H_tail
        self.eta = eta
        self.rho = rho
        self.g = g
        
        # 建立水位-库容插值函数
        self.V_to_Z = interp1d(V_data, Z_data, kind='cubic',
                              fill_value='extrapolate')
    
    def power_output(self, Q, V):
        """
        计算发电量
        
        参数:
            Q: 出流量 (m^3/s)
            V: 库容 (m^3)
        
        返回:
            P: 发电量 (MW)
        """
        Z = self.V_to_Z(V)
        H = Z - self.H_tail
        P = self.eta * self.rho * self.g * Q * H / 1e6  # MW
        return P
    
    def water_balance(self, V, Q_in, Q_out, E, dt=86400):
        """
        水量平衡方程
        
        参数:
            V: 当前库容
            Q_in: 入流
            Q_out: 出流
            E: 蒸发渗漏损失 (m^3)
            dt: 时间步长 (秒，默认1天)
        
        返回:
            V_next: 下一时刻库容
        """
        return V + (Q_in - Q_out) * dt - E
    
    def optimize_dynamic_programming(self, Q_in_series, V_init, 
                                     n_stages, n_states=20):
        """
        动态规划优化
        
        参数:
            Q_in_series: 入流序列 (m^3/s)
            V_init: 初始库容
            n_stages: 时段数
            n_states: 状态离散数
        
        返回:
            Q_opt: 最优出流序列
            V_opt: 最优库容序列
            P_total: 总发电量
        """
        # 状态空间离散
        V_states = np.linspace(self.V_min, self.V_max, n_states)
        
        # 决策空间
        Q_decisions = np.linspace(self.Q_min, self.Q_max, 20)
        
        # DP表
        value = np.full((n_stages + 1, n_states), -np.inf)
        policy = np.zeros((n_stages, n_states), dtype=int)
        
        # 边界条件（终端状态价值为0）
        value[n_stages, :] = 0
        
        # 逆向递推
        for t in range(n_stages - 1, -1, -1):
            Q_in = Q_in_series[t]
            
            for i, V in enumerate(V_states):
                best_value = -np.inf
                best_decision = 0
                
                for j, Q_out in enumerate(Q_decisions):
                    # 水量平衡
                    V_next = self.water_balance(V, Q_in, Q_out, E=0)
                    
                    # 检查约束
                    if V_next < self.V_min or V_next > self.V_max:
                        continue
                    
                    # 阶段发电量
                    P = self.power_output(Q_out, V)
                    
                    # 插值下一状态价值
                    V_next_value = np.interp(V_next, V_states, value[t+1, :])
                    
                    # 总价值
                    total_value = P + V_next_value
                    
                    if total_value > best_value:
                        best_value = total_value
                        best_decision = j
                
                value[t, i] = best_value
                policy[t, i] = best_decision
        
        # 正向模拟最优轨迹
        Q_opt = np.zeros(n_stages)
        V_opt = np.zeros(n_stages + 1)
        V_opt[0] = V_init
        
        for t in range(n_stages):
            # 找到当前库容最近的状态
            i = np.argmin(np.abs(V_states - V_opt[t]))
            
            # 最优决策
            j = policy[t, i]
            Q_opt[t] = Q_decisions[j]
            
            # 更新库容
            V_opt[t+1] = self.water_balance(V_opt[t], Q_in_series[t],
                                           Q_opt[t], E=0)
        
        # 总发电量
        P_series = [self.power_output(Q_opt[t], V_opt[t]) 
                   for t in range(n_stages)]
        P_total = sum(P_series)
        
        return Q_opt, V_opt, P_total, P_series
    
    def optimize_differential_evolution(self, Q_in_series, V_init, V_final):
        """
        差分进化全局优化
        
        参数:
            Q_in_series: 入流序列
            V_init: 初始库容
            V_final: 最终库容（约束）
        
        返回:
            Q_opt: 最优出流序列
            V_opt: 库容序列
            P_total: 总发电量
        """
        n_stages = len(Q_in_series)
        
        # 决策变量：各时段出流量
        bounds = [(self.Q_min, self.Q_max)] * n_stages
        
        def objective(Q_decisions):
            """目标函数：负的总发电量"""
            V = V_init
            P_total = 0
            
            for t in range(n_stages):
                Q_out = Q_decisions[t]
                
                # 发电量
                P = self.power_output(Q_out, V)
                P_total += P
                
                # 水量平衡
                V = self.water_balance(V, Q_in_series[t], Q_out, E=0)
                
                # 约束惩罚
                if V < self.V_min or V > self.V_max:
                    return 1e10
            
            # 终端库容约束
            penalty = 1e6 * (V - V_final)**2
            
            return -P_total + penalty
        
        # 优化
        result = differential_evolution(objective, bounds, seed=42,
                                       maxiter=200, popsize=20)
        
        Q_opt = result.x
        
        # 重新模拟得到库容序列
        V_opt = np.zeros(n_stages + 1)
        V_opt[0] = V_init
        P_series = []
        
        for t in range(n_stages):
            P = self.power_output(Q_opt[t], V_opt[t])
            P_series.append(P)
            V_opt[t+1] = self.water_balance(V_opt[t], Q_in_series[t],
                                           Q_opt[t], E=0)
        
        P_total = sum(P_series)
        
        return Q_opt, V_opt, P_total, P_series


# 测试案例
print("="*60)
print("案例1：水库优化调度")
print("="*60)

# 水位-库容关系（三峡水库简化）
V_data = np.array([0, 5e9, 10e9, 20e9, 30e9, 39.3e9]) * 1e-9 * 1e9  # m^3
Z_data = np.array([145, 150, 155, 165, 170, 175])  # m

# 初始化
reservoir = ReservoirOptimization(
    V_data=V_data,
    Z_data=Z_data,
    V_min=10e9,
    V_max=39e9,
    Q_min=5000,
    Q_max=60000,
    H_tail=62,
    eta=0.9
)

# 入流数据（12个月）
Q_in_series = np.array([8000, 9000, 12000, 18000, 25000, 30000,
                        35000, 32000, 28000, 22000, 15000, 10000])

V_init = 20e9
V_final = 25e9

# 方法1：动态规划
print("\n方法1：动态规划")
Q_dp, V_dp, P_dp, P_series_dp = reservoir.optimize_dynamic_programming(
    Q_in_series, V_init, n_stages=12, n_states=30)

print(f"总发电量: {P_dp:.2f} MW·天")
print(f"日均发电量: {P_dp/12:.2f} MW")

# 方法2：差分进化
print("\n方法2：差分进化")
Q_de, V_de, P_de, P_series_de = reservoir.optimize_differential_evolution(
    Q_in_series, V_init, V_final)

print(f"总发电量: {P_de:.2f} MW·天")
print(f"日均发电量: {P_de/12:.2f} MW")
print(f"终端库容: {V_de[-1]/1e9:.2f} 亿m^3 (目标: {V_final/1e9:.2f})")

# 可视化
fig, axes = plt.subplots(2, 2, figsize=(14, 10))

# 入流和出流
ax = axes[0, 0]
months = np.arange(1, 13)
ax.plot(months, Q_in_series, 'b-o', label='入流', linewidth=2, markersize=6)
ax.plot(months, Q_dp, 'r-s', label='出流(DP)', linewidth=2, markersize=6)
ax.plot(months, Q_de, 'g-^', label='出流(DE)', linewidth=1.5, markersize=5)
ax.set_xlabel('月份')
ax.set_ylabel('流量 (m³/s)')
ax.set_title('入流与出流对比')
ax.legend()
ax.grid(True, alpha=0.3)

# 库容变化
ax = axes[0, 1]
ax.plot(np.arange(13), V_dp/1e9, 'r-s', label='DP', linewidth=2, markersize=6)
ax.plot(np.arange(13), V_de/1e9, 'g-^', label='DE', linewidth=1.5, markersize=5)
ax.axhline(reservoir.V_min/1e9, color='k', linestyle='--', 
          alpha=0.5, label='库容下限')
ax.axhline(reservoir.V_max/1e9, color='k', linestyle='--',
          alpha=0.5, label='库容上限')
ax.set_xlabel('月份')
ax.set_ylabel('库容 (亿m³)')
ax.set_title('库容变化')
ax.legend()
ax.grid(True, alpha=0.3)

# 发电量
ax = axes[1, 0]
ax.bar(months - 0.2, P_series_dp, width=0.4, label='DP', color='red', alpha=0.7)
ax.bar(months + 0.2, P_series_de, width=0.4, label='DE', color='green', alpha=0.7)
ax.set_xlabel('月份')
ax.set_ylabel('发电量 (MW)')
ax.set_title('各月发电量')
ax.legend()
ax.grid(True, alpha=0.3, axis='y')

# 水位-库容关系
ax = axes[1, 1]
V_range = np.linspace(V_data.min(), V_data.max(), 100)
Z_range = reservoir.V_to_Z(V_range)
ax.plot(V_range/1e9, Z_range, 'b-', linewidth=2, label='水位-库容曲线')
ax.plot(V_dp/1e9, reservoir.V_to_Z(V_dp), 'ro', markersize=8,
       label='DP库容轨迹')
ax.set_xlabel('库容 (亿m³)')
ax.set_ylabel('水位 (m)')
ax.set_title('水位-库容关系')
ax.legend()
ax.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('reservoir_optimization.png', dpi=300, bbox_inches='tight')
plt.show()
```

---

## 二、地下水流数值模拟综合案例

### 2.1 问题描述

**控制方程**（2D稳定流）：
$$
\frac{\partial}{\partial x}\left(K\frac{\partial h}{\partial x}\right) + \frac{\partial}{\partial y}\left(K\frac{\partial h}{\partial y}\right) = W
$$

**边界条件**：
- 第一类（Dirichlet）：$h = h_0$ 在边界上
- 第二类（Neumann）：$-K\frac{\partial h}{\partial n} = q$ 在边界上
- 第三类（Cauchy）：$-K\frac{\partial h}{\partial n} = \alpha(h - h_e)$

---

### 2.2 完整Python实现

```python
class GroundwaterSimulation:
    """地下水流数值模拟系统"""
    
    def __init__(self, Lx, Ly, nx, ny, K):
        """
        参数:
            Lx, Ly: 区域尺寸 (m)
            nx, ny: 网格数
            K: 渗透系数 (m/day)
        """
        self.Lx = Lx
        self.Ly = Ly
        self.nx = nx
        self.ny = ny
        self.K = K
        
        self.dx = Lx / (nx - 1)
        self.dy = Ly / (ny - 1)
        
        self.x = np.linspace(0, Lx, nx)
        self.y = np.linspace(0, Ly, ny)
        self.X, self.Y = np.meshgrid(self.x, self.y)
        
        self.h = np.zeros((ny, nx))
    
    def solve_steady_state(self, h_boundary, W=None, tol=1e-6, max_iter=10000):
        """
        稳定流求解（Gauss-Seidel迭代）
        
        参数:
            h_boundary: 边界水头函数 h_boundary(i, j) 或 None
            W: 源汇项 (ny, nx) 数组 (m/day)
            tol: 收敛容差
            max_iter: 最大迭代次数
        
        返回:
            h: 水头分布
            n_iter: 迭代次数
        """
        if W is None:
            W = np.zeros((self.ny, self.nx))
        
        # 初始化（线性插值）
        if h_boundary is not None:
            for i in range(self.ny):
                for j in range(self.nx):
                    self.h[i, j] = h_boundary(i, j)
        
        # Gauss-Seidel迭代
        for iter_count in range(max_iter):
            h_old = self.h.copy()
            
            for i in range(1, self.ny - 1):
                for j in range(1, self.nx - 1):
                    # 五点差分格式
                    self.h[i, j] = (
                        (self.h[i+1, j] + self.h[i-1, j]) / self.dy**2 +
                        (self.h[i, j+1] + self.h[i, j-1]) / self.dx**2 -
                        W[i, j] / self.K
                    ) / (2 / self.dx**2 + 2 / self.dy**2)
            
            # 应用边界条件（Dirichlet）
            if h_boundary is not None:
                for i in range(self.ny):
                    self.h[i, 0] = h_boundary(i, 0)
                    self.h[i, -1] = h_boundary(i, -1)
                for j in range(self.nx):
                    self.h[0, j] = h_boundary(0, j)
                    self.h[-1, j] = h_boundary(-1, j)
            
            # 检查收敛
            error = np.max(np.abs(self.h - h_old))
            if error < tol:
                return self.h, iter_count + 1
        
        print("警告：未收敛")
        return self.h, max_iter
    
    def add_pumping_well(self, x_well, y_well, Q):
        """
        添加抽水井
        
        参数:
            x_well, y_well: 井位置
            Q: 抽水量 (m^3/day, 负值表示抽水)
        
        返回:
            W: 更新的源汇项
        """
        W = np.zeros((self.ny, self.nx))
        
        # 找到最近的网格点
        i = np.argmin(np.abs(self.y - y_well))
        j = np.argmin(np.abs(self.x - x_well))
        
        # 源汇项（分布在单元格）
        W[i, j] = Q / (self.dx * self.dy)
        
        return W
    
    def calculate_flow(self):
        """
        计算流速场（Darcy定律）
        
        返回:
            vx, vy: x和y方向流速 (m/day)
        """
        vx = np.zeros_like(self.h)
        vy = np.zeros_like(self.h)
        
        # 中心差分
        vx[:, 1:-1] = -self.K * (self.h[:, 2:] - self.h[:, :-2]) / (2 * self.dx)
        vy[1:-1, :] = -self.K * (self.h[2:, :] - self.h[:-2, :]) / (2 * self.dy)
        
        return vx, vy
    
    def plot_results(self, vx, vy):
        """可视化结果"""
        fig, axes = plt.subplots(1, 2, figsize=(14, 5))
        
        # 水头等值线
        ax = axes[0]
        contour = ax.contourf(self.X, self.Y, self.h, levels=20, cmap='viridis')
        ax.contour(self.X, self.Y, self.h, levels=10, colors='black',
                  linewidths=0.5, alpha=0.5)
        plt.colorbar(contour, ax=ax, label='水头 (m)')
        ax.set_xlabel('X (m)')
        ax.set_ylabel('Y (m)')
        ax.set_title('水头分布')
        ax.set_aspect('equal')
        
        # 流速场
        ax = axes[1]
        skip = 3
        Q_plot = ax.quiver(self.X[::skip, ::skip], self.Y[::skip, ::skip],
                          vx[::skip, ::skip], vy[::skip, ::skip],
                          scale=50, width=0.003)
        ax.quiverkey(Q_plot, 0.9, 0.95, 1, '1 m/day', labelpos='E')
        
        # 叠加水头等值线
        contour = ax.contour(self.X, self.Y, self.h, levels=10, colors='gray',
                            linewidths=0.8, alpha=0.6)
        ax.clabel(contour, inline=True, fontsize=8)
        
        ax.set_xlabel('X (m)')
        ax.set_ylabel('Y (m)')
        ax.set_title('流速场与水头等值线')
        ax.set_aspect('equal')
        
        plt.tight_layout()
        
        return fig


# 测试案例
print("\n" + "="*60)
print("案例2：地下水流数值模拟")
print("="*60)

# 初始化
gw = GroundwaterSimulation(Lx=1000, Ly=1000, nx=51, ny=51, K=10)

# 边界条件（西高东低）
def h_boundary(i, j):
    if j == 0:  # 西边界
        return 100
    elif j == gw.nx - 1:  # 东边界
        return 80
    elif i == 0 or i == gw.ny - 1:  # 南北边界（插值）
        return 100 - 20 * j / (gw.nx - 1)
    return None

# 添加抽水井
W1 = gw.add_pumping_well(300, 500, Q=-500)
W2 = gw.add_pumping_well(700, 500, Q=-500)
W_total = W1 + W2

# 求解
h, n_iter = gw.solve_steady_state(h_boundary, W=W_total, tol=1e-6)

print(f"迭代次数: {n_iter}")
print(f"最大水头: {h.max():.2f} m")
print(f"最小水头: {h.min():.2f} m")

# 计算流速
vx, vy = gw.calculate_flow()

# 可视化
fig = gw.plot_results(vx, vy)
plt.savefig('groundwater_simulation.png', dpi=300, bbox_inches='tight')
plt.show()
```

---

## 三、非恒定流数值模拟综合案例

### 3.1 问题描述

**Saint-Venant方程**（1D明渠非恒定流）：

**连续性方程**：
$$
\frac{\partial A}{\partial t} + \frac{\partial Q}{\partial x} = 0
$$

**动量方程**：
$$
\frac{\partial Q}{\partial t} + \frac{\partial}{\partial x}\left(\frac{Q^2}{A}\right) + gA\frac{\partial h}{\partial x} + gA(S_f - S_0) = 0
$$

其中摩阻坡度：$S_f = \frac{n^2 Q |Q|}{A^2 R^{4/3}}$

---

### 3.2 MacCormack格式实现

```python
class UnsteadyFlowSimulation:
    """非恒定流数值模拟"""
    
    def __init__(self, L, nx, b, n, S0, g=9.81):
        """
        参数:
            L: 河道长度 (m)
            nx: 网格数
            b: 河宽 (m)
            n: 曼宁系数
            S0: 河床坡度
            g: 重力加速度
        """
        self.L = L
        self.nx = nx
        self.b = b
        self.n = n
        self.S0 = S0
        self.g = g
        
        self.dx = L / (nx - 1)
        self.x = np.linspace(0, L, nx)
        
        # 状态变量
        self.h = np.zeros(nx)  # 水深
        self.Q = np.zeros(nx)  # 流量
    
    def initialize(self, h0, Q0):
        """初始化"""
        self.h[:] = h0
        self.Q[:] = Q0
    
    def compute_Sf(self, Q, h):
        """计算摩阻坡度"""
        A = self.b * h
        R = A / (self.b + 2 * h)
        
        # 避免除零
        A = np.maximum(A, 1e-6)
        R = np.maximum(R, 1e-6)
        
        Sf = self.n**2 * Q * np.abs(Q) / (A**2 * R**(4/3))
        
        return Sf
    
    def maccormack_step(self, dt, Q_upstream):
        """
        MacCormack格式单步
        
        参数:
            dt: 时间步长
            Q_upstream: 上游边界流量
        """
        h = self.h
        Q = self.Q
        g = self.g
        b = self.b
        dx = self.dx
        
        # 预测步（向前差分）
        h_pred = h.copy()
        Q_pred = Q.copy()
        
        A = b * h
        v = Q / A
        Sf = self.compute_Sf(Q, h)
        
        for i in range(self.nx - 1):
            # 连续性
            dAdx = (A[i+1] - A[i]) / dx
            dQdx = (Q[i+1] - Q[i]) / dx
            
            h_pred[i] = h[i] - dt / b * dQdx
            
            # 动量
            dQ2Adx = ((Q[i+1]**2 / A[i+1]) - (Q[i]**2 / A[i])) / dx
            dhdx = (h[i+1] - h[i]) / dx
            
            Q_pred[i] = Q[i] - dt * (dQ2Adx + g * A[i] * dhdx +
                                     g * A[i] * (Sf[i] - self.S0))
        
        # 上游边界
        Q_pred[0] = Q_upstream
        
        # 下游边界（零梯度）
        h_pred[-1] = h_pred[-2]
        Q_pred[-1] = Q_pred[-2]
        
        # 校正步（向后差分）
        A_pred = b * h_pred
        Sf_pred = self.compute_Sf(Q_pred, h_pred)
        
        for i in range(1, self.nx):
            # 连续性
            dQdx_pred = (Q_pred[i] - Q_pred[i-1]) / dx
            
            h_corr = h_pred[i] - dt / b * dQdx_pred
            
            # 动量
            dQ2Adx_pred = ((Q_pred[i]**2 / A_pred[i]) - 
                          (Q_pred[i-1]**2 / A_pred[i-1])) / dx
            dhdx_pred = (h_pred[i] - h_pred[i-1]) / dx
            
            Q_corr = Q_pred[i] - dt * (dQ2Adx_pred + 
                                       g * A_pred[i] * dhdx_pred +
                                       g * A_pred[i] * (Sf_pred[i] - self.S0))
            
            # 平均
            self.h[i] = 0.5 * (h[i] + h_corr)
            self.Q[i] = 0.5 * (Q[i] + Q_corr)
        
        # 边界
        self.Q[0] = Q_upstream
        self.h[-1] = self.h[-2]
        self.Q[-1] = self.Q[-2]
    
    def simulate(self, T, Q_upstream_func, CFL=0.5):
        """
        完整模拟
        
        参数:
            T: 总模拟时间 (s)
            Q_upstream_func: 上游流量函数 Q(t)
            CFL: CFL数
        
        返回:
            t_series: 时间序列
            h_series: 水深时间序列
            Q_series: 流量时间序列
        """
        t = 0
        t_series = [0]
        h_series = [self.h.copy()]
        Q_series = [self.Q.copy()]
        
        while t < T:
            # 计算时间步长（CFL条件）
            A = self.b * self.h
            v = self.Q / A
            c = np.sqrt(self.g * self.h)
            
            dt = CFL * self.dx / np.max(np.abs(v) + c)
            dt = min(dt, T - t)
            
            # 上游流量
            Q_up = Q_upstream_func(t)
            
            # 推进一步
            self.maccormack_step(dt, Q_up)
            
            t += dt
            t_series.append(t)
            h_series.append(self.h.copy())
            Q_series.append(self.Q.copy())
        
        return np.array(t_series), np.array(h_series), np.array(Q_series)


# 测试案例
print("\n" + "="*60)
print("案例3：非恒定流数值模拟（洪水演进）")
print("="*60)

# 初始化
ufs = UnsteadyFlowSimulation(L=10000, nx=101, b=50, n=0.03, S0=0.001)

# 初始条件（均匀流）
Q0 = 100
h0 = (Q0 * ufs.n / (ufs.b * np.sqrt(ufs.S0)))**(3/5)
ufs.initialize(h0, Q0)

print(f"初始水深: {h0:.2f} m")
print(f"初始流量: {Q0:.2f} m³/s")

# 上游洪水过程线（三角形）
def Q_upstream(t):
    T_rise = 3600  # 1小时涨水
    T_fall = 7200  # 2小时退水
    Q_peak = 500
    
    if t < T_rise:
        return Q0 + (Q_peak - Q0) * t / T_rise
    elif t < T_rise + T_fall:
        return Q_peak - (Q_peak - Q0) * (t - T_rise) / T_fall
    else:
        return Q0

# 模拟
T_sim = 4 * 3600  # 4小时
t_series, h_series, Q_series = ufs.simulate(T_sim, Q_upstream, CFL=0.8)

print(f"\n模拟完成！")
print(f"时间步数: {len(t_series)}")
print(f"最大水深: {h_series.max():.2f} m")
print(f"最大流量: {Q_series.max():.2f} m³/s")

# 可视化
fig = plt.figure(figsize=(14, 10))

# 3D水深演变
ax1 = fig.add_subplot(221, projection='3d')
X, T = np.meshgrid(ufs.x / 1000, t_series / 3600)
surf = ax1.plot_surface(X, T, h_series, cmap='viridis', alpha=0.8)
ax1.set_xlabel('距离 (km)')
ax1.set_ylabel('时间 (h)')
ax1.set_zlabel('水深 (m)')
ax1.set_title('水深时空演变')
plt.colorbar(surf, ax=ax1, shrink=0.5)

# 断面水深过程
ax2 = fig.add_subplot(222)
sections = [0, 25, 50, 75, 100]
for i, sec in enumerate(sections):
    ax2.plot(t_series / 3600, h_series[:, sec],
            label=f'x={ufs.x[sec]/1000:.1f}km', linewidth=2)
ax2.set_xlabel('时间 (h)')
ax2.set_ylabel('水深 (m)')
ax2.set_title('不同断面水深过程线')
ax2.legend()
ax2.grid(True, alpha=0.3)

# 流量过程
ax3 = fig.add_subplot(223)
for i, sec in enumerate(sections):
    ax3.plot(t_series / 3600, Q_series[:, sec],
            label=f'x={ufs.x[sec]/1000:.1f}km', linewidth=2)
ax3.set_xlabel('时间 (h)')
ax3.set_ylabel('流量 (m³/s)')
ax3.set_title('不同断面流量过程线')
ax3.legend()
ax3.grid(True, alpha=0.3)

# 水面线
ax4 = fig.add_subplot(224)
time_snapshots = [0, len(t_series)//4, len(t_series)//2, -1]
for i, t_idx in enumerate(time_snapshots):
    Z = h_series[t_idx, :] + ufs.x * ufs.S0  # 水面高程
    ax4.plot(ufs.x / 1000, Z,
            label=f't={t_series[t_idx]/3600:.1f}h', linewidth=2)

# 河床
Z_bed = ufs.x * ufs.S0
ax4.fill_between(ufs.x / 1000, Z_bed, alpha=0.3, color='brown', label='河床')

ax4.set_xlabel('距离 (km)')
ax4.set_ylabel('高程 (m)')
ax4.set_title('不同时刻水面线')
ax4.legend()
ax4.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('unsteady_flow_simulation.png', dpi=300, bbox_inches='tight')
plt.show()
```

---

## 四、本章总结

### 核心要点

1. **水库优化调度**：
   - 动态规划（全局最优，状态离散）
   - 差分进化（处理非线性约束）
   - 水位-库容非线性关系
   - 发电量计算

2. **地下水流模拟**：
   - 2D稳定流求解（Gauss-Seidel迭代）
   - 抽水井源汇项处理
   - 流速场计算（Darcy定律）
   - 水头等值线与流速场可视化

3. **非恒定流模拟**：
   - Saint-Venant方程组
   - MacCormack格式（预测-校正）
   - CFL条件稳定性
   - 洪水演进3D可视化

4. **综合应用能力**：
   - 数学建模
   - 算法实现
   - 结果可视化
   - 工程解释

---

**课程总结**：本书系统介绍了数值计算的核心方法，从数值积分、常微分方程、偏微分方程、特征值问题、优化方法到综合工程案例，为水利工程数值计算打下坚实基础。

**推荐实践**：
- 完成所有Python代码实现
- 对比不同算法性能
- 应用于实际工程问题
- 参加数学建模竞赛
