# 第4章：数值积分

**学习时间**: 4小时  
**考试频率**: ⭐⭐⭐⭐⭐  
**难度**: ⭐⭐⭐⭐

---

## 一、数值积分基本概念

### 1.1 基本思想

**目标**：计算定积分$\int_a^b f(x)dx$

**几何意义**：曲边梯形面积

**数值积分公式**：

$$\int_a^b f(x)dx \approx \sum_{i=0}^{n}A_i f(x_i)$$

**参数说明**：
- $A_i$：求积系数
- $x_i$：求积节点

---

### 1.2 代数精度

**定义**：若公式对$f(x) = x^k$（$k = 0, 1, \ldots, m$）精确成立，但对$f(x) = x^{m+1}$不精确，则称具有$m$次代数精度。

---

## 二、Newton-Cotes公式

### 2.1 梯形公式

**基本公式**（$n=1$）：

$$\int_a^b f(x)dx \approx \frac{b-a}{2}[f(a) + f(b)]$$

**几何意义**：用梯形面积近似

**误差估计**：

$$R = -\frac{(b-a)^3}{12}f''(\xi), \quad \xi \in (a, b)$$

**代数精度**：1次

---

### 2.2 Simpson公式（抛物线法）

**基本公式**（$n=2$）：

$$\int_a^b f(x)dx \approx \frac{b-a}{6}\left[f(a) + 4f\left(\frac{a+b}{2}\right) + f(b)\right]$$

**几何意义**：用抛物线拟合

**误差估计**：

$$R = -\frac{(b-a)^5}{2880}f^{(4)}(\xi)$$

**代数精度**：3次

---

### 2.3 Simpson 3/8公式

**基本公式**（$n=3$）：

$$\int_a^b f(x)dx \approx \frac{b-a}{8}\left[f(a) + 3f\left(a+\frac{h}{3}\right) + 3f\left(a+\frac{2h}{3}\right) + f(b)\right]$$

其中$h = b - a$

---

## 三、复化求积公式

### 3.1 复化梯形公式

**将$[a, b]$分成$n$等份**，$h = \frac{b-a}{n}$，$x_i = a + ih$

$$T_n = \frac{h}{2}\left[f(a) + 2\sum_{i=1}^{n-1}f(x_i) + f(b)\right]$$

**简化形式**：

$$T_n = \frac{h}{2}\left[f_0 + 2(f_1 + f_2 + \cdots + f_{n-1}) + f_n\right]$$

**误差估计**：

$$R = -\frac{b-a}{12}h^2 f''(\xi)$$

**收敛性**：$O(h^2)$

---

### 3.2 复化Simpson公式

$$S_n = \frac{h}{6}\left[f(a) + 4\sum_{i=0}^{n-1}f(x_{i+1/2}) + 2\sum_{i=1}^{n-1}f(x_i) + f(b)\right]$$

其中$x_{i+1/2} = \frac{x_i + x_{i+1}}{2}$

**误差估计**：

$$R = -\frac{b-a}{180}h^4 f^{(4)}(\xi)$$

**收敛性**：$O(h^4)$

---

## 四、Romberg积分（Richardson外推）

### 4.1 基本思想

**递推关系**：

$$T_m^{(k+1)} = \frac{4^{k+1}T_m^{(k)} - T_{m-1}^{(k)}}{4^{k+1} - 1}$$

**初始**：$T_m^{(0)} = T_{2^m}$（复化梯形）

**Romberg序列**：

| $m$ | $T^{(0)}$ | $T^{(1)}$ | $T^{(2)}$ | $T^{(3)}$ |
|-----|----------|----------|----------|----------|
| 0   | $T_1$    |          |          |          |
| 1   | $T_2$    | $S_1$    |          |          |
| 2   | $T_4$    | $S_2$    | $C_1$    |          |
| 3   | $T_8$    | $S_4$    | $C_2$    | $R_1$    |

**注**：
- $T^{(1)}$列为Simpson公式
- $T^{(2)}$列为Cotes公式
- $T^{(3)}$列为Romberg公式

---

### 4.2 停止准则

$$|T_m^{(k)} - T_{m-1}^{(k)}| < \varepsilon$$

---

## 五、Gauss型求积公式

### 5.1 基本思想

**最优选点**：节点$x_i$可自由选取（不必等距）

**Gauss-Legendre公式**（$[-1, 1]$区间）：

$$\int_{-1}^{1}f(x)dx \approx \sum_{i=1}^{n}A_i f(x_i)$$

**节点**：Legendre多项式$P_n(x)$的零点

**权重**：$A_i = \int_{-1}^{1}l_i(x)dx$

**代数精度**：$2n-1$次

---

### 5.2 常用Gauss点

**$n=2$**：
- $x_1 = -\frac{1}{\sqrt{3}}, \quad x_2 = \frac{1}{\sqrt{3}}$
- $A_1 = A_2 = 1$

$$\int_{-1}^{1}f(x)dx \approx f\left(-\frac{1}{\sqrt{3}}\right) + f\left(\frac{1}{\sqrt{3}}\right)$$

**$n=3$**：
- $x_1 = -\sqrt{\frac{3}{5}}, \quad x_2 = 0, \quad x_3 = \sqrt{\frac{3}{5}}$
- $A_1 = A_3 = \frac{5}{9}, \quad A_2 = \frac{8}{9}$

---

### 5.3 区间变换

**变换到$[a, b]$**：

$$\int_a^b f(x)dx = \frac{b-a}{2}\int_{-1}^{1}f\left(\frac{b-a}{2}t + \frac{a+b}{2}\right)dt$$

---

## 六、Python实现

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy import integrate

class NumericalIntegration:
    """数值积分"""
    
    @staticmethod
    def trapezoidal(f, a, b, n=100):
        """
        复化梯形公式
        
        参数:
            f: 被积函数
            a, b: 积分区间
            n: 分段数
        """
        h = (b - a) / n
        x = np.linspace(a, b, n + 1)
        y = f(x)
        
        # T_n = h/2 * [f(a) + 2*sum(f_i) + f(b)]
        integral = h / 2 * (y[0] + 2 * np.sum(y[1:-1]) + y[-1])
        
        return integral
    
    @staticmethod
    def simpson(f, a, b, n=100):
        """
        复化Simpson公式
        
        参数:
            f: 被积函数
            a, b: 积分区间
            n: 分段数（必须为偶数）
        """
        if n % 2 != 0:
            n += 1  # 确保n为偶数
        
        h = (b - a) / n
        x = np.linspace(a, b, n + 1)
        y = f(x)
        
        # S_n = h/3 * [f(a) + 4*sum(f_奇) + 2*sum(f_偶) + f(b)]
        integral = h / 3 * (y[0] + 4 * np.sum(y[1:-1:2]) + 2 * np.sum(y[2:-1:2]) + y[-1])
        
        return integral
    
    @staticmethod
    def romberg(f, a, b, tol=1e-6, max_iter=20):
        """
        Romberg积分
        
        参数:
            f: 被积函数
            a, b: 积分区间
            tol: 容许误差
            max_iter: 最大迭代次数
        
        返回:
            integral: 积分值
            R_table: Romberg表
        """
        R = np.zeros((max_iter, max_iter))
        
        # 初始化第一列（复化梯形）
        h = b - a
        R[0, 0] = h / 2 * (f(a) + f(b))
        
        for m in range(1, max_iter):
            # 计算T_{2^m}
            h = h / 2
            sum_val = 0
            for k in range(1, 2**m, 2):
                x_k = a + k * h
                sum_val += f(x_k)
            
            R[m, 0] = R[m-1, 0] / 2 + h * sum_val
            
            # Richardson外推
            for k in range(1, m + 1):
                R[m, k] = (4**k * R[m, k-1] - R[m-1, k-1]) / (4**k - 1)
            
            # 检查收敛
            if m > 0 and abs(R[m, m] - R[m-1, m-1]) < tol:
                return R[m, m], R[:m+1, :m+1]
        
        return R[max_iter-1, max_iter-1], R
    
    @staticmethod
    def gauss_legendre(f, a, b, n=2):
        """
        Gauss-Legendre求积公式
        
        参数:
            f: 被积函数
            a, b: 积分区间
            n: 求积点数（2, 3, 4, 5）
        """
        # 预定义节点和权重（对应[-1, 1]区间）
        nodes_weights = {
            2: (
                np.array([-1/np.sqrt(3), 1/np.sqrt(3)]),
                np.array([1, 1])
            ),
            3: (
                np.array([-np.sqrt(3/5), 0, np.sqrt(3/5)]),
                np.array([5/9, 8/9, 5/9])
            ),
            4: (
                np.array([-0.861136, -0.339981, 0.339981, 0.861136]),
                np.array([0.347855, 0.652145, 0.652145, 0.347855])
            ),
            5: (
                np.array([-0.906180, -0.538469, 0, 0.538469, 0.906180]),
                np.array([0.236927, 0.478629, 0.568889, 0.478629, 0.236927])
            )
        }
        
        nodes, weights = nodes_weights[n]
        
        # 变换到[a, b]
        x_transformed = (b - a) / 2 * nodes + (a + b) / 2
        
        # 计算积分
        integral = (b - a) / 2 * np.sum(weights * f(x_transformed))
        
        return integral
    
    @staticmethod
    def adaptive_simpson(f, a, b, tol=1e-6, max_depth=50):
        """
        自适应Simpson积分
        
        参数:
            f: 被积函数
            a, b: 积分区间
            tol: 容许误差
            max_depth: 最大递归深度
        """
        def simpson_basic(f, a, b):
            """基本Simpson公式"""
            h = b - a
            c = (a + b) / 2
            return h / 6 * (f(a) + 4*f(c) + f(b))
        
        def adaptive_recursive(f, a, b, tol, S_ab, fa, fb, fc, depth):
            """递归细分"""
            if depth > max_depth:
                return S_ab
            
            c = (a + b) / 2
            d = (a + c) / 2
            e = (c + b) / 2
            
            fd = f(d)
            fe = f(e)
            
            S_ac = (c - a) / 6 * (fa + 4*fd + fc)
            S_cb = (b - c) / 6 * (fc + 4*fe + fb)
            S_ab_new = S_ac + S_cb
            
            # 误差估计
            error = abs(S_ab_new - S_ab) / 15
            
            if error < tol:
                return S_ab_new + error  # Richardson外推修正
            else:
                left = adaptive_recursive(f, a, c, tol/2, S_ac, fa, fc, fd, depth+1)
                right = adaptive_recursive(f, c, b, tol/2, S_cb, fc, fb, fe, depth+1)
                return left + right
        
        fa = f(a)
        fb = f(b)
        fc = f((a + b) / 2)
        S_ab = simpson_basic(f, a, b)
        
        return adaptive_recursive(f, a, b, tol, S_ab, fa, fb, fc, 0)
    
    @staticmethod
    def plot_integration_comparison():
        """绘制数值积分方法对比"""
        fig, axes = plt.subplots(2, 2, figsize=(16, 12))
        
        # 测试函数
        def f(x):
            return np.sin(x) + 0.1 * x**2
        
        a, b = 0, np.pi
        exact = integrate.quad(f, a, b)[0]
        
        # 1. 不同方法精度对比
        ax1 = axes[0, 0]
        
        n_values = np.array([4, 8, 16, 32, 64, 128])
        
        errors_trap = []
        errors_simp = []
        errors_gauss = []
        
        for n in n_values:
            I_trap = NumericalIntegration.trapezoidal(f, a, b, n)
            I_simp = NumericalIntegration.simpson(f, a, b, n)
            I_gauss = NumericalIntegration.gauss_legendre(f, a, b, min(n//16+2, 5))
            
            errors_trap.append(abs(I_trap - exact))
            errors_simp.append(abs(I_simp - exact))
            errors_gauss.append(abs(I_gauss - exact))
        
        ax1.loglog(n_values, errors_trap, 'bo-', linewidth=2, markersize=8, label='梯形公式')
        ax1.loglog(n_values, errors_simp, 'rs-', linewidth=2, markersize=8, label='Simpson公式')
        ax1.loglog(n_values, errors_gauss, 'g^-', linewidth=2, markersize=8, label='Gauss公式')
        
        # 参考线
        ax1.loglog(n_values, 1/n_values**2, 'k--', linewidth=1, alpha=0.5, label='O(h²)')
        ax1.loglog(n_values, 1/n_values**4, 'k:', linewidth=1, alpha=0.5, label='O(h⁴)')
        
        ax1.set_xlabel('分段数 n', fontsize=11)
        ax1.set_ylabel('误差', fontsize=11)
        ax1.set_title('数值积分方法精度对比', fontsize=13, fontweight='bold')
        ax1.legend()
        ax1.grid(True, alpha=0.3, which='both')
        
        # 2. Romberg积分收敛
        ax2 = axes[0, 1]
        
        I_rom, R_table = NumericalIntegration.romberg(f, a, b, tol=1e-10)
        
        # 绘制Romberg表的对角线元素
        m_rom = R_table.shape[0]
        diagonal = [R_table[i, i] for i in range(m_rom)]
        errors_rom = [abs(val - exact) for val in diagonal]
        
        ax2.semilogy(range(m_rom), errors_rom, 'mo-', linewidth=2.5, markersize=10)
        ax2.set_xlabel('Romberg迭代次数', fontsize=11)
        ax2.set_ylabel('误差', fontsize=11)
        ax2.set_title(f'Romberg积分收敛（精确值={exact:.10f}）', fontsize=13, fontweight='bold')
        ax2.grid(True, alpha=0.3, which='both')
        
        # 3. 几何意义演示
        ax3 = axes[1, 0]
        
        n_demo = 6
        x_fine = np.linspace(a, b, 500)
        y_fine = f(x_fine)
        
        ax3.plot(x_fine, y_fine, 'b-', linewidth=2.5, label='f(x)')
        ax3.fill_between(x_fine, 0, y_fine, alpha=0.2, color='cyan')
        
        # 梯形逼近
        x_trap = np.linspace(a, b, n_demo + 1)
        y_trap = f(x_trap)
        
        for i in range(n_demo):
            x_seg = [x_trap[i], x_trap[i+1], x_trap[i+1], x_trap[i]]
            y_seg = [0, 0, y_trap[i+1], y_trap[i]]
            ax3.fill(x_seg, y_seg, alpha=0.3, edgecolor='red', facecolor='none', linewidth=2)
        
        ax3.scatter(x_trap, y_trap, color='red', s=50, zorder=5)
        
        ax3.set_xlabel('x', fontsize=11)
        ax3.set_ylabel('f(x)', fontsize=11)
        ax3.set_title(f'梯形公式几何意义（n={n_demo}）', fontsize=13, fontweight='bold')
        ax3.legend()
        ax3.grid(True, alpha=0.3)
        
        # 4. Gauss点分布
        ax4 = axes[1, 1]
        
        gauss_n = [2, 3, 4, 5]
        colors = plt.cm.Set3(np.linspace(0, 1, len(gauss_n)))
        
        for i, n_g in enumerate(gauss_n):
            if n_g == 2:
                nodes = np.array([-1/np.sqrt(3), 1/np.sqrt(3)])
            elif n_g == 3:
                nodes = np.array([-np.sqrt(3/5), 0, np.sqrt(3/5)])
            elif n_g == 4:
                nodes = np.array([-0.861136, -0.339981, 0.339981, 0.861136])
            elif n_g == 5:
                nodes = np.array([-0.906180, -0.538469, 0, 0.538469, 0.906180])
            
            y_pos = np.ones(len(nodes)) * (i + 1)
            ax4.scatter(nodes, y_pos, s=150, color=colors[i], edgecolor='black',
                       linewidth=2, zorder=5, label=f'n={n_g}')
        
        ax4.axvline(0, color='k', linestyle='--', linewidth=1, alpha=0.5)
        ax4.set_xlabel('节点位置（[-1, 1]区间）', fontsize=11)
        ax4.set_yticks(range(1, len(gauss_n)+1))
        ax4.set_yticklabels([f'n={n}' for n in gauss_n])
        ax4.set_title('Gauss-Legendre求积节点分布', fontsize=13, fontweight='bold')
        ax4.legend()
        ax4.grid(True, alpha=0.3, axis='x')
        ax4.set_xlim([-1.2, 1.2])
        
        plt.tight_layout()
        plt.savefig('numerical_integration_comparison.png', dpi=300)
        plt.show()

# 示例1：基本积分公式对比
print("="*60)
print("示例1：数值积分方法对比")
print("="*60)

ni = NumericalIntegration()

def f1(x):
    return np.exp(-x**2)

a, b = 0, 1
exact = integrate.quad(f1, a, b)[0]

print(f"被积函数: f(x) = e^(-x²)")
print(f"积分区间: [{a}, {b}]")
print(f"精确值: {exact:.10f}")

n = 10

I_trap = ni.trapezoidal(f1, a, b, n)
I_simp = ni.simpson(f1, a, b, n)
I_gauss2 = ni.gauss_legendre(f1, a, b, 2)
I_gauss3 = ni.gauss_legendre(f1, a, b, 3)

print(f"\nn={n}时各方法结果:")
print(f"{'方法':<20s} {'积分值':<18s} {'误差':<15s}")
print("-" * 55)
print(f"{'梯形公式':<20s} {I_trap:<18.10f} {abs(I_trap-exact):<15.2e}")
print(f"{'Simpson公式':<20s} {I_simp:<18.10f} {abs(I_simp-exact):<15.2e}")
print(f"{'Gauss(n=2)':<20s} {I_gauss2:<18.10f} {abs(I_gauss2-exact):<15.2e}")
print(f"{'Gauss(n=3)':<20s} {I_gauss3:<18.10f} {abs(I_gauss3-exact):<15.2e}")

# 示例2：Romberg积分
print("\n" + "="*60)
print("示例2：Romberg积分法")
print("="*60)

def f2(x):
    return 1 / (1 + x**2)

a2, b2 = 0, 1
exact2 = np.pi / 4  # arctan(1) - arctan(0)

print(f"被积函数: f(x) = 1/(1+x²)")
print(f"积分区间: [{a2}, {b2}]")
print(f"精确值: π/4 = {exact2:.10f}")

I_rom, R_table = ni.romberg(f2, a2, b2, tol=1e-10)

print(f"\nRomberg积分表:")
m_rom = R_table.shape[0]

for i in range(m_rom):
    row_str = f"m={i}: "
    for j in range(i + 1):
        row_str += f"{R_table[i, j]:12.8f}  "
    print(row_str)

print(f"\n最终结果: {I_rom:.10f}")
print(f"误差: {abs(I_rom - exact2):.2e}")

# 示例3：自适应积分
print("\n" + "="*60)
print("示例3：自适应Simpson积分")
print("="*60)

def f3(x):
    """震荡函数"""
    return np.sin(10 * x) * np.exp(-x)

a3, b3 = 0, 2
exact3 = integrate.quad(f3, a3, b3)[0]

I_adapt = ni.adaptive_simpson(f3, a3, b3, tol=1e-6)

print(f"被积函数: f(x) = sin(10x)·e^(-x)")
print(f"积分区间: [{a3}, {b3}]")
print(f"精确值: {exact3:.10f}")
print(f"自适应Simpson: {I_adapt:.10f}")
print(f"误差: {abs(I_adapt - exact3):.2e}")

# 示例4：Gauss求积精度验证
print("\n" + "="*60)
print("示例4：Gauss求积的代数精度")
print("="*60)

print("验证Gauss-Legendre公式的代数精度")
print("（n点Gauss公式对x^k精确，k≤2n-1）\n")

for n_gauss in [2, 3]:
    print(f"n={n_gauss} Gauss公式（理论精度：{2*n_gauss-1}次）:")
    print(f"{'k':<5s} {'精确积分':<15s} {'Gauss积分':<15s} {'误差':<12s}")
    print("-" * 50)
    
    for k in range(2*n_gauss + 2):
        def f_poly(x):
            return x**k
        
        exact_poly = integrate.quad(f_poly, -1, 1)[0]
        gauss_poly = ni.gauss_legendre(f_poly, -1, 1, n_gauss)
        
        error = abs(gauss_poly - exact_poly)
        
        print(f"{k:<5d} {exact_poly:<15.10f} {gauss_poly:<15.10f} {error:<12.2e}")
    
    print()

# 绘制对比图
print("绘制数值积分方法对比图...")
ni.plot_integration_comparison()
```

---

## 八、典型考题

### 【例题1】Simpson公式（10分）

**题目**：用Simpson公式计算$\int_0^1 e^{-x^2}dx$（保留6位小数）。

**【解答】**

$$\int_0^1 e^{-x^2}dx \approx \frac{1-0}{6}\left[e^0 + 4e^{-(0.5)^2} + e^{-1}\right]$$

$$= \frac{1}{6}(1 + 4 \times 0.7788 + 0.3679) = \frac{1}{6} \times 4.4831 = 0.747183$$

---

### 【例题2】复化梯形（12分）

**题目**：用$n=4$的复化梯形公式计算$\int_0^2 x^2 dx$。

**【解答】**

$h = 0.5$，$x_0=0, x_1=0.5, x_2=1.0, x_3=1.5, x_4=2.0$

$$T_4 = \frac{0.5}{2}[0 + 2(0.25 + 1 + 2.25) + 4] = 0.25 \times 11 = 2.75$$

精确值：$\frac{8}{3} = 2.667$，误差0.083

---

**本章重点**：
- 梯形/Simpson公式
- 复化求积
- Romberg积分
- Gauss求积

**下一章**：常微分方程初值问题
