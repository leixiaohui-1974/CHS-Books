# ğŸ“Š å­¦ä¹ è¿›åº¦è¿½è¸ªç³»ç»Ÿè®¾è®¡

**ç‰ˆæœ¬**: v1.0  
**åˆ¶å®šæ—¥æœŸ**: 2025-11-12  
**è´Ÿè´£æ¨¡å—**: å­¦ä¹ æ•°æ®é‡‡é›†ä¸åˆ†æ

---

## ğŸ“‹ ç›®å½•

- [ç³»ç»Ÿæ¦‚è¿°](#ç³»ç»Ÿæ¦‚è¿°)
- [æ•°æ®æ¨¡å‹](#æ•°æ®æ¨¡å‹)
- [è¿½è¸ªæœºåˆ¶](#è¿½è¸ªæœºåˆ¶)
- [å¯è§†åŒ–è®¾è®¡](#å¯è§†åŒ–è®¾è®¡)
- [åˆ†æç®—æ³•](#åˆ†æç®—æ³•)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)

---

## ğŸ¯ ç³»ç»Ÿæ¦‚è¿°

### è®¾è®¡ç›®æ ‡

```
ç›®æ ‡ä½“ç³»
â”œâ”€â”€ å…¨é¢è¿½è¸ª
â”‚   â”œâ”€â”€ å­¦ä¹ æ—¶é•¿ç»Ÿè®¡
â”‚   â”œâ”€â”€ ç« èŠ‚è¿›åº¦è®°å½•
â”‚   â”œâ”€â”€ ç»ƒä¹ å®Œæˆæƒ…å†µ
â”‚   â””â”€â”€ çŸ¥è¯†ç‚¹æŒæ¡åº¦
â”‚
â”œâ”€â”€ æ™ºèƒ½åˆ†æ
â”‚   â”œâ”€â”€ å­¦ä¹ æ¨¡å¼è¯†åˆ«
â”‚   â”œâ”€â”€ è–„å¼±ç¯èŠ‚è¯Šæ–­
â”‚   â”œâ”€â”€ è¿›æ­¥è¶‹åŠ¿åˆ†æ
â”‚   â””â”€â”€ ä¸ªæ€§åŒ–å»ºè®®
â”‚
â”œâ”€â”€ æ¿€åŠ±æœºåˆ¶
â”‚   â”œâ”€â”€ æˆå°±ç³»ç»Ÿ
â”‚   â”œâ”€â”€ å­¦ä¹ æ’è¡Œ
â”‚   â”œâ”€â”€ è¿ç»­å­¦ä¹ å¥–åŠ±
â”‚   â””â”€â”€ é‡Œç¨‹ç¢‘åº†ç¥
â”‚
â””â”€â”€ æ•°æ®å¯è§†åŒ–
    â”œâ”€â”€ è¿›åº¦ä»ªè¡¨ç›˜
    â”œâ”€â”€ è¶‹åŠ¿å›¾è¡¨
    â”œâ”€â”€ é›·è¾¾å›¾åˆ†æ
    â””â”€â”€ å¯¹æ¯”å±•ç¤º
```

### æ ¸å¿ƒæŒ‡æ ‡

```
å­¦ä¹ æŒ‡æ ‡ä½“ç³»
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                            â”‚
â”‚  åŸºç¡€æŒ‡æ ‡                                   â”‚
â”‚  â”œâ”€ å­¦ä¹ å¤©æ•°: æ€»å­¦ä¹ å¤©æ•°                    â”‚
â”‚  â”œâ”€ å­¦ä¹ æ—¶é•¿: ç´¯è®¡åˆ†é’Ÿæ•°                    â”‚
â”‚  â”œâ”€ å®Œæˆç« èŠ‚: å·²å®Œæˆ/æ€»ç« èŠ‚                 â”‚
â”‚  â”œâ”€ ç»ƒä¹ æ•°é‡: å·²å®Œæˆ/æ€»ç»ƒä¹                  â”‚
â”‚  â””â”€ æµ‹è¯•åˆ†æ•°: å¹³å‡åˆ†/æœ€é«˜åˆ†                 â”‚
â”‚                                            â”‚
â”‚  è¿›é˜¶æŒ‡æ ‡                                   â”‚
â”‚  â”œâ”€ è¿ç»­å¤©æ•°: æœ€é•¿è¿ç»­å­¦ä¹ å¤©æ•°              â”‚
â”‚  â”œâ”€ æ´»è·ƒåº¦: æ—¥å‡å­¦ä¹ æ—¶é•¿                    â”‚
â”‚  â”œâ”€ å®Œæˆç‡: è®¡åˆ’å®Œæˆåº¦                      â”‚
â”‚  â”œâ”€ æ­£ç¡®ç‡: ç»ƒä¹ æ­£ç¡®ç‡                      â”‚
â”‚  â””â”€ è¿›æ­¥é€Ÿåº¦: å­¦ä¹ æ•ˆç‡è¶‹åŠ¿                  â”‚
â”‚                                            â”‚
â”‚  é«˜çº§æŒ‡æ ‡                                   â”‚
â”‚  â”œâ”€ çŸ¥è¯†è¦†ç›–: çŸ¥è¯†ç‚¹æŒæ¡åº¦                  â”‚
â”‚  â”œâ”€ å­¦ä¹ æ·±åº¦: å¤ä¹ æ¬¡æ•°ä¸æ·±åº¦                â”‚
â”‚  â”œâ”€ åº”ç”¨èƒ½åŠ›: å®è·µé¡¹ç›®å®Œæˆåº¦                â”‚
â”‚  â””â”€ ç»¼åˆè¯„åˆ†: åŠ æƒç»¼åˆå¾—åˆ†                  â”‚
â”‚                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’¾ æ•°æ®æ¨¡å‹

### æ•°æ®åº“è®¾è®¡

```sql
-- å­¦ä¹ è¿›åº¦è¡¨
CREATE TABLE learning_progress (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    chapter_id BIGINT NOT NULL REFERENCES chapters(id) ON DELETE CASCADE,
    
    -- è¿›åº¦ä¿¡æ¯
    progress INT DEFAULT 0 CHECK (progress >= 0 AND progress <= 100),
    last_position INT DEFAULT 0,  -- é˜…è¯»ä½ç½®
    completed BOOLEAN DEFAULT FALSE,
    
    -- æ—¶é—´ç»Ÿè®¡
    time_spent INT DEFAULT 0,  -- ç§’
    start_time TIMESTAMP,
    last_access TIMESTAMP,
    completed_at TIMESTAMP,
    
    -- äº¤äº’æ•°æ®
    scroll_depth INT DEFAULT 0,  -- æ»šåŠ¨æ·±åº¦ç™¾åˆ†æ¯”
    interactions JSONB DEFAULT '{}',  -- äº¤äº’è®°å½•
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(user_id, chapter_id)
);

CREATE INDEX idx_progress_user ON learning_progress(user_id);
CREATE INDEX idx_progress_chapter ON learning_progress(chapter_id);
CREATE INDEX idx_progress_updated ON learning_progress(updated_at);

-- ç»ƒä¹ è®°å½•è¡¨
CREATE TABLE exercise_records (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    exercise_id BIGINT NOT NULL REFERENCES exercises(id) ON DELETE CASCADE,
    
    -- æäº¤ä¿¡æ¯
    code TEXT,
    language VARCHAR(20),
    result JSONB,  -- æ‰§è¡Œç»“æœ
    
    -- è¯„åˆ†ä¿¡æ¯
    score INT,
    max_score INT,
    passed BOOLEAN,
    
    -- å°è¯•ç»Ÿè®¡
    attempt_number INT DEFAULT 1,
    time_spent INT DEFAULT 0,  -- ç§’
    
    -- é”™è¯¯ä¿¡æ¯
    errors JSONB,
    hints_used INT DEFAULT 0,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP
);

CREATE INDEX idx_exercise_user ON exercise_records(user_id);
CREATE INDEX idx_exercise_id ON exercise_records(exercise_id);
CREATE INDEX idx_exercise_created ON exercise_records(created_at);

-- å­¦ä¹ ä¼šè¯è¡¨
CREATE TABLE learning_sessions (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- ä¼šè¯ä¿¡æ¯
    start_time TIMESTAMP NOT NULL,
    end_time TIMESTAMP,
    duration INT,  -- ç§’
    
    -- å­¦ä¹ å†…å®¹
    chapters_visited INT[] DEFAULT '{}',
    exercises_attempted INT[] DEFAULT '{}',
    
    -- æ´»åŠ¨ç»Ÿè®¡
    page_views INT DEFAULT 0,
    code_runs INT DEFAULT 0,
    searches INT DEFAULT 0,
    
    -- è®¾å¤‡ä¿¡æ¯
    device_type VARCHAR(20),
    platform VARCHAR(50),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_session_user ON learning_sessions(user_id);
CREATE INDEX idx_session_start ON learning_sessions(start_time);

-- çŸ¥è¯†ç‚¹æŒæ¡è¡¨
CREATE TABLE knowledge_mastery (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    knowledge_point_id BIGINT NOT NULL REFERENCES knowledge_points(id) ON DELETE CASCADE,
    
    -- æŒæ¡åº¦
    mastery_level VARCHAR(20) DEFAULT 'beginner',  -- beginner, intermediate, advanced, master
    confidence_score FLOAT DEFAULT 0.0 CHECK (confidence_score >= 0 AND confidence_score <= 1),
    
    -- å­¦ä¹ ç»Ÿè®¡
    study_count INT DEFAULT 0,
    practice_count INT DEFAULT 0,
    correct_count INT DEFAULT 0,
    wrong_count INT DEFAULT 0,
    
    -- æ—¶é—´ä¿¡æ¯
    first_learned TIMESTAMP,
    last_reviewed TIMESTAMP,
    next_review TIMESTAMP,  -- é—´éš”é‡å¤å­¦ä¹ 
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(user_id, knowledge_point_id)
);

CREATE INDEX idx_mastery_user ON knowledge_mastery(user_id);
CREATE INDEX idx_mastery_point ON knowledge_mastery(knowledge_point_id);
CREATE INDEX idx_mastery_next_review ON knowledge_mastery(next_review);

-- å­¦ä¹ ç»Ÿè®¡æ±‡æ€»è¡¨
CREATE TABLE learning_statistics (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    date DATE NOT NULL,
    
    -- æ¯æ—¥ç»Ÿè®¡
    study_time INT DEFAULT 0,  -- ç§’
    chapters_completed INT DEFAULT 0,
    exercises_completed INT DEFAULT 0,
    tests_taken INT DEFAULT 0,
    
    -- å¾—åˆ†ç»Ÿè®¡
    total_score INT DEFAULT 0,
    average_score FLOAT,
    
    -- æ´»åŠ¨ç»Ÿè®¡
    login_count INT DEFAULT 0,
    page_views INT DEFAULT 0,
    code_runs INT DEFAULT 0,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(user_id, date)
);

CREATE INDEX idx_stats_user ON learning_statistics(user_id);
CREATE INDEX idx_stats_date ON learning_statistics(date);

-- å­¦ä¹ æˆå°±è¡¨
CREATE TABLE achievements (
    id BIGSERIAL PRIMARY KEY,
    code VARCHAR(50) UNIQUE NOT NULL,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    icon VARCHAR(200),
    category VARCHAR(50),  -- learning, practice, milestone, social
    points INT DEFAULT 0,
    rarity VARCHAR(20) DEFAULT 'common',  -- common, rare, epic, legendary
    conditions JSONB NOT NULL,  -- è¾¾æˆæ¡ä»¶
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ç”¨æˆ·æˆå°±è¡¨
CREATE TABLE user_achievements (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    achievement_id BIGINT NOT NULL REFERENCES achievements(id) ON DELETE CASCADE,
    progress FLOAT DEFAULT 0.0,  -- è¿›åº¦ 0-1
    completed BOOLEAN DEFAULT FALSE,
    completed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(user_id, achievement_id)
);

CREATE INDEX idx_user_ach_user ON user_achievements(user_id);
CREATE INDEX idx_user_ach_completed ON user_achievements(completed);
```

### SQLAlchemyæ¨¡å‹

```python
from sqlalchemy import Column, Integer, BigInteger, String, Text, Boolean, Float, TIMESTAMP, Date, JSON, ARRAY
from sqlalchemy.orm import relationship
from datetime import datetime

class LearningProgress(Base):
    __tablename__ = 'learning_progress'
    
    id = Column(BigInteger, primary_key=True)
    user_id = Column(BigInteger, ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    chapter_id = Column(BigInteger, ForeignKey('chapters.id', ondelete='CASCADE'), nullable=False)
    
    progress = Column(Integer, default=0)
    last_position = Column(Integer, default=0)
    completed = Column(Boolean, default=False)
    
    time_spent = Column(Integer, default=0)
    start_time = Column(TIMESTAMP)
    last_access = Column(TIMESTAMP)
    completed_at = Column(TIMESTAMP)
    
    scroll_depth = Column(Integer, default=0)
    interactions = Column(JSON, default={})
    
    created_at = Column(TIMESTAMP, default=datetime.utcnow)
    updated_at = Column(TIMESTAMP, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # å…³ç³»
    user = relationship("User", back_populates="learning_progress")
    chapter = relationship("Chapter", back_populates="progress_records")

class ExerciseRecord(Base):
    __tablename__ = 'exercise_records'
    
    id = Column(BigInteger, primary_key=True)
    user_id = Column(BigInteger, ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    exercise_id = Column(BigInteger, ForeignKey('exercises.id', ondelete='CASCADE'), nullable=False)
    
    code = Column(Text)
    language = Column(String(20))
    result = Column(JSON)
    
    score = Column(Integer)
    max_score = Column(Integer)
    passed = Column(Boolean)
    
    attempt_number = Column(Integer, default=1)
    time_spent = Column(Integer, default=0)
    
    errors = Column(JSON)
    hints_used = Column(Integer, default=0)
    
    created_at = Column(TIMESTAMP, default=datetime.utcnow)
    completed_at = Column(TIMESTAMP)
    
    user = relationship("User", back_populates="exercise_records")
    exercise = relationship("Exercise", back_populates="records")

class LearningSession(Base):
    __tablename__ = 'learning_sessions'
    
    id = Column(BigInteger, primary_key=True)
    user_id = Column(BigInteger, ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    
    start_time = Column(TIMESTAMP, nullable=False)
    end_time = Column(TIMESTAMP)
    duration = Column(Integer)
    
    chapters_visited = Column(ARRAY(Integer), default=[])
    exercises_attempted = Column(ARRAY(Integer), default=[])
    
    page_views = Column(Integer, default=0)
    code_runs = Column(Integer, default=0)
    searches = Column(Integer, default=0)
    
    device_type = Column(String(20))
    platform = Column(String(50))
    
    created_at = Column(TIMESTAMP, default=datetime.utcnow)
    
    user = relationship("User", back_populates="sessions")

class KnowledgeMastery(Base):
    __tablename__ = 'knowledge_mastery'
    
    id = Column(BigInteger, primary_key=True)
    user_id = Column(BigInteger, ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    knowledge_point_id = Column(BigInteger, ForeignKey('knowledge_points.id', ondelete='CASCADE'), nullable=False)
    
    mastery_level = Column(String(20), default='beginner')
    confidence_score = Column(Float, default=0.0)
    
    study_count = Column(Integer, default=0)
    practice_count = Column(Integer, default=0)
    correct_count = Column(Integer, default=0)
    wrong_count = Column(Integer, default=0)
    
    first_learned = Column(TIMESTAMP)
    last_reviewed = Column(TIMESTAMP)
    next_review = Column(TIMESTAMP)
    
    created_at = Column(TIMESTAMP, default=datetime.utcnow)
    updated_at = Column(TIMESTAMP, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    user = relationship("User", back_populates="knowledge_mastery")
    knowledge_point = relationship("KnowledgePoint", back_populates="mastery_records")

class LearningStatistics(Base):
    __tablename__ = 'learning_statistics'
    
    id = Column(BigInteger, primary_key=True)
    user_id = Column(BigInteger, ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    date = Column(Date, nullable=False)
    
    study_time = Column(Integer, default=0)
    chapters_completed = Column(Integer, default=0)
    exercises_completed = Column(Integer, default=0)
    tests_taken = Column(Integer, default=0)
    
    total_score = Column(Integer, default=0)
    average_score = Column(Float)
    
    login_count = Column(Integer, default=0)
    page_views = Column(Integer, default=0)
    code_runs = Column(Integer, default=0)
    
    created_at = Column(TIMESTAMP, default=datetime.utcnow)
    
    user = relationship("User", back_populates="statistics")
```

---

## ğŸ“¡ è¿½è¸ªæœºåˆ¶

### 1. å‰ç«¯æ•°æ®é‡‡é›†

```javascript
class LearningTracker {
  constructor() {
    this.sessionId = this.generateSessionId();
    this.startTime = Date.now();
    this.events = [];
    this.heartbeatInterval = 30000;  // 30ç§’
    
    this.initTracking();
  }
  
  generateSessionId() {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  initTracking() {
    // é¡µé¢å¯è§æ€§è¿½è¸ª
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        this.pauseTracking();
      } else {
        this.resumeTracking();
      }
    });
    
    // æ»šåŠ¨è¿½è¸ª
    let scrollTimeout;
    window.addEventListener('scroll', () => {
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        this.trackScroll();
      }, 500);
    });
    
    // ç« èŠ‚é˜…è¯»å®Œæˆè¿½è¸ª
    this.observeContentCompletion();
    
    // ä»£ç æ‰§è¡Œè¿½è¸ª
    this.trackCodeExecution();
    
    // å®šæœŸå‘é€å¿ƒè·³
    this.startHeartbeat();
    
    // é¡µé¢å¸è½½æ—¶ä¿å­˜æ•°æ®
    window.addEventListener('beforeunload', () => {
      this.flush();
    });
  }
  
  trackChapterView(chapterId, chapterTitle) {
    const event = {
      type: 'chapter_view',
      chapter_id: chapterId,
      chapter_title: chapterTitle,
      timestamp: Date.now()
    };
    
    this.events.push(event);
    this.sendEvent(event);
  }
  
  trackScroll() {
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const scrollHeight = document.documentElement.scrollHeight;
    const clientHeight = document.documentElement.clientHeight;
    
    const scrollPercent = Math.round((scrollTop / (scrollHeight - clientHeight)) * 100);
    
    const event = {
      type: 'scroll',
      scroll_depth: scrollPercent,
      timestamp: Date.now()
    };
    
    this.events.push(event);
    
    // æ›´æ–°è¿›åº¦
    if (scrollPercent > 80) {
      this.updateProgress(scrollPercent);
    }
  }
  
  observeContentCompletion() {
    // ä½¿ç”¨Intersection Observerç›‘æµ‹å†…å®¹é˜…è¯»
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const section = entry.target;
          const sectionId = section.id;
          
          this.trackSectionView(sectionId);
        }
      });
    }, {
      threshold: 0.5  // 50%å¯è§æ—¶è§¦å‘
    });
    
    // è§‚å¯Ÿæ‰€æœ‰sectionå…ƒç´ 
    document.querySelectorAll('section[id]').forEach(section => {
      observer.observe(section);
    });
  }
  
  trackSectionView(sectionId) {
    const event = {
      type: 'section_view',
      section_id: sectionId,
      timestamp: Date.now()
    };
    
    this.events.push(event);
  }
  
  trackCodeExecution(code, language, result) {
    const event = {
      type: 'code_execution',
      code_length: code.length,
      language: language,
      success: result.success,
      execution_time: result.execution_time,
      timestamp: Date.now()
    };
    
    this.events.push(event);
    this.sendEvent(event);
  }
  
  trackExerciseAttempt(exerciseId, code, result) {
    const event = {
      type: 'exercise_attempt',
      exercise_id: exerciseId,
      code: code,
      result: result,
      timestamp: Date.now()
    };
    
    this.sendEvent(event);
  }
  
  async updateProgress(progress) {
    const chapterId = this.getCurrentChapterId();
    
    await fetch('/api/v1/learning/progress', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getToken()}`
      },
      body: JSON.stringify({
        chapter_id: chapterId,
        progress: progress,
        scroll_depth: progress,
        time_spent: Math.floor((Date.now() - this.startTime) / 1000)
      })
    });
  }
  
  startHeartbeat() {
    this.heartbeat = setInterval(() => {
      this.sendHeartbeat();
    }, this.heartbeatInterval);
  }
  
  async sendHeartbeat() {
    const timeSpent = Math.floor((Date.now() - this.startTime) / 1000);
    
    await fetch('/api/v1/learning/heartbeat', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getToken()}`
      },
      body: JSON.stringify({
        session_id: this.sessionId,
        time_spent: timeSpent,
        events_count: this.events.length
      })
    });
  }
  
  pauseTracking() {
    clearInterval(this.heartbeat);
    this.flush();
  }
  
  resumeTracking() {
    this.startTime = Date.now();
    this.startHeartbeat();
  }
  
  async sendEvent(event) {
    await fetch('/api/v1/learning/events', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getToken()}`
      },
      body: JSON.stringify({
        session_id: this.sessionId,
        event: event
      })
    });
  }
  
  flush() {
    // ä½¿ç”¨sendBeaconç¡®ä¿æ•°æ®å‘é€
    if (this.events.length > 0) {
      const data = JSON.stringify({
        session_id: this.sessionId,
        events: this.events,
        duration: Math.floor((Date.now() - this.startTime) / 1000)
      });
      
      navigator.sendBeacon(
        '/api/v1/learning/flush',
        new Blob([data], { type: 'application/json' })
      );
      
      this.events = [];
    }
  }
  
  getCurrentChapterId() {
    // ä»URLæˆ–é¡µé¢å…ƒç´ è·å–å½“å‰ç« èŠ‚ID
    const match = window.location.pathname.match(/\/chapters\/(\d+)/);
    return match ? parseInt(match[1]) : null;
  }
  
  getToken() {
    return localStorage.getItem('access_token');
  }
}

// åˆå§‹åŒ–è¿½è¸ªå™¨
const tracker = new LearningTracker();
```

### 2. åç«¯æ•°æ®å¤„ç†

```python
from fastapi import APIRouter, Depends
from datetime import datetime, timedelta

router = APIRouter()

class LearningTrackingService:
    """å­¦ä¹ è¿½è¸ªæœåŠ¡"""
    
    async def update_progress(
        self, 
        user_id: int, 
        chapter_id: int, 
        data: dict
    ):
        """æ›´æ–°å­¦ä¹ è¿›åº¦"""
        # è·å–æˆ–åˆ›å»ºè¿›åº¦è®°å½•
        progress = await LearningProgress.get_or_create(
            user_id=user_id,
            chapter_id=chapter_id
        )
        
        # æ›´æ–°è¿›åº¦
        progress.progress = data.get('progress', progress.progress)
        progress.scroll_depth = data.get('scroll_depth', progress.scroll_depth)
        progress.time_spent += data.get('time_spent', 0)
        progress.last_position = data.get('last_position', progress.last_position)
        progress.last_access = datetime.utcnow()
        
        # æ£€æŸ¥æ˜¯å¦å®Œæˆ
        if progress.progress >= 95 and not progress.completed:
            progress.completed = True
            progress.completed_at = datetime.utcnow()
            
            # è§¦å‘å®Œæˆäº‹ä»¶
            await self.on_chapter_completed(user_id, chapter_id)
        
        await progress.save()
        
        # æ›´æ–°æ¯æ—¥ç»Ÿè®¡
        await self.update_daily_statistics(user_id, data)
        
        return progress
    
    async def record_exercise_attempt(
        self, 
        user_id: int, 
        exercise_id: int, 
        data: dict
    ):
        """è®°å½•ç»ƒä¹ å°è¯•"""
        # è·å–ä¸Šä¸€æ¬¡å°è¯•
        last_attempt = await ExerciseRecord.filter(
            user_id=user_id,
            exercise_id=exercise_id
        ).order_by('-attempt_number').first()
        
        attempt_number = (last_attempt.attempt_number + 1) if last_attempt else 1
        
        # åˆ›å»ºè®°å½•
        record = await ExerciseRecord.create(
            user_id=user_id,
            exercise_id=exercise_id,
            code=data['code'],
            language=data['language'],
            result=data['result'],
            score=data.get('score'),
            max_score=data.get('max_score'),
            passed=data.get('passed', False),
            attempt_number=attempt_number,
            time_spent=data.get('time_spent', 0),
            errors=data.get('errors'),
            hints_used=data.get('hints_used', 0)
        )
        
        # æ›´æ–°çŸ¥è¯†ç‚¹æŒæ¡åº¦
        if record.passed:
            await self.update_knowledge_mastery(
                user_id, 
                exercise_id, 
                correct=True
            )
            
            # è§¦å‘ç»ƒä¹ å®Œæˆäº‹ä»¶
            await self.on_exercise_completed(user_id, exercise_id)
        else:
            await self.update_knowledge_mastery(
                user_id, 
                exercise_id, 
                correct=False
            )
        
        return record
    
    async def create_session(
        self, 
        user_id: int, 
        device_info: dict
    ) -> LearningSession:
        """åˆ›å»ºå­¦ä¹ ä¼šè¯"""
        session = await LearningSession.create(
            user_id=user_id,
            start_time=datetime.utcnow(),
            device_type=device_info.get('device_type'),
            platform=device_info.get('platform')
        )
        
        return session
    
    async def end_session(
        self, 
        session_id: int, 
        statistics: dict
    ):
        """ç»“æŸå­¦ä¹ ä¼šè¯"""
        session = await LearningSession.get(id=session_id)
        
        session.end_time = datetime.utcnow()
        session.duration = int((session.end_time - session.start_time).total_seconds())
        session.chapters_visited = statistics.get('chapters_visited', [])
        session.exercises_attempted = statistics.get('exercises_attempted', [])
        session.page_views = statistics.get('page_views', 0)
        session.code_runs = statistics.get('code_runs', 0)
        session.searches = statistics.get('searches', 0)
        
        await session.save()
    
    async def update_knowledge_mastery(
        self, 
        user_id: int, 
        exercise_id: int, 
        correct: bool
    ):
        """æ›´æ–°çŸ¥è¯†ç‚¹æŒæ¡åº¦"""
        # è·å–ç»ƒä¹ å…³è”çš„çŸ¥è¯†ç‚¹
        exercise = await Exercise.get(id=exercise_id).prefetch_related('knowledge_points')
        
        for kp in exercise.knowledge_points:
            # è·å–æˆ–åˆ›å»ºæŒæ¡è®°å½•
            mastery = await KnowledgeMastery.get_or_create(
                user_id=user_id,
                knowledge_point_id=kp.id
            )
            
            # æ›´æ–°ç»Ÿè®¡
            mastery.practice_count += 1
            if correct:
                mastery.correct_count += 1
            else:
                mastery.wrong_count += 1
            
            # è®¡ç®—ç½®ä¿¡åº¦åˆ†æ•°
            total = mastery.correct_count + mastery.wrong_count
            mastery.confidence_score = mastery.correct_count / total if total > 0 else 0
            
            # æ›´æ–°æŒæ¡ç­‰çº§
            mastery.mastery_level = self.calculate_mastery_level(mastery)
            
            # æ›´æ–°å¤ä¹ æ—¶é—´
            mastery.last_reviewed = datetime.utcnow()
            mastery.next_review = self.calculate_next_review(mastery)
            
            await mastery.save()
    
    def calculate_mastery_level(self, mastery: KnowledgeMastery) -> str:
        """è®¡ç®—æŒæ¡ç­‰çº§"""
        score = mastery.confidence_score
        count = mastery.practice_count
        
        if count < 3:
            return 'beginner'
        elif score >= 0.9 and count >= 10:
            return 'master'
        elif score >= 0.75 and count >= 5:
            return 'advanced'
        elif score >= 0.6:
            return 'intermediate'
        else:
            return 'beginner'
    
    def calculate_next_review(self, mastery: KnowledgeMastery) -> datetime:
        """è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´ (é—´éš”é‡å¤ç®—æ³•)"""
        # SM-2ç®—æ³•ç®€åŒ–ç‰ˆ
        intervals = {
            'beginner': 1,      # 1å¤©
            'intermediate': 3,  # 3å¤©
            'advanced': 7,      # 7å¤©
            'master': 30        # 30å¤©
        }
        
        days = intervals.get(mastery.mastery_level, 1)
        
        # æ ¹æ®ç½®ä¿¡åº¦è°ƒæ•´
        if mastery.confidence_score < 0.7:
            days = max(1, days // 2)
        
        return datetime.utcnow() + timedelta(days=days)
    
    async def update_daily_statistics(self, user_id: int, data: dict):
        """æ›´æ–°æ¯æ—¥ç»Ÿè®¡"""
        today = datetime.utcnow().date()
        
        stats = await LearningStatistics.get_or_create(
            user_id=user_id,
            date=today
        )
        
        stats.study_time += data.get('time_spent', 0)
        stats.page_views += data.get('page_views', 0)
        stats.code_runs += data.get('code_runs', 0)
        
        if data.get('chapter_completed'):
            stats.chapters_completed += 1
        
        if data.get('exercise_completed'):
            stats.exercises_completed += 1
        
        await stats.save()
    
    async def on_chapter_completed(self, user_id: int, chapter_id: int):
        """ç« èŠ‚å®Œæˆäº‹ä»¶å¤„ç†"""
        # æ£€æŸ¥æˆå°±
        await self.check_achievements(user_id, 'chapter_completed')
        
        # å‘é€é€šçŸ¥
        # await NotificationService.send(user_id, f"æ­å–œå®Œæˆç« èŠ‚ï¼")
    
    async def on_exercise_completed(self, user_id: int, exercise_id: int):
        """ç»ƒä¹ å®Œæˆäº‹ä»¶å¤„ç†"""
        # æ£€æŸ¥æˆå°±
        await self.check_achievements(user_id, 'exercise_completed')

@router.post("/progress")
async def update_progress(
    data: ProgressUpdate,
    current_user: User = Depends(get_current_user)
):
    """æ›´æ–°å­¦ä¹ è¿›åº¦"""
    service = LearningTrackingService()
    progress = await service.update_progress(
        current_user.id,
        data.chapter_id,
        data.dict()
    )
    
    return {'success': True, 'data': progress}

@router.post("/exercises/{exercise_id}/attempt")
async def record_attempt(
    exercise_id: int,
    data: ExerciseAttempt,
    current_user: User = Depends(get_current_user)
):
    """è®°å½•ç»ƒä¹ å°è¯•"""
    service = LearningTrackingService()
    record = await service.record_exercise_attempt(
        current_user.id,
        exercise_id,
        data.dict()
    )
    
    return {'success': True, 'data': record}
```

---

## ğŸ“Š å¯è§†åŒ–è®¾è®¡

### ä¸ªäººè¿›åº¦ä»ªè¡¨ç›˜

```html
<div class="dashboard-container">
  <!-- æ¦‚è§ˆå¡ç‰‡ -->
  <div class="overview-cards">
    <div class="stat-card">
      <div class="stat-icon">ğŸ“š</div>
      <div class="stat-value">45</div>
      <div class="stat-label">å­¦ä¹ å¤©æ•°</div>
      <div class="stat-change">+5 æœ¬å‘¨</div>
    </div>
    
    <div class="stat-card">
      <div class="stat-icon">â±ï¸</div>
      <div class="stat-value">128</div>
      <div class="stat-label">å­¦ä¹ æ—¶é•¿ (å°æ—¶)</div>
      <div class="stat-change">+12 æœ¬å‘¨</div>
    </div>
    
    <div class="stat-card">
      <div class="stat-icon">âœ…</div>
      <div class="stat-value">24/30</div>
      <div class="stat-label">å®Œæˆç« èŠ‚</div>
      <div class="stat-change">80% å®Œæˆ</div>
    </div>
    
    <div class="stat-card">
      <div class="stat-icon">ğŸ†</div>
      <div class="stat-value">15</div>
      <div class="stat-label">è·å¾—æˆå°±</div>
      <div class="stat-change">+3 æœ¬æœˆ</div>
    </div>
  </div>
  
  <!-- å­¦ä¹ è¶‹åŠ¿å›¾ -->
  <div class="chart-section">
    <h3>ğŸ“ˆ å­¦ä¹ è¶‹åŠ¿</h3>
    <canvas id="learningTrendChart"></canvas>
  </div>
  
  <!-- çŸ¥è¯†ç‚¹é›·è¾¾å›¾ -->
  <div class="chart-section">
    <h3>ğŸ¯ çŸ¥è¯†ç‚¹æŒæ¡åº¦</h3>
    <canvas id="knowledgeRadarChart"></canvas>
  </div>
  
  <!-- æœ€è¿‘å­¦ä¹  -->
  <div class="recent-section">
    <h3>ğŸ“– æœ€è¿‘å­¦ä¹ </h3>
    <div class="recent-list">
      <div class="recent-item">
        <div class="item-icon">ğŸ“„</div>
        <div class="item-info">
          <div class="item-title">ç¬¬5ç«  æ°´åŠ›è®¡ç®—</div>
          <div class="item-meta">80% å®Œæˆ Â· 2å°æ—¶å‰</div>
        </div>
        <div class="item-action">
          <button>ç»§ç»­å­¦ä¹ </button>
        </div>
      </div>
      <!-- æ›´å¤šé¡¹ç›®... -->
    </div>
  </div>
  
  <!-- æˆå°±å±•ç¤º -->
  <div class="achievements-section">
    <h3>ğŸ† æˆå°±å±•ç¤º</h3>
    <div class="achievements-grid">
      <div class="achievement-card completed">
        <div class="ach-icon">ğŸ“</div>
        <div class="ach-name">åˆå­¦è€…</div>
        <div class="ach-desc">å®Œæˆ10ä¸ªç« èŠ‚</div>
      </div>
      <div class="achievement-card completed">
        <div class="ach-icon">ğŸ’ª</div>
        <div class="ach-name">åšæŒä¸æ‡ˆ</div>
        <div class="ach-desc">è¿ç»­å­¦ä¹ 7å¤©</div>
      </div>
      <div class="achievement-card locked">
        <div class="ach-icon">â­</div>
        <div class="ach-name">ç²¾é€šè€…</div>
        <div class="ach-desc">å®Œæˆæ‰€æœ‰ç« èŠ‚</div>
        <div class="ach-progress">24/30</div>
      </div>
      <!-- æ›´å¤šæˆå°±... -->
    </div>
  </div>
</div>
```

### Chart.jså¯è§†åŒ–

```javascript
// å­¦ä¹ è¶‹åŠ¿å›¾
const learningTrendChart = new Chart(
  document.getElementById('learningTrendChart'),
  {
    type: 'line',
    data: {
      labels: ['å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­', 'å‘¨æ—¥'],
      datasets: [{
        label: 'å­¦ä¹ æ—¶é•¿ (åˆ†é’Ÿ)',
        data: [60, 45, 90, 75, 120, 80, 95],
        borderColor: 'rgb(75, 192, 192)',
        backgroundColor: 'rgba(75, 192, 192, 0.2)',
        tension: 0.4
      }, {
        label: 'å®Œæˆç« èŠ‚',
        data: [2, 1, 3, 2, 4, 2, 3],
        borderColor: 'rgb(255, 99, 132)',
        backgroundColor: 'rgba(255, 99, 132, 0.2)',
        tension: 0.4,
        yAxisID: 'y1'
      }]
    },
    options: {
      responsive: true,
      interaction: {
        mode: 'index',
        intersect: false
      },
      scales: {
        y: {
          type: 'linear',
          display: true,
          position: 'left',
          title: {
            display: true,
            text: 'å­¦ä¹ æ—¶é•¿ (åˆ†é’Ÿ)'
          }
        },
        y1: {
          type: 'linear',
          display: true,
          position: 'right',
          title: {
            display: true,
            text: 'å®Œæˆç« èŠ‚'
          },
          grid: {
            drawOnChartArea: false
          }
        }
      }
    }
  }
);

// çŸ¥è¯†ç‚¹é›·è¾¾å›¾
const knowledgeRadarChart = new Chart(
  document.getElementById('knowledgeRadarChart'),
  {
    type: 'radar',
    data: {
      labels: [
        'æµä½“åŠ›å­¦',
        'æ°´åŠ›è®¡ç®—',
        'ç®¡é“è®¾è®¡',
        'æ³µç«™è®¾è®¡',
        'æ§åˆ¶ç†è®º',
        'æ•°å€¼æ¨¡æ‹Ÿ'
      ],
      datasets: [{
        label: 'æŒæ¡ç¨‹åº¦',
        data: [85, 70, 90, 65, 75, 80],
        fill: true,
        backgroundColor: 'rgba(54, 162, 235, 0.2)',
        borderColor: 'rgb(54, 162, 235)',
        pointBackgroundColor: 'rgb(54, 162, 235)',
        pointBorderColor: '#fff',
        pointHoverBackgroundColor: '#fff',
        pointHoverBorderColor: 'rgb(54, 162, 235)'
      }]
    },
    options: {
      responsive: true,
      scales: {
        r: {
          angleLines: {
            display: true
          },
          suggestedMin: 0,
          suggestedMax: 100
        }
      }
    }
  }
);
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-11-12
