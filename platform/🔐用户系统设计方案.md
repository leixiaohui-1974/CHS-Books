# ğŸ” ç”¨æˆ·ç³»ç»Ÿè®¾è®¡æ–¹æ¡ˆ

**ç‰ˆæœ¬**: v1.0  
**åˆ¶å®šæ—¥æœŸ**: 2025-11-12  
**è´Ÿè´£æ¨¡å—**: ç”¨æˆ·è®¤è¯ä¸æƒé™ç®¡ç†

---

## ğŸ“‹ ç›®å½•

- [ç³»ç»Ÿæ¦‚è¿°](#ç³»ç»Ÿæ¦‚è¿°)
- [åŠŸèƒ½è®¾è®¡](#åŠŸèƒ½è®¾è®¡)
- [æ•°æ®åº“è®¾è®¡](#æ•°æ®åº“è®¾è®¡)
- [APIè®¾è®¡](#apiè®¾è®¡)
- [å®‰å…¨æ–¹æ¡ˆ](#å®‰å…¨æ–¹æ¡ˆ)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)

---

## ğŸ¯ ç³»ç»Ÿæ¦‚è¿°

### è®¾è®¡ç›®æ ‡

```
âœ… å®‰å…¨æ€§:     æ”¯æŒå¤šå› ç´ è®¤è¯ï¼Œé˜²æŠ¤å„ç±»æ”»å‡»
âœ… æ˜“ç”¨æ€§:     ç®€åŒ–æ³¨å†Œæµç¨‹ï¼Œæ”¯æŒç¬¬ä¸‰æ–¹ç™»å½•
âœ… æ‰©å±•æ€§:     æ”¯æŒå¤šç§è®¤è¯æ–¹å¼ï¼Œçµæ´»æƒé™æ§åˆ¶
âœ… é«˜æ€§èƒ½:     æ”¯æŒé«˜å¹¶å‘ï¼Œå¿«é€Ÿå“åº”
âœ… åˆè§„æ€§:     ç¬¦åˆæ•°æ®ä¿æŠ¤æ³•è§„
```

### æ ¸å¿ƒåŠŸèƒ½æ¨¡å—

```
ç”¨æˆ·ç³»ç»Ÿ
â”œâ”€â”€ ç”¨æˆ·è®¤è¯
â”‚   â”œâ”€â”€ æ³¨å†Œ/ç™»å½•
â”‚   â”œâ”€â”€ å¯†ç ç®¡ç†
â”‚   â”œâ”€â”€ ç¬¬ä¸‰æ–¹ç™»å½•
â”‚   â””â”€â”€ åŒå› ç´ è®¤è¯
â”‚
â”œâ”€â”€ ç”¨æˆ·ä¿¡æ¯
â”‚   â”œâ”€â”€ åŸºæœ¬ä¿¡æ¯
â”‚   â”œâ”€â”€ ä¸ªäººèµ„æ–™
â”‚   â”œâ”€â”€ åå¥½è®¾ç½®
â”‚   â””â”€â”€ éšç§è®¾ç½®
â”‚
â”œâ”€â”€ æƒé™ç®¡ç†
â”‚   â”œâ”€â”€ è§’è‰²å®šä¹‰
â”‚   â”œâ”€â”€ æƒé™åˆ†é…
â”‚   â””â”€â”€ è®¿é—®æ§åˆ¶
â”‚
â””â”€â”€ ä¼šè¯ç®¡ç†
    â”œâ”€â”€ Tokenç®¡ç†
    â”œâ”€â”€ è®¾å¤‡ç®¡ç†
    â””â”€â”€ ç™»å½•å†å²
```

---

## ğŸ¨ åŠŸèƒ½è®¾è®¡

### 1. ç”¨æˆ·æ³¨å†Œæµç¨‹

```
æ³¨å†Œæµç¨‹å›¾
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                             â”‚
â”‚  [ç”¨æˆ·è®¿é—®æ³¨å†Œé¡µé¢]                          â”‚
â”‚          â†“                                  â”‚
â”‚  [å¡«å†™åŸºæœ¬ä¿¡æ¯]                              â”‚
â”‚   - ç”¨æˆ·å                                   â”‚
â”‚   - é‚®ç®±/æ‰‹æœºå·                              â”‚
â”‚   - å¯†ç                                      â”‚
â”‚          â†“                                  â”‚
â”‚  [å‘é€éªŒè¯ç ]                                â”‚
â”‚          â†“                                  â”‚
â”‚  [è¾“å…¥éªŒè¯ç ]                                â”‚
â”‚          â†“                                  â”‚
â”‚  [åˆ›å»ºè´¦å·] â”€â”€å¤±è´¥â”€â”€â–¶ [æ˜¾ç¤ºé”™è¯¯æç¤º]        â”‚
â”‚          â†“                                  â”‚
â”‚       æˆåŠŸ                                   â”‚
â”‚          â†“                                  â”‚
â”‚  [è‡ªåŠ¨ç™»å½•]                                  â”‚
â”‚          â†“                                  â”‚
â”‚  [è·³è½¬åˆ°é¦–é¡µ]                                â”‚
â”‚                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### æ³¨å†Œè¡¨å•è®¾è®¡

```html
<form id="registerForm">
  <div class="form-group">
    <label>ç”¨æˆ·å</label>
    <input type="text" name="username" 
           placeholder="4-20ä¸ªå­—ç¬¦" 
           pattern="^[a-zA-Z0-9_]{4,20}$"
           required>
    <span class="hint">åªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿</span>
  </div>
  
  <div class="form-group">
    <label>é‚®ç®±</label>
    <input type="email" name="email" 
           placeholder="your@email.com"
           required>
    <button type="button" class="btn-send-code">
      å‘é€éªŒè¯ç 
    </button>
  </div>
  
  <div class="form-group">
    <label>éªŒè¯ç </label>
    <input type="text" name="code" 
           placeholder="6ä½æ•°å­—"
           pattern="^\d{6}$"
           required>
  </div>
  
  <div class="form-group">
    <label>å¯†ç </label>
    <input type="password" name="password"
           placeholder="è‡³å°‘8ä½ï¼ŒåŒ…å«å¤§å°å†™å­—æ¯å’Œæ•°å­—"
           pattern="^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]{8,}$"
           required>
    <div class="password-strength">
      <div class="strength-bar"></div>
      <span class="strength-text">å¯†ç å¼ºåº¦: å¼±</span>
    </div>
  </div>
  
  <div class="form-group">
    <label>ç¡®è®¤å¯†ç </label>
    <input type="password" name="confirmPassword"
           required>
  </div>
  
  <div class="form-group">
    <label class="checkbox">
      <input type="checkbox" name="agree" required>
      æˆ‘å·²é˜…è¯»å¹¶åŒæ„ <a href="/terms">æœåŠ¡æ¡æ¬¾</a> å’Œ 
      <a href="/privacy">éšç§æ”¿ç­–</a>
    </label>
  </div>
  
  <button type="submit" class="btn-primary">
    æ³¨å†Œ
  </button>
  
  <div class="form-footer">
    å·²æœ‰è´¦å·ï¼Ÿ <a href="/login">ç«‹å³ç™»å½•</a>
  </div>
</form>
```

#### å‰ç«¯éªŒè¯é€»è¾‘

```javascript
class RegistrationValidator {
  constructor() {
    this.rules = {
      username: {
        pattern: /^[a-zA-Z0-9_]{4,20}$/,
        message: 'ç”¨æˆ·åå¿…é¡»ä¸º4-20ä¸ªå­—ç¬¦ï¼Œåªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿'
      },
      email: {
        pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
        message: 'è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€'
      },
      password: {
        pattern: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d@$!%*?&]{8,}$/,
        message: 'å¯†ç è‡³å°‘8ä½ï¼Œå¿…é¡»åŒ…å«å¤§å°å†™å­—æ¯å’Œæ•°å­—'
      }
    };
  }
  
  validateUsername(username) {
    if (!this.rules.username.pattern.test(username)) {
      return { valid: false, message: this.rules.username.message };
    }
    return { valid: true };
  }
  
  validateEmail(email) {
    if (!this.rules.email.pattern.test(email)) {
      return { valid: false, message: this.rules.email.message };
    }
    return { valid: true };
  }
  
  validatePassword(password) {
    if (!this.rules.password.pattern.test(password)) {
      return { valid: false, message: this.rules.password.message };
    }
    
    // è®¡ç®—å¯†ç å¼ºåº¦
    const strength = this.calculatePasswordStrength(password);
    return { 
      valid: true, 
      strength: strength,
      message: `å¯†ç å¼ºåº¦: ${strength}`
    };
  }
  
  calculatePasswordStrength(password) {
    let score = 0;
    
    // é•¿åº¦
    if (password.length >= 8) score++;
    if (password.length >= 12) score++;
    if (password.length >= 16) score++;
    
    // å¤æ‚åº¦
    if (/[a-z]/.test(password)) score++;
    if (/[A-Z]/.test(password)) score++;
    if (/\d/.test(password)) score++;
    if (/[@$!%*?&]/.test(password)) score++;
    
    if (score <= 3) return 'å¼±';
    if (score <= 5) return 'ä¸­';
    return 'å¼º';
  }
  
  async checkUsernameAvailable(username) {
    const response = await fetch(`/api/v1/users/check-username?username=${username}`);
    const data = await response.json();
    return data.available;
  }
  
  async checkEmailAvailable(email) {
    const response = await fetch(`/api/v1/users/check-email?email=${email}`);
    const data = await response.json();
    return data.available;
  }
}
```

---

### 2. ç™»å½•æµç¨‹

```
ç™»å½•æµç¨‹å›¾
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                             â”‚
â”‚  [ç”¨æˆ·è®¿é—®ç™»å½•é¡µé¢]                          â”‚
â”‚          â†“                                  â”‚
â”‚  [é€‰æ‹©ç™»å½•æ–¹å¼]                              â”‚
â”‚     â”œâ”€ è´¦å·å¯†ç                               â”‚
â”‚     â”œâ”€ æ‰‹æœºéªŒè¯ç                             â”‚
â”‚     â””â”€ ç¬¬ä¸‰æ–¹ç™»å½•                            â”‚
â”‚          â†“                                  â”‚
â”‚  [éªŒè¯èº«ä»½]                                  â”‚
â”‚          â†“                                  â”‚
â”‚  [æ˜¯å¦å¼€å¯2FA?] â”€â”€æ˜¯â”€â”€â–¶ [è¾“å…¥2FAéªŒè¯ç ]     â”‚
â”‚          â†“ å¦                               â”‚
â”‚  [ç”ŸæˆToken]                                 â”‚
â”‚          â†“                                  â”‚
â”‚  [è®°å½•ç™»å½•æ—¥å¿—]                              â”‚
â”‚          â†“                                  â”‚
â”‚  [è·³è½¬åˆ°ç›®æ ‡é¡µé¢]                            â”‚
â”‚                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ç™»å½•è¡¨å•è®¾è®¡

```html
<div class="login-container">
  <!-- æ ‡ç­¾é¡µåˆ‡æ¢ -->
  <div class="login-tabs">
    <button class="tab active" data-tab="password">
      è´¦å·ç™»å½•
    </button>
    <button class="tab" data-tab="sms">
      çŸ­ä¿¡ç™»å½•
    </button>
  </div>
  
  <!-- è´¦å·å¯†ç ç™»å½• -->
  <form id="passwordLoginForm" class="login-form active">
    <div class="form-group">
      <input type="text" name="username" 
             placeholder="ç”¨æˆ·å/é‚®ç®±/æ‰‹æœºå·" required>
    </div>
    
    <div class="form-group">
      <input type="password" name="password"
             placeholder="å¯†ç " required>
      <a href="/forgot-password" class="forgot-link">
        å¿˜è®°å¯†ç ?
      </a>
    </div>
    
    <div class="form-group">
      <label class="checkbox">
        <input type="checkbox" name="remember">
        è®°ä½æˆ‘ (7å¤©å†…å…ç™»å½•)
      </label>
    </div>
    
    <button type="submit" class="btn-primary btn-block">
      ç™»å½•
    </button>
  </form>
  
  <!-- çŸ­ä¿¡éªŒè¯ç ç™»å½• -->
  <form id="smsLoginForm" class="login-form">
    <div class="form-group">
      <input type="tel" name="phone" 
             placeholder="æ‰‹æœºå·" 
             pattern="^1[3-9]\d{9}$"
             required>
    </div>
    
    <div class="form-group">
      <input type="text" name="code" 
             placeholder="éªŒè¯ç " required>
      <button type="button" class="btn-send-code">
        å‘é€éªŒè¯ç 
      </button>
    </div>
    
    <button type="submit" class="btn-primary btn-block">
      ç™»å½•
    </button>
  </form>
  
  <!-- ç¬¬ä¸‰æ–¹ç™»å½• -->
  <div class="social-login">
    <p class="divider">
      <span>æˆ–ä½¿ç”¨ä»¥ä¸‹æ–¹å¼ç™»å½•</span>
    </p>
    
    <div class="social-buttons">
      <button class="btn-social btn-wechat">
        <i class="icon-wechat"></i> å¾®ä¿¡
      </button>
      <button class="btn-social btn-github">
        <i class="icon-github"></i> GitHub
      </button>
      <button class="btn-social btn-google">
        <i class="icon-google"></i> Google
      </button>
    </div>
  </div>
  
  <div class="form-footer">
    è¿˜æ²¡æœ‰è´¦å·ï¼Ÿ <a href="/register">ç«‹å³æ³¨å†Œ</a>
  </div>
</div>
```

---

### 3. åŒå› ç´ è®¤è¯ (2FA)

```
2FAæµç¨‹å›¾
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                             â”‚
â”‚  [ç”¨æˆ·å¼€å¯2FA]                               â”‚
â”‚          â†“                                  â”‚
â”‚  [é€‰æ‹©2FAæ–¹å¼]                               â”‚
â”‚     â”œâ”€ TOTP (æ¨è)                          â”‚
â”‚     â”œâ”€ çŸ­ä¿¡éªŒè¯ç                             â”‚
â”‚     â””â”€ é‚®ç®±éªŒè¯ç                             â”‚
â”‚          â†“                                  â”‚
â”‚  [æ˜¾ç¤ºäºŒç»´ç /å‘é€éªŒè¯ç ]                      â”‚
â”‚          â†“                                  â”‚
â”‚  [ç”¨æˆ·ç»‘å®š/è¾“å…¥éªŒè¯ç ]                        â”‚
â”‚          â†“                                  â”‚
â”‚  [éªŒè¯æˆåŠŸ]                                  â”‚
â”‚          â†“                                  â”‚
â”‚  [ç”Ÿæˆå¤‡ç”¨ç ] (10ä¸ª)                         â”‚
â”‚          â†“                                  â”‚
â”‚  [ä¿å­˜é…ç½®]                                  â”‚
â”‚                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### TOTPå®ç°

```python
import pyotp
import qrcode
from io import BytesIO
import base64

class TwoFactorAuthService:
    """åŒå› ç´ è®¤è¯æœåŠ¡"""
    
    def generate_totp_secret(self, user_id: int) -> dict:
        """ç”ŸæˆTOTPå¯†é’¥"""
        # ç”Ÿæˆéšæœºå¯†é’¥
        secret = pyotp.random_base32()
        
        # ç”ŸæˆTOTP URI
        totp_uri = pyotp.totp.TOTP(secret).provisioning_uri(
            name=f"user_{user_id}@platform.com",
            issuer_name="Platform"
        )
        
        # ç”ŸæˆäºŒç»´ç 
        qr = qrcode.QRCode(version=1, box_size=10, border=5)
        qr.add_data(totp_uri)
        qr.make(fit=True)
        
        img = qr.make_image(fill_color="black", back_color="white")
        buffer = BytesIO()
        img.save(buffer, format='PNG')
        qr_code_base64 = base64.b64encode(buffer.getvalue()).decode()
        
        return {
            'secret': secret,
            'qr_code': f"data:image/png;base64,{qr_code_base64}",
            'manual_entry': secret
        }
    
    def verify_totp(self, secret: str, code: str) -> bool:
        """éªŒè¯TOTPä»£ç """
        totp = pyotp.TOTP(secret)
        return totp.verify(code, valid_window=1)
    
    def generate_backup_codes(self, count: int = 10) -> list:
        """ç”Ÿæˆå¤‡ç”¨ç """
        import secrets
        return [
            f"{secrets.randbelow(10000):04d}-{secrets.randbelow(10000):04d}"
            for _ in range(count)
        ]
    
    async def enable_2fa(self, user_id: int, method: str, secret: str):
        """å¯ç”¨2FA"""
        # ç”Ÿæˆå¤‡ç”¨ç 
        backup_codes = self.generate_backup_codes()
        
        # ä¿å­˜é…ç½®
        await TwoFactorAuth.create(
            user_id=user_id,
            method=method,
            secret=secret,
            backup_codes=backup_codes,
            enabled=True
        )
        
        return backup_codes
    
    async def verify_login_2fa(self, user_id: int, code: str) -> bool:
        """éªŒè¯ç™»å½•æ—¶çš„2FA"""
        config = await TwoFactorAuth.get(user_id=user_id)
        
        if not config or not config.enabled:
            return True  # æœªå¯ç”¨2FAï¼Œç›´æ¥é€šè¿‡
        
        # éªŒè¯TOTP
        if self.verify_totp(config.secret, code):
            return True
        
        # éªŒè¯å¤‡ç”¨ç 
        if code in config.backup_codes:
            # ä½¿ç”¨åç§»é™¤
            config.backup_codes.remove(code)
            await config.save()
            return True
        
        return False
```

---

### 4. ç¬¬ä¸‰æ–¹ç™»å½•

#### OAuth2.0æµç¨‹

```
OAuthç™»å½•æµç¨‹
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                             â”‚
â”‚  [ç”¨æˆ·ç‚¹å‡»"å¾®ä¿¡ç™»å½•"]                         â”‚
â”‚          â†“                                  â”‚
â”‚  [è·³è½¬åˆ°å¾®ä¿¡æˆæƒé¡µé¢]                         â”‚
â”‚          â†“                                  â”‚
â”‚  [ç”¨æˆ·åŒæ„æˆæƒ]                              â”‚
â”‚          â†“                                  â”‚
â”‚  [å¾®ä¿¡å›è°ƒå¹¶è¿”å›code]                         â”‚
â”‚          â†“                                  â”‚
â”‚  [åç«¯ç”¨codeæ¢å–access_token]                â”‚
â”‚          â†“                                  â”‚
â”‚  [è·å–ç”¨æˆ·ä¿¡æ¯]                              â”‚
â”‚          â†“                                  â”‚
â”‚  [æ£€æŸ¥æ˜¯å¦å·²æ³¨å†Œ] â”€â”€å¦â”€â”€â–¶ [åˆ›å»ºæ–°ç”¨æˆ·]       â”‚
â”‚          â†“ æ˜¯                               â”‚
â”‚  [ç”Ÿæˆå¹³å°Token]                             â”‚
â”‚          â†“                                  â”‚
â”‚  [ç™»å½•æˆåŠŸ]                                  â”‚
â”‚                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å®ç°ä»£ç 

```python
from authlib.integrations.starlette_client import OAuth
from fastapi import APIRouter, Request

router = APIRouter()
oauth = OAuth()

# å¾®ä¿¡OAuthé…ç½®
oauth.register(
    name='wechat',
    client_id='YOUR_WECHAT_APP_ID',
    client_secret='YOUR_WECHAT_APP_SECRET',
    authorize_url='https://open.weixin.qq.com/connect/qrconnect',
    authorize_params={'scope': 'snsapi_login'},
    access_token_url='https://api.weixin.qq.com/sns/oauth2/access_token',
    client_kwargs={'scope': 'snsapi_login'}
)

# GitHub OAuthé…ç½®
oauth.register(
    name='github',
    client_id='YOUR_GITHUB_CLIENT_ID',
    client_secret='YOUR_GITHUB_CLIENT_SECRET',
    authorize_url='https://github.com/login/oauth/authorize',
    authorize_params={'scope': 'user:email'},
    access_token_url='https://github.com/login/oauth/access_token',
    api_base_url='https://api.github.com/',
    client_kwargs={'scope': 'user:email'}
)

@router.get('/auth/{provider}/login')
async def oauth_login(request: Request, provider: str):
    """å‘èµ·OAuthç™»å½•"""
    redirect_uri = request.url_for('oauth_callback', provider=provider)
    return await oauth.create_client(provider).authorize_redirect(
        request, 
        redirect_uri
    )

@router.get('/auth/{provider}/callback')
async def oauth_callback(request: Request, provider: str):
    """OAuthå›è°ƒå¤„ç†"""
    try:
        # è·å–access token
        token = await oauth.create_client(provider).authorize_access_token(request)
        
        # è·å–ç”¨æˆ·ä¿¡æ¯
        if provider == 'wechat':
            user_info = await get_wechat_user_info(token)
        elif provider == 'github':
            user_info = await get_github_user_info(token)
        else:
            raise ValueError(f"Unsupported provider: {provider}")
        
        # æŸ¥æ‰¾æˆ–åˆ›å»ºç”¨æˆ·
        user = await find_or_create_oauth_user(provider, user_info)
        
        # ç”Ÿæˆå¹³å°Token
        access_token = create_access_token(user.id)
        
        return {
            'success': True,
            'access_token': access_token,
            'user': user.dict()
        }
        
    except Exception as e:
        return {
            'success': False,
            'error': str(e)
        }

async def get_wechat_user_info(token: dict) -> dict:
    """è·å–å¾®ä¿¡ç”¨æˆ·ä¿¡æ¯"""
    url = f"https://api.weixin.qq.com/sns/userinfo"
    params = {
        'access_token': token['access_token'],
        'openid': token['openid']
    }
    
    async with httpx.AsyncClient() as client:
        response = await client.get(url, params=params)
        data = response.json()
        
        return {
            'id': data['openid'],
            'name': data['nickname'],
            'avatar': data['headimgurl']
        }

async def get_github_user_info(token: dict) -> dict:
    """è·å–GitHubç”¨æˆ·ä¿¡æ¯"""
    headers = {'Authorization': f"Bearer {token['access_token']}"}
    
    async with httpx.AsyncClient() as client:
        # è·å–ç”¨æˆ·åŸºæœ¬ä¿¡æ¯
        user_response = await client.get(
            'https://api.github.com/user',
            headers=headers
        )
        user_data = user_response.json()
        
        # è·å–ç”¨æˆ·é‚®ç®±
        emails_response = await client.get(
            'https://api.github.com/user/emails',
            headers=headers
        )
        emails_data = emails_response.json()
        primary_email = next(
            (e['email'] for e in emails_data if e['primary']),
            None
        )
        
        return {
            'id': str(user_data['id']),
            'username': user_data['login'],
            'name': user_data['name'],
            'email': primary_email,
            'avatar': user_data['avatar_url']
        }

async def find_or_create_oauth_user(provider: str, user_info: dict):
    """æŸ¥æ‰¾æˆ–åˆ›å»ºOAuthç”¨æˆ·"""
    # æŸ¥æ‰¾å·²ç»‘å®šçš„è´¦å·
    oauth_account = await OAuthAccount.get(
        provider=provider,
        provider_user_id=user_info['id']
    )
    
    if oauth_account:
        return await User.get(id=oauth_account.user_id)
    
    # åˆ›å»ºæ–°ç”¨æˆ·
    user = await User.create(
        username=user_info.get('username') or f"{provider}_{user_info['id']}",
        email=user_info.get('email'),
        avatar_url=user_info.get('avatar'),
        verified=True  # OAuthç”¨æˆ·é»˜è®¤å·²éªŒè¯
    )
    
    # åˆ›å»ºOAuthå…³è”
    await OAuthAccount.create(
        user_id=user.id,
        provider=provider,
        provider_user_id=user_info['id'],
        access_token=user_info.get('access_token')
    )
    
    return user
```

---

## ğŸ’¾ æ•°æ®åº“è®¾è®¡

### ERå›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     users       â”‚      â”‚  user_profiles   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK)         â”‚â—€â”€â”€â”€â”€â–¶â”‚ user_id (FK)     â”‚
â”‚ username        â”‚      â”‚ real_name        â”‚
â”‚ email           â”‚      â”‚ school           â”‚
â”‚ phone           â”‚      â”‚ major            â”‚
â”‚ password_hash   â”‚      â”‚ grade            â”‚
â”‚ avatar_url      â”‚      â”‚ bio              â”‚
â”‚ verified        â”‚      â”‚ preferences      â”‚
â”‚ created_at      â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ updated_at      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”‚ 1:N
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ oauth_accounts  â”‚      â”‚  two_factor_auth â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK)         â”‚      â”‚ id (PK)          â”‚
â”‚ user_id (FK)    â”‚      â”‚ user_id (FK)     â”‚
â”‚ provider        â”‚      â”‚ method           â”‚
â”‚ provider_user_idâ”‚      â”‚ secret           â”‚
â”‚ access_token    â”‚      â”‚ backup_codes     â”‚
â”‚ created_at      â”‚      â”‚ enabled          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚ created_at       â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â”‚ 1:N
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  login_history  â”‚      â”‚   user_tokens    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK)         â”‚      â”‚ id (PK)          â”‚
â”‚ user_id (FK)    â”‚      â”‚ user_id (FK)     â”‚
â”‚ ip_address      â”‚      â”‚ token            â”‚
â”‚ user_agent      â”‚      â”‚ type             â”‚
â”‚ device_type     â”‚      â”‚ expires_at       â”‚
â”‚ location        â”‚      â”‚ device_id        â”‚
â”‚ success         â”‚      â”‚ created_at       â”‚
â”‚ created_at      â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è¡¨ç»“æ„å®šä¹‰

```sql
-- ç”¨æˆ·ä¸»è¡¨
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE,
    phone VARCHAR(20) UNIQUE,
    password_hash VARCHAR(255),
    avatar_url VARCHAR(500),
    verified BOOLEAN DEFAULT FALSE,
    status VARCHAR(20) DEFAULT 'active',  -- active, suspended, deleted
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_login TIMESTAMP,
    
    CONSTRAINT username_format CHECK (username ~ '^[a-zA-Z0-9_]{4,50}$'),
    CONSTRAINT email_format CHECK (email ~ '^[^@]+@[^@]+\.[^@]+$')
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_phone ON users(phone);
CREATE INDEX idx_users_created_at ON users(created_at);

-- ç”¨æˆ·èµ„æ–™è¡¨
CREATE TABLE user_profiles (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    real_name VARCHAR(50),
    school VARCHAR(100),
    major VARCHAR(100),
    grade VARCHAR(20),
    bio TEXT,
    preferences JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_profiles_user_id ON user_profiles(user_id);

-- OAuthè´¦å·å…³è”è¡¨
CREATE TABLE oauth_accounts (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    provider VARCHAR(20) NOT NULL,  -- wechat, github, google
    provider_user_id VARCHAR(100) NOT NULL,
    access_token TEXT,
    refresh_token TEXT,
    expires_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(provider, provider_user_id)
);

CREATE INDEX idx_oauth_user_id ON oauth_accounts(user_id);
CREATE INDEX idx_oauth_provider ON oauth_accounts(provider, provider_user_id);

-- åŒå› ç´ è®¤è¯è¡¨
CREATE TABLE two_factor_auth (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    method VARCHAR(20) NOT NULL,  -- totp, sms, email
    secret VARCHAR(100),
    backup_codes JSONB,
    enabled BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_2fa_user_id ON two_factor_auth(user_id);

-- ç”¨æˆ·Tokenè¡¨
CREATE TABLE user_tokens (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    token VARCHAR(500) UNIQUE NOT NULL,
    type VARCHAR(20) NOT NULL,  -- access, refresh, reset_password
    device_id VARCHAR(100),
    device_info JSONB,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_used TIMESTAMP,
    
    CONSTRAINT token_type_check CHECK (type IN ('access', 'refresh', 'reset_password'))
);

CREATE INDEX idx_tokens_user_id ON user_tokens(user_id);
CREATE INDEX idx_tokens_token ON user_tokens(token);
CREATE INDEX idx_tokens_expires_at ON user_tokens(expires_at);

-- ç™»å½•å†å²è¡¨
CREATE TABLE login_history (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT REFERENCES users(id) ON DELETE SET NULL,
    username VARCHAR(50),
    ip_address VARCHAR(45),
    user_agent TEXT,
    device_type VARCHAR(20),  -- desktop, mobile, tablet
    location VARCHAR(100),
    success BOOLEAN,
    failure_reason VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_login_user_id ON login_history(user_id);
CREATE INDEX idx_login_created_at ON login_history(created_at);
CREATE INDEX idx_login_ip ON login_history(ip_address);

-- éªŒè¯ç è¡¨
CREATE TABLE verification_codes (
    id BIGSERIAL PRIMARY KEY,
    type VARCHAR(20) NOT NULL,  -- register, login, reset_password
    recipient VARCHAR(100) NOT NULL,  -- email or phone
    code VARCHAR(10) NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    used BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    CONSTRAINT code_type_check CHECK (type IN ('register', 'login', 'reset_password', 'change_email', 'change_phone'))
);

CREATE INDEX idx_codes_recipient ON verification_codes(recipient, type);
CREATE INDEX idx_codes_expires_at ON verification_codes(expires_at);
```

---

## ğŸ”Œ APIè®¾è®¡

### è®¤è¯ç›¸å…³æ¥å£

```yaml
# æ³¨å†Œ
POST /api/v1/auth/register
Request:
  {
    "username": "testuser",
    "email": "test@example.com",
    "password": "Test1234!",
    "verification_code": "123456"
  }
Response:
  {
    "success": true,
    "data": {
      "user_id": 12345,
      "username": "testuser",
      "access_token": "eyJ0eXAiOiJKV1QiLCJhbGc...",
      "refresh_token": "eyJ0eXAiOiJKV1QiLCJhbGc...",
      "expires_in": 3600
    }
  }

# ç™»å½•
POST /api/v1/auth/login
Request:
  {
    "username": "testuser",  # æˆ– email/phone
    "password": "Test1234!",
    "remember_me": true,
    "device_id": "abc123"
  }
Response:
  {
    "success": true,
    "data": {
      "user_id": 12345,
      "access_token": "eyJ0eXAiOiJKV1QiLCJhbGc...",
      "refresh_token": "eyJ0eXAiOiJKV1QiLCJhbGc...",
      "expires_in": 3600,
      "requires_2fa": false
    }
  }

# 2FAéªŒè¯
POST /api/v1/auth/verify-2fa
Request:
  {
    "user_id": 12345,
    "code": "123456",
    "temp_token": "temp_token_from_login"
  }
Response:
  {
    "success": true,
    "data": {
      "access_token": "eyJ0eXAiOiJKV1QiLCJhbGc...",
      "refresh_token": "eyJ0eXAiOiJKV1QiLCJhbGc..."
    }
  }

# åˆ·æ–°Token
POST /api/v1/auth/refresh
Request:
  {
    "refresh_token": "eyJ0eXAiOiJKV1QiLCJhbGc..."
  }
Response:
  {
    "success": true,
    "data": {
      "access_token": "eyJ0eXAiOiJKV1QiLCJhbGc...",
      "expires_in": 3600
    }
  }

# ç™»å‡º
POST /api/v1/auth/logout
Headers:
  Authorization: Bearer <access_token>
Response:
  {
    "success": true,
    "message": "Logged out successfully"
  }

# å‘é€éªŒè¯ç 
POST /api/v1/auth/send-code
Request:
  {
    "type": "register",  # register, login, reset_password
    "recipient": "test@example.com",  # email or phone
    "method": "email"  # email or sms
  }
Response:
  {
    "success": true,
    "message": "Verification code sent",
    "expires_in": 300
  }
```

### ç”¨æˆ·ä¿¡æ¯æ¥å£

```yaml
# è·å–å½“å‰ç”¨æˆ·ä¿¡æ¯
GET /api/v1/users/me
Headers:
  Authorization: Bearer <access_token>
Response:
  {
    "success": true,
    "data": {
      "id": 12345,
      "username": "testuser",
      "email": "test@example.com",
      "avatar_url": "https://cdn.example.com/avatars/12345.jpg",
      "verified": true,
      "created_at": "2025-11-12T10:00:00Z",
      "profile": {
        "real_name": "å¼ ä¸‰",
        "school": "æ¸…åå¤§å­¦",
        "major": "æ°´åˆ©å·¥ç¨‹",
        "grade": "å¤§ä¸‰"
      }
    }
  }

# æ›´æ–°ç”¨æˆ·ä¿¡æ¯
PUT /api/v1/users/me
Headers:
  Authorization: Bearer <access_token>
Request:
  {
    "avatar_url": "https://cdn.example.com/avatars/new.jpg",
    "profile": {
      "real_name": "å¼ ä¸‰",
      "bio": "çƒ­çˆ±å­¦ä¹ çš„å·¥ç¨‹å¸ˆ"
    }
  }
Response:
  {
    "success": true,
    "data": {
      "id": 12345,
      "username": "testuser",
      ...
    }
  }

# ä¿®æ”¹å¯†ç 
PUT /api/v1/users/me/password
Headers:
  Authorization: Bearer <access_token>
Request:
  {
    "old_password": "Test1234!",
    "new_password": "NewPass1234!"
  }
Response:
  {
    "success": true,
    "message": "Password updated successfully"
  }

# æ£€æŸ¥ç”¨æˆ·åå¯ç”¨æ€§
GET /api/v1/users/check-username?username=testuser
Response:
  {
    "available": false,
    "message": "Username already taken"
  }

# æ£€æŸ¥é‚®ç®±å¯ç”¨æ€§
GET /api/v1/users/check-email?email=test@example.com
Response:
  {
    "available": true
  }
```

---

## ğŸ”’ å®‰å…¨æ–¹æ¡ˆ

### 1. å¯†ç å®‰å…¨

```python
from passlib.context import CryptContext
import secrets

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class PasswordService:
    """å¯†ç æœåŠ¡"""
    
    @staticmethod
    def hash_password(password: str) -> str:
        """å“ˆå¸Œå¯†ç """
        return pwd_context.hash(password)
    
    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        """éªŒè¯å¯†ç """
        return pwd_context.verify(plain_password, hashed_password)
    
    @staticmethod
    def check_password_strength(password: str) -> dict:
        """æ£€æŸ¥å¯†ç å¼ºåº¦"""
        score = 0
        issues = []
        
        # é•¿åº¦æ£€æŸ¥
        if len(password) < 8:
            issues.append("å¯†ç é•¿åº¦è‡³å°‘8ä½")
        elif len(password) >= 12:
            score += 1
        
        # å¤æ‚åº¦æ£€æŸ¥
        if not re.search(r'[a-z]', password):
            issues.append("è‡³å°‘åŒ…å«ä¸€ä¸ªå°å†™å­—æ¯")
        else:
            score += 1
            
        if not re.search(r'[A-Z]', password):
            issues.append("è‡³å°‘åŒ…å«ä¸€ä¸ªå¤§å†™å­—æ¯")
        else:
            score += 1
            
        if not re.search(r'\d', password):
            issues.append("è‡³å°‘åŒ…å«ä¸€ä¸ªæ•°å­—")
        else:
            score += 1
            
        if not re.search(r'[@$!%*?&]', password):
            issues.append("å»ºè®®åŒ…å«ç‰¹æ®Šå­—ç¬¦")
        else:
            score += 1
        
        # å¸¸è§å¯†ç æ£€æŸ¥
        common_passwords = ['password', '12345678', 'qwerty']
        if password.lower() in common_passwords:
            issues.append("ä¸è¦ä½¿ç”¨å¸¸è§å¯†ç ")
            score = 0
        
        strength = 'weak'
        if score >= 4:
            strength = 'strong'
        elif score >= 3:
            strength = 'medium'
        
        return {
            'strength': strength,
            'score': score,
            'issues': issues,
            'valid': len(issues) == 0
        }
    
    @staticmethod
    def generate_random_password(length: int = 16) -> str:
        """ç”Ÿæˆéšæœºå¯†ç """
        alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@$!%*?"
        password = ''.join(secrets.choice(alphabet) for _ in range(length))
        return password
```

### 2. JWT Tokenç®¡ç†

```python
from datetime import datetime, timedelta
import jwt
from typing import Optional

class TokenService:
    """TokenæœåŠ¡"""
    
    def __init__(self):
        self.secret_key = settings.JWT_SECRET_KEY
        self.algorithm = "HS256"
        self.access_token_expire = timedelta(hours=1)
        self.refresh_token_expire = timedelta(days=7)
    
    def create_access_token(
        self, 
        user_id: int, 
        expires_delta: Optional[timedelta] = None
    ) -> str:
        """åˆ›å»ºè®¿é—®Token"""
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + self.access_token_expire
        
        to_encode = {
            "sub": str(user_id),
            "type": "access",
            "exp": expire,
            "iat": datetime.utcnow()
        }
        
        encoded_jwt = jwt.encode(
            to_encode, 
            self.secret_key, 
            algorithm=self.algorithm
        )
        
        return encoded_jwt
    
    def create_refresh_token(self, user_id: int) -> str:
        """åˆ›å»ºåˆ·æ–°Token"""
        expire = datetime.utcnow() + self.refresh_token_expire
        
        to_encode = {
            "sub": str(user_id),
            "type": "refresh",
            "exp": expire,
            "iat": datetime.utcnow()
        }
        
        encoded_jwt = jwt.encode(
            to_encode,
            self.secret_key,
            algorithm=self.algorithm
        )
        
        return encoded_jwt
    
    def verify_token(self, token: str, token_type: str = "access") -> Optional[int]:
        """éªŒè¯Token"""
        try:
            payload = jwt.decode(
                token,
                self.secret_key,
                algorithms=[self.algorithm]
            )
            
            if payload.get("type") != token_type:
                return None
            
            user_id: int = int(payload.get("sub"))
            return user_id
            
        except jwt.ExpiredSignatureError:
            # Tokenå·²è¿‡æœŸ
            return None
        except jwt.JWTError:
            # Tokenæ— æ•ˆ
            return None
    
    async def revoke_token(self, token: str):
        """æ’¤é”€Token"""
        # å°†TokenåŠ å…¥é»‘åå•
        await TokenBlacklist.create(
            token=token,
            revoked_at=datetime.utcnow()
        )
    
    async def is_token_revoked(self, token: str) -> bool:
        """æ£€æŸ¥Tokenæ˜¯å¦è¢«æ’¤é”€"""
        blacklisted = await TokenBlacklist.get(token=token)
        return blacklisted is not None
```

### 3. è®¿é—®æ§åˆ¶

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> User:
    """è·å–å½“å‰ç”¨æˆ·"""
    token = credentials.credentials
    
    # æ£€æŸ¥Tokenæ˜¯å¦è¢«æ’¤é”€
    if await token_service.is_token_revoked(token):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has been revoked"
        )
    
    # éªŒè¯Token
    user_id = token_service.verify_token(token)
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token"
        )
    
    # è·å–ç”¨æˆ·ä¿¡æ¯
    user = await User.get(id=user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    if user.status != 'active':
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User account is suspended"
        )
    
    return user

async def get_current_active_user(
    current_user: User = Depends(get_current_user)
) -> User:
    """è·å–å½“å‰æ´»è·ƒç”¨æˆ·"""
    if not current_user.verified:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Email not verified"
        )
    return current_user

def require_permission(permission: str):
    """æƒé™éªŒè¯è£…é¥°å™¨"""
    async def permission_checker(
        current_user: User = Depends(get_current_user)
    ) -> User:
        user_permissions = await get_user_permissions(current_user.id)
        if permission not in user_permissions:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Permission denied: {permission}"
            )
        return current_user
    return permission_checker

# ä½¿ç”¨ç¤ºä¾‹
@router.get("/admin/users")
async def list_users(
    current_user: User = Depends(require_permission("admin.users.list"))
):
    """åˆ—å‡ºç”¨æˆ· (éœ€è¦admin.users.listæƒé™)"""
    users = await User.all()
    return users
```

### 4. å®‰å…¨é˜²æŠ¤

```python
from fastapi import Request
from slowapi import Limiter
from slowapi.util import get_remote_address
import hashlib

# é€Ÿç‡é™åˆ¶
limiter = Limiter(key_func=get_remote_address)

class SecurityService:
    """å®‰å…¨æœåŠ¡"""
    
    @staticmethod
    async def check_ip_blacklist(ip: str) -> bool:
        """æ£€æŸ¥IPé»‘åå•"""
        blacklisted = await IPBlacklist.get(ip_address=ip)
        return blacklisted is not None
    
    @staticmethod
    async def add_to_blacklist(ip: str, reason: str):
        """æ·»åŠ åˆ°é»‘åå•"""
        await IPBlacklist.create(
            ip_address=ip,
            reason=reason,
            created_at=datetime.utcnow()
        )
    
    @staticmethod
    async def check_login_attempts(username: str, ip: str) -> bool:
        """æ£€æŸ¥ç™»å½•å°è¯•æ¬¡æ•°"""
        # æ£€æŸ¥æœ€è¿‘15åˆ†é’Ÿå†…çš„å¤±è´¥æ¬¡æ•°
        since = datetime.utcnow() - timedelta(minutes=15)
        failed_attempts = await LoginHistory.filter(
            username=username,
            ip_address=ip,
            success=False,
            created_at__gte=since
        ).count()
        
        return failed_attempts < 5
    
    @staticmethod
    def generate_csrf_token() -> str:
        """ç”ŸæˆCSRF Token"""
        return secrets.token_urlsafe(32)
    
    @staticmethod
    def verify_csrf_token(token: str, stored_token: str) -> bool:
        """éªŒè¯CSRF Token"""
        return secrets.compare_digest(token, stored_token)
    
    @staticmethod
    def sanitize_input(text: str) -> str:
        """æ¸…ç†è¾“å…¥"""
        # ç§»é™¤HTMLæ ‡ç­¾
        import bleach
        return bleach.clean(text, strip=True)

# ç™»å½•é€Ÿç‡é™åˆ¶
@router.post("/auth/login")
@limiter.limit("5/minute")
async def login(request: Request, credentials: LoginRequest):
    """ç™»å½• (é™åˆ¶: 5æ¬¡/åˆ†é’Ÿ)"""
    # æ£€æŸ¥IPé»‘åå•
    ip = request.client.host
    if await SecurityService.check_ip_blacklist(ip):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="IP blocked"
        )
    
    # æ£€æŸ¥ç™»å½•å°è¯•æ¬¡æ•°
    if not await SecurityService.check_login_attempts(
        credentials.username, 
        ip
    ):
        raise HTTPException(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail="Too many failed login attempts"
        )
    
    # ... ç™»å½•é€»è¾‘
```

---

## âš¡ æ€§èƒ½ä¼˜åŒ–

### 1. Redisç¼“å­˜

```python
import redis.asyncio as redis
import json

class CacheService:
    """ç¼“å­˜æœåŠ¡"""
    
    def __init__(self):
        self.redis = redis.from_url(
            settings.REDIS_URL,
            encoding="utf-8",
            decode_responses=True
        )
    
    async def get_user(self, user_id: int) -> Optional[User]:
        """ä»ç¼“å­˜è·å–ç”¨æˆ·"""
        key = f"user:{user_id}"
        cached = await self.redis.get(key)
        
        if cached:
            return User(**json.loads(cached))
        
        # ä»æ•°æ®åº“è·å–
        user = await User.get(id=user_id)
        if user:
            # ç¼“å­˜1å°æ—¶
            await self.redis.setex(
                key,
                3600,
                json.dumps(user.dict())
            )
        
        return user
    
    async def invalidate_user(self, user_id: int):
        """ä½¿ç”¨æˆ·ç¼“å­˜å¤±æ•ˆ"""
        key = f"user:{user_id}"
        await self.redis.delete(key)
    
    async def cache_session(
        self, 
        session_id: str, 
        user_id: int,
        ttl: int = 3600
    ):
        """ç¼“å­˜ä¼šè¯"""
        key = f"session:{session_id}"
        await self.redis.setex(key, ttl, str(user_id))
    
    async def get_session(self, session_id: str) -> Optional[int]:
        """è·å–ä¼šè¯"""
        key = f"session:{session_id}"
        user_id = await self.redis.get(key)
        return int(user_id) if user_id else None
```

### 2. æ•°æ®åº“ä¼˜åŒ–

```python
# ä½¿ç”¨æ•°æ®åº“è¿æ¥æ± 
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

engine = create_async_engine(
    settings.DATABASE_URL,
    echo=False,
    pool_size=20,
    max_overflow=40,
    pool_pre_ping=True,
    pool_recycle=3600
)

AsyncSessionLocal = sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False
)

# æ‰¹é‡æŸ¥è¯¢ä¼˜åŒ–
async def get_users_with_profiles(user_ids: List[int]) -> List[User]:
    """æ‰¹é‡è·å–ç”¨æˆ·åŠèµ„æ–™"""
    query = (
        select(User)
        .options(selectinload(User.profile))
        .where(User.id.in_(user_ids))
    )
    
    result = await db.execute(query)
    return result.scalars().all()
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2025-11-12
